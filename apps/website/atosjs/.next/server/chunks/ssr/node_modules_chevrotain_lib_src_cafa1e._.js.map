{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"version.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/version.ts"],"sourcesContent":["// needs a separate module as this is required inside chevrotain productive code\n// and also in the entry point for webpack(api.ts).\n// A separate file avoids cyclic dependencies and webpack errors.\nexport const VERSION = \"11.0.3\";\n"],"names":[],"mappings":"AAAA,gFAAgF;AAChF,mDAAmD;AACnD,iEAAiE;;;;AAC1D,MAAM,OAAO,GAAG,QAAQ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"file":"rest.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/grammar/rest.ts"],"sourcesContent":["import { drop, forEach } from \"lodash-es\";\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport { IProduction } from \"@chevrotain/types\";\n\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nexport abstract class RestWalker {\n  walk(prod: { definition: IProduction[] }, prevRest: any[] = []): void {\n    forEach(prod.definition, (subProd: IProduction, index) => {\n      const currRest = drop(prod.definition, index + 1);\n      /* istanbul ignore else */\n      if (subProd instanceof NonTerminal) {\n        this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof Terminal) {\n        this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternative) {\n        this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof Option) {\n        this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatory) {\n        this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof Repetition) {\n        this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternation) {\n        this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {}\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {}\n\n  walkFlat(\n    flatProd: Alternative,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABCDEF => after the D the rest is EF\n    const fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, <any>fullOrRest);\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    const fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, <any>fullOrRest);\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    const fullAtLeastOneRest: IProduction[] = [\n      new Option({ definition: atLeastOneProd.definition }),\n    ].concat(<any>currRest, <any>prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    const fullAtLeastOneSepRest = restForRepetitionWithSeparator(\n      atLeastOneSepProd,\n      currRest,\n      prevRest,\n    );\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    const fullManyRest: IProduction[] = [\n      new Option({ definition: manyProd.definition }),\n    ].concat(<any>currRest, <any>prevRest);\n    this.walk(manyProd, fullManyRest);\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    const fullManySepRest = restForRepetitionWithSeparator(\n      manySepProd,\n      currRest,\n      prevRest,\n    );\n    this.walk(manySepProd, fullManySepRest);\n  }\n\n  walkOr(\n    orProd: Alternation,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n    const fullOrRest = currRest.concat(prevRest);\n    // walk all different alternatives\n    forEach(orProd.definition, (alt) => {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      const prodWrapper = new Alternative({ definition: [alt] });\n      this.walk(prodWrapper, <any>fullOrRest);\n    });\n  }\n}\n\nfunction restForRepetitionWithSeparator(\n  repSepProd: RepetitionWithSeparator,\n  currRest: IProduction[],\n  prevRest: IProduction[],\n) {\n  const repSepRest = [\n    new Option({\n      definition: [\n        new Terminal({ terminalType: repSepProd.separator }) as IProduction,\n      ].concat(repSepProd.definition),\n    }) as IProduction,\n  ];\n  const fullRepSepRest: IProduction[] = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 126, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"file":"first.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/grammar/first.ts"],"sourcesContent":["import { flatten, map, uniq } from \"lodash-es\";\nimport {\n  isBranchingProd,\n  isOptionalProd,\n  isSequenceProd,\n  NonTerminal,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport { IProduction, TokenType } from \"@chevrotain/types\";\n\nexport function first(prod: IProduction): TokenType[] {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first((<NonTerminal>prod).referencedRule);\n  } else if (prod instanceof Terminal) {\n    return firstForTerminal(<Terminal>prod);\n  } else if (isSequenceProd(prod)) {\n    return firstForSequence(prod);\n  } else if (isBranchingProd(prod)) {\n    return firstForBranching(prod);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexport function firstForSequence(prod: {\n  definition: IProduction[];\n}): TokenType[] {\n  let firstSet: TokenType[] = [];\n  const seq = prod.definition;\n  let nextSubProdIdx = 0;\n  let hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  let currSubProd;\n  // so we enter the loop at least once (if the definition is not empty\n  let isLastInnerProdOptional = true;\n  // scan a sequence until it's end or until we have found a NONE optional production in it\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx];\n    isLastInnerProdOptional = isOptionalProd(currSubProd);\n    firstSet = firstSet.concat(first(currSubProd));\n    nextSubProdIdx = nextSubProdIdx + 1;\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  }\n\n  return uniq(firstSet);\n}\n\nexport function firstForBranching(prod: {\n  definition: IProduction[];\n}): TokenType[] {\n  const allAlternativesFirsts: TokenType[][] = map(\n    prod.definition,\n    (innerProd) => {\n      return first(innerProd);\n    },\n  );\n  return uniq(flatten<TokenType>(allAlternativesFirsts));\n}\n\nexport function firstForTerminal(terminal: Terminal): TokenType[] {\n  return [terminal.terminalType];\n}\n"],"names":[],"mappings":";;;;;;AACA,OAAO,EACL,eAAe,EACf,cAAc,EACd,cAAc,EACd,WAAW,EACX,QAAQ,GACT,MAAM,kBAAkB,CAAC;;;;;AAP1B,OAAO,EAAE,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,WAAW,CAAC;;;AAUzC,SAAU,KAAK,CAAC,IAAiB;IACrC,wBAAA,EAA0B,CAC1B,IAAI,IAAI,mMAAY,cAAW,EAAE;QAC/B,+CAA+C;QAC/C,0BAA0B;QAC1B,yBAAyB;QACzB,iCAAiC;QACjC,6EAA6E;QAC7E,+DAA+D;QAC/D,oEAAoE;QACpE,sFAAsF;QACtF,OAAO,KAAK,CAAe,IAAK,CAAC,cAAc,CAAC,CAAC;KAClD,MAAM,IAAI,IAAI,mMAAY,WAAQ,EAAE;QACnC,OAAO,gBAAgB,CAAW,IAAI,CAAC,CAAC;KACzC,MAAM,iMAAI,iBAAA,AAAc,EAAC,IAAI,CAAC,EAAE;QAC/B,OAAO,gBAAgB,CAAC,IAAI,CAAC,CAAC;KAC/B,MAAM,iMAAI,kBAAA,AAAe,EAAC,IAAI,CAAC,EAAE;QAChC,OAAO,iBAAiB,CAAC,IAAI,CAAC,CAAC;KAChC,MAAM;QACL,MAAM,KAAK,CAAC,sBAAsB,CAAC,CAAC;KACrC;AACH,CAAC;AAEK,SAAU,gBAAgB,CAAC,IAEhC;IACC,IAAI,QAAQ,GAAgB,EAAE,CAAC;IAC/B,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC;IAC5B,IAAI,cAAc,GAAG,CAAC,CAAC;IACvB,IAAI,sBAAsB,GAAG,GAAG,CAAC,MAAM,GAAG,cAAc,CAAC;IACzD,IAAI,WAAW,CAAC;IAChB,qEAAqE;IACrE,IAAI,uBAAuB,GAAG,IAAI,CAAC;IACnC,yFAAyF;IACzF,MAAO,sBAAsB,IAAI,uBAAuB,CAAE;QACxD,WAAW,GAAG,GAAG,CAAC,cAAc,CAAC,CAAC;QAClC,uBAAuB,gMAAG,iBAAA,AAAc,EAAC,WAAW,CAAC,CAAC;QACtD,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC;QAC/C,cAAc,GAAG,cAAc,GAAG,CAAC,CAAC;QACpC,sBAAsB,GAAG,GAAG,CAAC,MAAM,GAAG,cAAc,CAAC;KACtD;IAED,8MAAO,OAAA,AAAI,EAAC,QAAQ,CAAC,CAAC;AACxB,CAAC;AAEK,SAAU,iBAAiB,CAAC,IAEjC;IACC,MAAM,qBAAqB,GAAkB,2MAAA,AAAG,EAC9C,IAAI,CAAC,UAAU,EACf,CAAC,SAAS,EAAE,EAAE;QACZ,OAAO,KAAK,CAAC,SAAS,CAAC,CAAC;IAC1B,CAAC,CACF,CAAC;IACF,8MAAO,OAAA,AAAI,+MAAC,UAAA,AAAO,EAAY,qBAAqB,CAAC,CAAC,CAAC;AACzD,CAAC;AAEK,SAAU,gBAAgB,CAAC,QAAkB;IACjD,OAAO;QAAC,QAAQ,CAAC,YAAY;KAAC,CAAC;AACjC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"file":"constants.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/constants.ts"],"sourcesContent":["// TODO: can this be removed? where is it used?\nexport const IN = \"_~IN~_\";\n"],"names":[],"mappings":"AAAA,+CAA+C;;;;AACxC,MAAM,EAAE,GAAG,QAAQ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 207, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 213, "column": 0}, "map": {"version":3,"file":"follow.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/grammar/follow.ts"],"sourcesContent":["import { RestWalker } from \"./rest.js\";\nimport { first } from \"./first.js\";\nimport { assign, forEach } from \"lodash-es\";\nimport { IN } from \"../constants.js\";\nimport { Alternative, NonTerminal, Rule, Terminal } from \"@chevrotain/gast\";\nimport { IProduction, TokenType } from \"@chevrotain/types\";\n\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nexport class ResyncFollowsWalker extends RestWalker {\n  public follows: Record<string, TokenType[]> = {};\n\n  constructor(private topProd: Rule) {\n    super();\n  }\n\n  startWalking(): Record<string, TokenType[]> {\n    this.walk(this.topProd);\n    return this.follows;\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // do nothing! just like in the public sector after 13:00\n  }\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    const followName =\n      buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n      this.topProd.name;\n    const fullRest: IProduction[] = currRest.concat(prevRest);\n    const restProd = new Alternative({ definition: fullRest });\n    const t_in_topProd_follows = first(restProd);\n    this.follows[followName] = t_in_topProd_follows;\n  }\n}\n\nexport function computeAllProdsFollows(\n  topProductions: Rule[],\n): Record<string, TokenType[]> {\n  const reSyncFollows = {};\n\n  forEach(topProductions, (topProd) => {\n    const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n    assign(reSyncFollows, currRefsFollow);\n  });\n  return reSyncFollows;\n}\n\nexport function buildBetweenProdsFollowPrefix(\n  inner: Rule,\n  occurenceInParent: number,\n): string {\n  return inner.name + occurenceInParent + IN;\n}\n\nexport function buildInProdFollowPrefix(terminal: Terminal): string {\n  const terminalName = terminal.terminalType.name;\n  return terminalName + terminal.idx + IN;\n}\n"],"names":[],"mappings":";;;;;;AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,WAAW,CAAC;AACvC,OAAO,EAAE,KAAK,EAAE,MAAM,YAAY,CAAC;AAEnC,OAAO,EAAE,EAAE,EAAE,MAAM,iBAAiB,CAAC;;AACrC,OAAO,EAAE,WAAW,EAA+B,MAAM,kBAAkB,CAAC;;AAF5E,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;;;;;;AAOtC,MAAO,mBAAoB,yMAAQ,aAAU;IAGjD,YAAoB,OAAa,CAAA;QAC/B,KAAK,EAAE,CAAC;QADU,IAAA,CAAA,OAAO,GAAP,OAAO,CAAM;QAF1B,IAAA,CAAA,OAAO,GAAgC,CAAA,CAAE,CAAC;IAIjD,CAAC;IAED,YAAY,GAAA;QACV,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACxB,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAED,YAAY,CACV,QAAkB,EAClB,QAAuB,EACvB,QAAuB,EAAA;IAEvB,yDAAyD;IAC3D,CAAC;IAED,WAAW,CACT,OAAoB,EACpB,QAAuB,EACvB,QAAuB,EAAA;QAEvB,MAAM,UAAU,GACd,6BAA6B,CAAC,OAAO,CAAC,cAAc,EAAE,OAAO,CAAC,GAAG,CAAC,GAClE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;QACpB,MAAM,QAAQ,GAAkB,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC1D,MAAM,QAAQ,GAAG,2LAAI,cAAW,CAAC;YAAE,UAAU,EAAE,QAAQ;QAAA,CAAE,CAAC,CAAC;QAC3D,MAAM,oBAAoB,wMAAG,QAAA,AAAK,EAAC,QAAQ,CAAC,CAAC;QAC7C,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,oBAAoB,CAAC;IAClD,CAAC;CACF;AAEK,SAAU,sBAAsB,CACpC,cAAsB;IAEtB,MAAM,aAAa,GAAG,CAAA,CAAE,CAAC;iNAEzB,UAAA,AAAO,EAAC,cAAc,EAAE,CAAC,OAAO,EAAE,EAAE;QAClC,MAAM,cAAc,GAAG,IAAI,mBAAmB,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,CAAC;mNACvE,SAAA,AAAM,EAAC,aAAa,EAAE,cAAc,CAAC,CAAC;IACxC,CAAC,CAAC,CAAC;IACH,OAAO,aAAa,CAAC;AACvB,CAAC;AAEK,SAAU,6BAA6B,CAC3C,KAAW,EACX,iBAAyB;IAEzB,OAAO,KAAK,CAAC,IAAI,GAAG,iBAAiB,6LAAG,KAAE,CAAC;AAC7C,CAAC;AAEK,SAAU,uBAAuB,CAAC,QAAkB;IACxD,MAAM,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC;IAChD,OAAO,YAAY,GAAG,QAAQ,CAAC,GAAG,6LAAG,KAAE,CAAC;AAC1C,CAAC","ignoreList":[0]}},
    {"offset": {"line": 269, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 275, "column": 0}, "map": {"version":3,"file":"reg_exp_parser.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/scan/reg_exp_parser.ts"],"sourcesContent":["import {\n  Alternative,\n  Assertion,\n  Atom,\n  Disjunction,\n  RegExpParser,\n  RegExpPattern,\n} from \"@chevrotain/regexp-to-ast\";\n\nlet regExpAstCache: { [regex: string]: RegExpPattern } = {};\nconst regExpParser = new RegExpParser();\n\n// this should be moved to regexp-to-ast\nexport type ASTNode =\n  | RegExpPattern\n  | Disjunction\n  | Alternative\n  | Assertion\n  | Atom;\n\nexport function getRegExpAst(regExp: RegExp): RegExpPattern {\n  const regExpStr = regExp.toString();\n  if (regExpAstCache.hasOwnProperty(regExpStr)) {\n    return regExpAstCache[regExpStr];\n  } else {\n    const regExpAst = regExpParser.pattern(regExpStr);\n    regExpAstCache[regExpStr] = regExpAst;\n    return regExpAst;\n  }\n}\n\nexport function clearRegExpParserCache() {\n  regExpAstCache = {};\n}\n"],"names":[],"mappings":";;;;;AAAA,OAAO,EAKL,YAAY,GAEb,MAAM,2BAA2B,CAAC;;AAEnC,IAAI,cAAc,GAAuC,CAAA,CAAE,CAAC;AAC5D,MAAM,YAAY,GAAG,qNAAI,eAAY,EAAE,CAAC;AAUlC,SAAU,YAAY,CAAC,MAAc;IACzC,MAAM,SAAS,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;IACpC,IAAI,cAAc,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE;QAC5C,OAAO,cAAc,CAAC,SAAS,CAAC,CAAC;KAClC,MAAM;QACL,MAAM,SAAS,GAAG,YAAY,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAClD,cAAc,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC;QACtC,OAAO,SAAS,CAAC;KAClB;AACH,CAAC;AAEK,SAAU,sBAAsB;IACpC,cAAc,GAAG,CAAA,CAAE,CAAC;AACtB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 297, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 303, "column": 0}, "map": {"version":3,"file":"reg_exp.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/scan/reg_exp.ts"],"sourcesContent":["import {\n  Alternative,\n  Atom,\n  BaseRegExpVisitor,\n  Character,\n  Disjunction,\n  Group,\n  Set,\n} from \"@chevrotain/regexp-to-ast\";\nimport { every, find, forEach, includes, isArray, values } from \"lodash-es\";\nimport { PRINT_ERROR, PRINT_WARNING } from \"@chevrotain/utils\";\nimport { ASTNode, getRegExpAst } from \"./reg_exp_parser.js\";\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer.js\";\n\nconst complementErrorMessage =\n  \"Complement Sets are not supported for first char optimization\";\nexport const failedOptimizationPrefixMsg =\n  'Unable to use \"first char\" lexer optimizations:\\n';\n\nexport function getOptimizedStartCodesIndices(\n  regExp: RegExp,\n  ensureOptimizations = false,\n): number[] {\n  try {\n    const ast = getRegExpAst(regExp);\n    const firstChars = firstCharOptimizedIndices(\n      ast.value,\n      {},\n      ast.flags.ignoreCase,\n    );\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\n          `${failedOptimizationPrefixMsg}` +\n            `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n            \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\",\n        );\n      }\n    } else {\n      let msgSuffix = \"\";\n      if (ensureOptimizations) {\n        msgSuffix =\n          \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n      PRINT_ERROR(\n        `${failedOptimizationPrefixMsg}\\n` +\n          `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n          `\\tUsing the @chevrotain/regexp-to-ast library\\n` +\n          \"\\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues\" +\n          msgSuffix,\n      );\n    }\n  }\n\n  return [];\n}\n\nexport function firstCharOptimizedIndices(\n  ast: ASTNode,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean,\n): number[] {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (let i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n      break;\n    case \"Alternative\":\n      const terms = ast.value;\n      for (let i = 0; i < terms.length; i++) {\n        const term = terms[i];\n\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n\n        const atom = term;\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n            forEach(atom.value, (code) => {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                const range = code as any;\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to && rangeCode < minOptimizationVal;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= minOptimizationVal) {\n                    const minUnOptVal =\n                      range.from >= minOptimizationVal\n                        ? range.from\n                        : minOptimizationVal;\n                    const maxUnOptVal = range.to;\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n\n                    for (\n                      let currOptIdx = minOptIdx;\n                      currOptIdx <= maxOptIdx;\n                      currOptIdx++\n                    ) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        }\n\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        const isOptionalQuantifier =\n          atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n        if (\n          // A group may be optional due to empty contents /(?:)/\n          // or if everything inside it is optional /((a)?)/\n          (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n          // If this term is not a group it may only be optional if it has an optional quantifier\n          (atom.type !== \"Group\" && isOptionalQuantifier === false)\n        ) {\n          break;\n        }\n      }\n      break;\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\");\n  }\n\n  // console.log(Object.keys(result).length)\n  return values(result);\n}\n\nfunction addOptimizedIdxToResult(\n  code: number,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean,\n) {\n  const optimizedCharIdx = charCodeToOptimizedIndex(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\n\nfunction handleIgnoreCase(\n  code: number,\n  result: { [charCode: number]: number },\n) {\n  const char = String.fromCharCode(code);\n  const upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    const lowerChar = char.toLowerCase();\n    if (lowerChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(\n        lowerChar.charCodeAt(0),\n      );\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\n\nfunction findCode(setNode: Set, targetCharCodes: number[]) {\n  return find(setNode.value, (codeOrRange) => {\n    if (typeof codeOrRange === \"number\") {\n      return includes(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      const range = <any>codeOrRange;\n      return (\n        find(\n          targetCharCodes,\n          (targetCode) => range.from <= targetCode && targetCode <= range.to,\n        ) !== undefined\n      );\n    }\n  });\n}\n\nfunction isWholeOptional(ast: any): boolean {\n  const quantifier = (ast as Atom).quantifier;\n  if (quantifier && quantifier.atLeast === 0) {\n    return true;\n  }\n\n  if (!ast.value) {\n    return false;\n  }\n\n  return isArray(ast.value)\n    ? every(ast.value, isWholeOptional)\n    : isWholeOptional(ast.value);\n}\n\nclass CharCodeFinder extends BaseRegExpVisitor {\n  found: boolean = false;\n\n  constructor(private targetCharCodes: number[]) {\n    super();\n  }\n\n  visitChildren(node: ASTNode) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    }\n\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n\n    super.visitChildren(node);\n  }\n\n  visitCharacter(node: Character) {\n    if (includes(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  }\n\n  visitSet(node: Set) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  }\n}\n\nexport function canMatchCharCode(\n  charCodes: number[],\n  pattern: RegExp | string,\n) {\n  if (pattern instanceof RegExp) {\n    const ast = getRegExpAst(pattern);\n    const charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return (\n      find(<any>pattern, (char) => {\n        return includes(charCodes, (<string>char).charCodeAt(0));\n      }) !== undefined\n    );\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 530, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 536, "column": 0}, "map": {"version":3,"file":"lexer.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/scan/lexer.ts"],"sourcesContent":["import { BaseRegExpVisitor } from \"@chevrotain/regexp-to-ast\";\nimport {\n  IRegExpExec,\n  Lexer,\n  LexerDefinitionErrorType,\n} from \"./lexer_public.js\";\nimport {\n  compact,\n  defaults,\n  difference,\n  filter,\n  find,\n  first,\n  flatten,\n  forEach,\n  has,\n  includes,\n  indexOf,\n  isArray,\n  isEmpty,\n  isFunction,\n  isRegExp,\n  isString,\n  isUndefined,\n  keys,\n  map,\n  reduce,\n  reject,\n  values,\n} from \"lodash-es\";\nimport { PRINT_ERROR } from \"@chevrotain/utils\";\nimport {\n  canMatchCharCode,\n  failedOptimizationPrefixMsg,\n  getOptimizedStartCodesIndices,\n} from \"./reg_exp.js\";\nimport {\n  ILexerDefinitionError,\n  ILineTerminatorsTester,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType,\n} from \"@chevrotain/types\";\nimport { getRegExpAst } from \"./reg_exp_parser.js\";\n\nconst PATTERN = \"PATTERN\";\nexport const DEFAULT_MODE = \"defaultMode\";\nexport const MODES = \"modes\";\n\nexport interface IPatternConfig {\n  pattern: IRegExpExec | string;\n  longerAlt: number[] | undefined;\n  canLineTerminator: boolean;\n  isCustom: boolean;\n  short: number | false;\n  group: string | undefined | false;\n  push: string | undefined;\n  pop: boolean;\n  tokenType: TokenType;\n  tokenTypeIdx: number;\n}\n\nexport interface IAnalyzeResult {\n  patternIdxToConfig: IPatternConfig[];\n  charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] };\n  emptyGroups: { [groupName: string]: IToken[] };\n  hasCustom: boolean;\n  canBeOptimized: boolean;\n}\n\nexport let SUPPORT_STICKY =\n  typeof (<any>new RegExp(\"(?:)\")).sticky === \"boolean\";\n\nexport function disableSticky() {\n  SUPPORT_STICKY = false;\n}\n\nexport function enableSticky() {\n  SUPPORT_STICKY = true;\n}\n\nexport function analyzeTokenTypes(\n  tokenTypes: TokenType[],\n  options: {\n    positionTracking?: \"full\" | \"onlyStart\" | \"onlyOffset\";\n    ensureOptimizations?: boolean;\n    lineTerminatorCharacters?: (number | string)[];\n    // TODO: should `useSticky` be an argument here?\n    useSticky?: boolean;\n    safeMode?: boolean;\n    tracer?: (msg: string, action: () => void) => void;\n  },\n): IAnalyzeResult {\n  options = defaults(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false as boolean,\n    safeMode: false as boolean,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: (msg: string, action: Function) => action(),\n  });\n\n  const tracer = options.tracer!;\n\n  tracer(\"initCharCodeToOptimizedIndexMap\", () => {\n    initCharCodeToOptimizedIndexMap();\n  });\n\n  let onlyRelevantTypes: TokenType[];\n  tracer(\"Reject Lexer.NA\", () => {\n    onlyRelevantTypes = reject(tokenTypes, (currType) => {\n      return currType[PATTERN] === Lexer.NA;\n    });\n  });\n\n  let hasCustom = false;\n  let allTransformedPatterns: (IRegExpExec | string)[];\n  tracer(\"Transform Patterns\", () => {\n    hasCustom = false;\n    allTransformedPatterns = map(\n      onlyRelevantTypes,\n      (currType): IRegExpExec | string => {\n        const currPattern = currType[PATTERN];\n\n        /* istanbul ignore else */\n        if (isRegExp(currPattern)) {\n          const regExpSource = currPattern.source;\n          if (\n            regExpSource.length === 1 &&\n            // only these regExp meta characters which can appear in a length one regExp\n            regExpSource !== \"^\" &&\n            regExpSource !== \"$\" &&\n            regExpSource !== \".\" &&\n            !currPattern.ignoreCase\n          ) {\n            return regExpSource;\n          } else if (\n            regExpSource.length === 2 &&\n            regExpSource[0] === \"\\\\\" &&\n            // not a meta character\n            !includes(\n              [\n                \"d\",\n                \"D\",\n                \"s\",\n                \"S\",\n                \"t\",\n                \"r\",\n                \"n\",\n                \"t\",\n                \"0\",\n                \"c\",\n                \"b\",\n                \"B\",\n                \"f\",\n                \"v\",\n                \"w\",\n                \"W\",\n              ],\n              regExpSource[1],\n            )\n          ) {\n            // escaped meta Characters: /\\+/ /\\[/\n            // or redundant escaping: /\\a/\n            // without the escaping \"\\\"\n            return regExpSource[1];\n          } else {\n            return options.useSticky\n              ? addStickyFlag(currPattern)\n              : addStartOfInput(currPattern);\n          }\n        } else if (isFunction(currPattern)) {\n          hasCustom = true;\n          // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n          return { exec: currPattern };\n        } else if (typeof currPattern === \"object\") {\n          hasCustom = true;\n          // ICustomPattern\n          return currPattern;\n        } else if (typeof currPattern === \"string\") {\n          if (currPattern.length === 1) {\n            return currPattern;\n          } else {\n            const escapedRegExpString = currPattern.replace(\n              /[\\\\^$.*+?()[\\]{}|]/g,\n              \"\\\\$&\",\n            );\n            const wrappedRegExp = new RegExp(escapedRegExpString);\n            return options.useSticky\n              ? addStickyFlag(wrappedRegExp)\n              : addStartOfInput(wrappedRegExp);\n          }\n        } else {\n          throw Error(\"non exhaustive match\");\n        }\n      },\n    );\n  });\n\n  let patternIdxToType: number[];\n  let patternIdxToGroup: (string | undefined | false)[];\n  let patternIdxToLongerAltIdxArr: (number[] | undefined)[];\n  let patternIdxToPushMode: (string | undefined)[];\n  let patternIdxToPopMode: boolean[];\n  tracer(\"misc mapping\", () => {\n    patternIdxToType = map(\n      onlyRelevantTypes,\n      (currType) => currType.tokenTypeIdx!,\n    );\n\n    patternIdxToGroup = map(onlyRelevantTypes, (clazz: any) => {\n      const groupName = clazz.GROUP;\n      /* istanbul ignore next */\n      if (groupName === Lexer.SKIPPED) {\n        return undefined;\n      } else if (isString(groupName)) {\n        return groupName;\n      } else if (isUndefined(groupName)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n\n    patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz: any) => {\n      const longerAltType = clazz.LONGER_ALT;\n\n      if (longerAltType) {\n        const longerAltIdxArr = isArray(longerAltType)\n          ? map(longerAltType, (type: any) => indexOf(onlyRelevantTypes, type))\n          : [indexOf(onlyRelevantTypes, longerAltType)];\n        return longerAltIdxArr;\n      }\n    });\n\n    patternIdxToPushMode = map(\n      onlyRelevantTypes,\n      (clazz: any) => clazz.PUSH_MODE,\n    );\n\n    patternIdxToPopMode = map(onlyRelevantTypes, (clazz: any) =>\n      has(clazz, \"POP_MODE\"),\n    );\n  });\n\n  let patternIdxToCanLineTerminator: boolean[];\n  tracer(\"Line Terminator Handling\", () => {\n    const lineTerminatorCharCodes = getCharCodes(\n      options.lineTerminatorCharacters!,\n    );\n    patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false);\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n        if (has(tokType, \"LINE_BREAKS\")) {\n          return !!tokType.LINE_BREAKS;\n        } else {\n          return (\n            checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n            canMatchCharCode(\n              lineTerminatorCharCodes,\n              tokType.PATTERN as RegExp | string,\n            )\n          );\n        }\n      });\n    }\n  });\n\n  let patternIdxToIsCustom: boolean[];\n  let patternIdxToShort: (number | false)[];\n  let emptyGroups!: { [groupName: string]: IToken[] };\n  let patternIdxToConfig!: IPatternConfig[];\n  tracer(\"Misc Mapping #2\", () => {\n    patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n    patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n\n    emptyGroups = reduce(\n      onlyRelevantTypes,\n      (acc, clazz: any) => {\n        const groupName = clazz.GROUP;\n        if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n          acc[groupName] = [];\n        }\n        return acc;\n      },\n      {} as { [groupName: string]: IToken[] },\n    );\n\n    patternIdxToConfig = map(\n      allTransformedPatterns,\n      (x, idx): IPatternConfig => {\n        return {\n          pattern: allTransformedPatterns[idx],\n          longerAlt: patternIdxToLongerAltIdxArr[idx],\n          canLineTerminator: patternIdxToCanLineTerminator[idx],\n          isCustom: patternIdxToIsCustom[idx],\n          short: patternIdxToShort[idx],\n          group: patternIdxToGroup[idx],\n          push: patternIdxToPushMode[idx],\n          pop: patternIdxToPopMode[idx],\n          tokenTypeIdx: patternIdxToType[idx],\n          tokenType: onlyRelevantTypes[idx],\n        };\n      },\n    );\n  });\n\n  let canBeOptimized = true;\n  let charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] } =\n    [];\n\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", () => {\n      charCodeToPatternIdxToConfig = reduce(\n        onlyRelevantTypes,\n        (result, currTokType, idx) => {\n          if (typeof currTokType.PATTERN === \"string\") {\n            const charCode = currTokType.PATTERN.charCodeAt(0);\n            const optimizedIdx = charCodeToOptimizedIndex(charCode);\n            addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n          } else if (isArray(currTokType.START_CHARS_HINT)) {\n            let lastOptimizedIdx: number;\n            forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n              const charCode =\n                typeof charOrInt === \"string\"\n                  ? charOrInt.charCodeAt(0)\n                  : charOrInt;\n              const currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n              // Avoid adding the config multiple times\n              /* istanbul ignore else */\n              // - Difficult to check this scenario effects as it is only a performance\n              //   optimization that does not change correctness\n              if (lastOptimizedIdx !== currOptimizedIdx) {\n                lastOptimizedIdx = currOptimizedIdx;\n                addToMapOfArrays(\n                  result,\n                  currOptimizedIdx,\n                  patternIdxToConfig[idx],\n                );\n              }\n            });\n          } else if (isRegExp(currTokType.PATTERN)) {\n            if (currTokType.PATTERN.unicode) {\n              canBeOptimized = false;\n              if (options.ensureOptimizations) {\n                PRINT_ERROR(\n                  `${failedOptimizationPrefixMsg}` +\n                    `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                    \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\",\n                );\n              }\n            } else {\n              const optimizedCodes = getOptimizedStartCodesIndices(\n                currTokType.PATTERN,\n                options.ensureOptimizations,\n              );\n              /* istanbul ignore if */\n              // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n              // the first should be a different validation and the second cannot be tested.\n              if (isEmpty(optimizedCodes)) {\n                // we cannot understand what codes may start possible matches\n                // The optimization correctness requires knowing start codes for ALL patterns.\n                // Not actually sure this is an error, no debug message\n                canBeOptimized = false;\n              }\n              forEach(optimizedCodes, (code) => {\n                addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n              });\n            }\n          } else {\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(\n                `${failedOptimizationPrefixMsg}` +\n                  `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                  \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                  \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\",\n              );\n            }\n            canBeOptimized = false;\n          }\n\n          return result;\n        },\n        [] as { [charCode: number]: IPatternConfig[] },\n      );\n    });\n  }\n\n  return {\n    emptyGroups: emptyGroups,\n    patternIdxToConfig: patternIdxToConfig,\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n    hasCustom: hasCustom,\n    canBeOptimized: canBeOptimized,\n  };\n}\n\nexport function validatePatterns(\n  tokenTypes: TokenType[],\n  validModesNames: string[],\n): ILexerDefinitionError[] {\n  let errors: ILexerDefinitionError[] = [];\n\n  const missingResult = findMissingPatterns(tokenTypes);\n  errors = errors.concat(missingResult.errors);\n\n  const invalidResult = findInvalidPatterns(missingResult.valid);\n  const validTokenTypes = invalidResult.valid;\n  errors = errors.concat(invalidResult.errors);\n\n  errors = errors.concat(validateRegExpPattern(validTokenTypes));\n\n  errors = errors.concat(findInvalidGroupType(validTokenTypes));\n\n  errors = errors.concat(\n    findModesThatDoNotExist(validTokenTypes, validModesNames),\n  );\n\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n\n  return errors;\n}\n\nfunction validateRegExpPattern(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  let errors: ILexerDefinitionError[] = [];\n  const withRegExpPatterns = filter(tokenTypes, (currTokType) =>\n    isRegExp(currTokType[PATTERN]),\n  );\n\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n\n  return errors;\n}\n\nexport interface ILexerFilterResult {\n  errors: ILexerDefinitionError[];\n  valid: TokenType[];\n}\n\nexport function findMissingPatterns(\n  tokenTypes: TokenType[],\n): ILexerFilterResult {\n  const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n    return !has(currType, PATTERN);\n  });\n\n  const errors = map(tokenTypesWithMissingPattern, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType],\n    };\n  });\n\n  const valid = difference(tokenTypes, tokenTypesWithMissingPattern);\n  return { errors, valid };\n}\n\nexport function findInvalidPatterns(\n  tokenTypes: TokenType[],\n): ILexerFilterResult {\n  const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN];\n    return (\n      !isRegExp(pattern) &&\n      !isFunction(pattern) &&\n      !has(pattern, \"exec\") &&\n      !isString(pattern)\n    );\n  });\n\n  const errors = map(tokenTypesWithInvalidPattern, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' can only be a RegExp, a\" +\n        \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType],\n    };\n  });\n\n  const valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\n  return { errors, valid };\n}\n\nconst end_of_input = /[^\\\\][$]/;\n\nexport function findEndOfInputAnchor(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  class EndAnchorFinder extends BaseRegExpVisitor {\n    found = false;\n\n    visitEndAnchor(node: unknown) {\n      this.found = true;\n    }\n  }\n\n  const invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN;\n\n    try {\n      const regexpAst = getRegExpAst(pattern as RegExp);\n      const endAnchorVisitor = new EndAnchorFinder();\n      endAnchorVisitor.visit(regexpAst);\n\n      return endAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return end_of_input.test((pattern as RegExp).source);\n    }\n  });\n\n  const errors = map(invalidRegex, (currType) => {\n    return {\n      message:\n        \"Unexpected RegExp Anchor Error:\\n\" +\n        \"\\tToken Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n        \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType],\n    };\n  });\n\n  return errors;\n}\n\nexport function findEmptyMatchRegExps(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  const matchesEmptyString = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN as RegExp;\n    return pattern.test(\"\");\n  });\n\n  const errors = map(matchesEmptyString, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType],\n    };\n  });\n\n  return errors;\n}\n\nconst start_of_input = /[^\\\\[][\\^]|^\\^/;\n\nexport function findStartOfInputAnchor(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  class StartAnchorFinder extends BaseRegExpVisitor {\n    found = false;\n\n    visitStartAnchor(node: unknown) {\n      this.found = true;\n    }\n  }\n\n  const invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN as RegExp;\n    try {\n      const regexpAst = getRegExpAst(pattern);\n      const startAnchorVisitor = new StartAnchorFinder();\n      startAnchorVisitor.visit(regexpAst);\n\n      return startAnchorVisitor.found;\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return start_of_input.test(pattern.source);\n    }\n  });\n\n  const errors = map(invalidRegex, (currType) => {\n    return {\n      message:\n        \"Unexpected RegExp Anchor Error:\\n\" +\n        \"\\tToken Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType],\n    };\n  });\n\n  return errors;\n}\n\nexport function findUnsupportedFlags(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  const invalidFlags = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN];\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n  });\n\n  const errors = map(invalidFlags, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType],\n    };\n  });\n\n  return errors;\n}\n\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  const found: TokenType[] = [];\n  let identicalPatterns = map(tokenTypes, (outerType: any) => {\n    return reduce(\n      tokenTypes,\n      (result, innerType) => {\n        if (\n          outerType.PATTERN.source === (innerType.PATTERN as RegExp).source &&\n          !includes(found, innerType) &&\n          innerType.PATTERN !== Lexer.NA\n        ) {\n          // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n          // in essence we are creating Equivalence classes on equality relation.\n          found.push(innerType);\n          result.push(innerType);\n          return result;\n        }\n        return result;\n      },\n      [] as TokenType[],\n    );\n  });\n\n  identicalPatterns = compact(identicalPatterns);\n\n  const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n    return currIdenticalSet.length > 1;\n  });\n\n  const errors = map(duplicatePatterns, (setOfIdentical: any) => {\n    const tokenTypeNames = map(setOfIdentical, (currType: any) => {\n      return currType.name;\n    });\n\n    const dupPatternSrc = (<any>first(setOfIdentical)).PATTERN;\n    return {\n      message:\n        `The same RegExp pattern ->${dupPatternSrc}<-` +\n        `has been used in all of the following Token Types: ${tokenTypeNames.join(\n          \", \",\n        )} <-`,\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical,\n    };\n  });\n\n  return errors;\n}\n\nexport function findInvalidGroupType(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  const invalidTypes = filter(tokenTypes, (clazz: any) => {\n    if (!has(clazz, \"GROUP\")) {\n      return false;\n    }\n    const group = clazz.GROUP;\n\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\n  });\n\n  const errors = map(invalidTypes, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType],\n    };\n  });\n\n  return errors;\n}\n\nexport function findModesThatDoNotExist(\n  tokenTypes: TokenType[],\n  validModes: string[],\n): ILexerDefinitionError[] {\n  const invalidModes = filter(tokenTypes, (clazz: any) => {\n    return (\n      clazz.PUSH_MODE !== undefined && !includes(validModes, clazz.PUSH_MODE)\n    );\n  });\n\n  const errors = map(invalidModes, (tokType) => {\n    const msg =\n      `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n      `which does not exist`;\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType],\n    };\n  });\n\n  return errors;\n}\n\nexport function findUnreachablePatterns(\n  tokenTypes: TokenType[],\n): ILexerDefinitionError[] {\n  const errors: ILexerDefinitionError[] = [];\n\n  const canBeTested = reduce(\n    tokenTypes,\n    (result, tokType, idx) => {\n      const pattern = tokType.PATTERN;\n\n      if (pattern === Lexer.NA) {\n        return result;\n      }\n\n      // a more comprehensive validation for all forms of regExps would require\n      // deeper regExp analysis capabilities\n      if (isString(pattern)) {\n        result.push({ str: pattern, idx, tokenType: tokType });\n      } else if (isRegExp(pattern) && noMetaChar(pattern)) {\n        result.push({ str: pattern.source, idx, tokenType: tokType });\n      }\n      return result;\n    },\n    [] as { str: string; idx: number; tokenType: TokenType }[],\n  );\n\n  forEach(tokenTypes, (tokType, testIdx) => {\n    forEach(canBeTested, ({ str, idx, tokenType }) => {\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        const msg =\n          `Token: ->${tokenType.name}<- can never be matched.\\n` +\n          `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n          `in the lexer's definition.\\n` +\n          `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType],\n        });\n      }\n    });\n  });\n\n  return errors;\n}\n\nfunction testTokenType(str: string, pattern: any): boolean {\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    const regExpArray = pattern.exec(str);\n    return regExpArray !== null && regExpArray.index === 0;\n  } else if (isFunction(pattern)) {\n    // maintain the API of custom patterns\n    return pattern(str, 0, [], {});\n  } else if (has(pattern, \"exec\")) {\n    // maintain the API of custom patterns\n    return pattern.exec(str, 0, [], {});\n  } else if (typeof pattern === \"string\") {\n    return pattern === str;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nfunction noMetaChar(regExp: RegExp): boolean {\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n  const metaChars = [\n    \".\",\n    \"\\\\\",\n    \"[\",\n    \"]\",\n    \"|\",\n    \"^\",\n    \"$\",\n    \"(\",\n    \")\",\n    \"?\",\n    \"*\",\n    \"+\",\n    \"{\",\n  ];\n  return (\n    find(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined\n  );\n}\n\nexport function addStartOfInput(pattern: RegExp): RegExp {\n  const flags = pattern.ignoreCase ? \"i\" : \"\";\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(`^(?:${pattern.source})`, flags);\n}\n\nexport function addStickyFlag(pattern: RegExp): RegExp {\n  const flags = pattern.ignoreCase ? \"iy\" : \"y\";\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(`${pattern.source}`, flags);\n}\n\nexport function performRuntimeChecks(\n  lexerDefinition: IMultiModeLexerDefinition,\n  trackLines: boolean,\n  lineTerminatorCharacters: (number | string)[],\n): ILexerDefinitionError[] {\n  const errors: ILexerDefinitionError[] = [];\n\n  // some run time checks to help the end users.\n  if (!has(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message:\n        \"A MultiMode Lexer cannot be initialized without a <\" +\n        DEFAULT_MODE +\n        \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n    });\n  }\n  if (!has(lexerDefinition, MODES)) {\n    errors.push({\n      message:\n        \"A MultiMode Lexer cannot be initialized without a <\" +\n        MODES +\n        \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n    });\n  }\n\n  if (\n    has(lexerDefinition, MODES) &&\n    has(lexerDefinition, DEFAULT_MODE) &&\n    !has(lexerDefinition.modes, lexerDefinition.defaultMode)\n  ) {\n    errors.push({\n      message:\n        `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n        `which does not exist\\n`,\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n    });\n  }\n\n  if (has(lexerDefinition, MODES)) {\n    forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n      forEach(currModeValue, (currTokType, currIdx) => {\n        if (isUndefined(currTokType)) {\n          errors.push({\n            message:\n              `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n              `<${currModeName}> at index: <${currIdx}>\\n`,\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n          });\n        } else if (has(currTokType, \"LONGER_ALT\")) {\n          const longerAlt = isArray(currTokType.LONGER_ALT)\n            ? currTokType.LONGER_ALT\n            : [currTokType.LONGER_ALT];\n          forEach(longerAlt, (currLongerAlt) => {\n            if (\n              !isUndefined(currLongerAlt) &&\n              !includes(currModeValue, currLongerAlt)\n            ) {\n              errors.push({\n                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\n                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\n              });\n            }\n          });\n        }\n      });\n    });\n  }\n\n  return errors;\n}\n\nexport function performWarningRuntimeChecks(\n  lexerDefinition: IMultiModeLexerDefinition,\n  trackLines: boolean,\n  lineTerminatorCharacters: (number | string)[],\n): ILexerDefinitionError[] {\n  const warnings = [];\n  let hasAnyLineBreak = false;\n  const allTokenTypes = compact(flatten(values(lexerDefinition.modes)));\n\n  const concreteTokenTypes = reject(\n    allTokenTypes,\n    (currType) => currType[PATTERN] === Lexer.NA,\n  );\n  const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n  if (trackLines) {\n    forEach(concreteTokenTypes, (tokType) => {\n      const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n      if (currIssue !== false) {\n        const message = buildLineBreakIssueMessage(tokType, currIssue);\n        const warningDescriptor = {\n          message,\n          type: currIssue.issue,\n          tokenType: tokType,\n        };\n        warnings.push(warningDescriptor);\n      } else {\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n        if (has(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true;\n          }\n        } else {\n          if (\n            canMatchCharCode(terminatorCharCodes, tokType.PATTERN as RegExp)\n          ) {\n            hasAnyLineBreak = true;\n          }\n        }\n      }\n    });\n  }\n\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message:\n        \"Warning: No LINE_BREAKS Found.\\n\" +\n        \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n        \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS,\n    });\n  }\n  return warnings;\n}\n\nexport function cloneEmptyGroups(emptyGroups: {\n  [groupName: string]: IToken;\n}): { [groupName: string]: IToken } {\n  const clonedResult: any = {};\n  const groupKeys = keys(emptyGroups);\n\n  forEach(groupKeys, (currKey) => {\n    const currGroupValue = emptyGroups[currKey];\n\n    /* istanbul ignore else */\n    if (isArray(currGroupValue)) {\n      clonedResult[currKey] = [];\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  });\n\n  return clonedResult;\n}\n\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType: TokenType): boolean {\n  const pattern = tokenType.PATTERN;\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    return false;\n  } else if (isFunction(pattern)) {\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n    return true;\n  } else if (has(pattern, \"exec\")) {\n    // ICustomPattern\n    return true;\n  } else if (isString(pattern)) {\n    return false;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexport function isShortPattern(pattern: any): number | false {\n  if (isString(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0);\n  } else {\n    return false;\n  }\n}\n\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport const LineTerminatorOptimizedTester: ILineTerminatorsTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function (text) {\n    const len = text.length;\n    for (let i = this.lastIndex; i < len; i++) {\n      const c = text.charCodeAt(i);\n      if (c === 10) {\n        this.lastIndex = i + 1;\n        return true;\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2;\n        } else {\n          this.lastIndex = i + 1;\n        }\n        return true;\n      }\n    }\n    return false;\n  },\n\n  lastIndex: 0,\n};\n\nfunction checkLineBreaksIssues(\n  tokType: TokenType,\n  lineTerminatorCharCodes: number[],\n):\n  | {\n      issue:\n        | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\n        | LexerDefinitionErrorType.CUSTOM_LINE_BREAK;\n      errMsg?: string;\n    }\n  | false {\n  if (has(tokType, \"LINE_BREAKS\")) {\n    // if the user explicitly declared the line_breaks option we will respect their choice\n    // and assume it is correct.\n    return false;\n  } else {\n    /* istanbul ignore else */\n    if (isRegExp(tokType.PATTERN)) {\n      try {\n        // TODO: why is the casting suddenly needed?\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN as RegExp);\n      } catch (e) {\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: (e as Error).message,\n        };\n      }\n      return false;\n    } else if (isString(tokType.PATTERN)) {\n      // string literal patterns can always be analyzed to detect line terminator usage\n      return false;\n    } else if (isCustomPattern(tokType)) {\n      // custom token types\n      return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n}\n\nexport function buildLineBreakIssueMessage(\n  tokType: TokenType,\n  details: {\n    issue:\n      | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\n      | LexerDefinitionErrorType.CUSTOM_LINE_BREAK;\n    errMsg?: string;\n  },\n): string {\n  /* istanbul ignore else */\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return (\n      \"Warning: unable to identify line terminator usage in pattern.\\n\" +\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n      `\\t Root cause: ${details.errMsg}.\\n` +\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\"\n    );\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return (\n      \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\"\n    );\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nfunction getCharCodes(charsOrCodes: (number | string)[]): number[] {\n  const charCodes = map(charsOrCodes, (numOrString) => {\n    if (isString(numOrString)) {\n      return numOrString.charCodeAt(0);\n    } else {\n      return numOrString;\n    }\n  });\n\n  return charCodes;\n}\n\nfunction addToMapOfArrays<T>(\n  map: Record<number, T[]>,\n  key: number,\n  value: T,\n): void {\n  if (map[key] === undefined) {\n    map[key] = [value];\n  } else {\n    map[key].push(value);\n  }\n}\n\nexport const minOptimizationVal = 256;\n\n/**\n * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nlet charCodeToOptimizedIdxMap: number[] = [];\nexport function charCodeToOptimizedIndex(charCode: number): number {\n  return charCode < minOptimizationVal\n    ? charCode\n    : charCodeToOptimizedIdxMap[charCode];\n}\n\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536);\n    for (let i = 0; i < 65536; i++) {\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1379, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1385, "column": 0}, "map": {"version":3,"file":"tokens.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/scan/tokens.ts"],"sourcesContent":["import {\n  clone,\n  compact,\n  difference,\n  flatten,\n  forEach,\n  has,\n  includes,\n  isArray,\n  isEmpty,\n  map,\n} from \"lodash-es\";\nimport { IToken, TokenType } from \"@chevrotain/types\";\n\nexport function tokenStructuredMatcher(\n  tokInstance: IToken,\n  tokConstructor: TokenType,\n) {\n  const instanceType = tokInstance.tokenTypeIdx;\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return (\n      tokConstructor.isParent === true &&\n      tokConstructor.categoryMatchesMap![instanceType] === true\n    );\n  }\n}\n\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(\n  token: IToken,\n  tokType: TokenType,\n) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\n\nexport let tokenShortNameIdx = 1;\nexport const tokenIdxToClass: { [tokenIdx: number]: TokenType } = {};\n\nexport function augmentTokenTypes(tokenTypes: TokenType[]): void {\n  // collect the parent Token Types as well.\n  const tokenTypesAndParents = expandCategories(tokenTypes);\n\n  // add required tokenType and categoryMatches properties\n  assignTokenDefaultProps(tokenTypesAndParents);\n\n  // fill up the categoryMatches\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n\n  forEach(tokenTypesAndParents, (tokType) => {\n    tokType.isParent = tokType.categoryMatches!.length > 0;\n  });\n}\n\nexport function expandCategories(tokenTypes: TokenType[]): TokenType[] {\n  let result = clone(tokenTypes);\n\n  let categories = tokenTypes;\n  let searching = true;\n  while (searching) {\n    categories = compact(\n      flatten(map(categories, (currTokType) => currTokType.CATEGORIES)),\n    );\n\n    const newCategories = difference(categories, result);\n\n    result = result.concat(newCategories);\n\n    if (isEmpty(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n  return result;\n}\n\nexport function assignTokenDefaultProps(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType;\n      (<any>currTokType).tokenTypeIdx = tokenShortNameIdx++;\n    }\n\n    // CATEGORIES? : TokenType | TokenType[]\n    if (\n      hasCategoriesProperty(currTokType) &&\n      !isArray(currTokType.CATEGORIES)\n      // &&\n      // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES as unknown as TokenType];\n    }\n\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\n\nexport function assignCategoriesTokensProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    // avoid duplications\n    currTokType.categoryMatches = [];\n    forEach(currTokType.categoryMatchesMap!, (val, key) => {\n      currTokType.categoryMatches!.push(\n        tokenIdxToClass[key as unknown as number].tokenTypeIdx!,\n      );\n    });\n  });\n}\n\nexport function assignCategoriesMapProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\n\nexport function singleAssignCategoriesToksMap(\n  path: TokenType[],\n  nextNode: TokenType,\n): void {\n  forEach(path, (pathNode) => {\n    nextNode.categoryMatchesMap![pathNode.tokenTypeIdx!] = true;\n  });\n\n  forEach(nextNode.CATEGORIES, (nextCategory) => {\n    const newPath = path.concat(nextNode);\n    // avoids infinite loops due to cyclic categories.\n    if (!includes(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\n\nexport function hasShortKeyProperty(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\");\n}\n\nexport function hasCategoriesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"CATEGORIES\");\n}\n\nexport function hasExtendingTokensTypesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"categoryMatches\");\n}\n\nexport function hasExtendingTokensTypesMapProperty(\n  tokType: TokenType,\n): boolean {\n  return has(tokType, \"categoryMatchesMap\");\n}\n\nexport function isTokenType(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\");\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1518, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1524, "column": 0}, "map": {"version":3,"file":"lexer_errors_public.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/scan/lexer_errors_public.ts"],"sourcesContent":["import { ILexerErrorMessageProvider, IToken } from \"@chevrotain/types\";\n\nexport const defaultLexerErrorProvider: ILexerErrorMessageProvider = {\n  buildUnableToPopLexerModeMessage(token: IToken): string {\n    return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;\n  },\n\n  buildUnexpectedCharactersMessage(\n    fullText: string,\n    startOffset: number,\n    length: number,\n    line?: number,\n    column?: number,\n  ): string {\n    return (\n      `unexpected character: ->${fullText.charAt(\n        startOffset,\n      )}<- at offset: ${startOffset},` + ` skipped ${length} characters.`\n    );\n  },\n};\n"],"names":[],"mappings":";;;AAEO,MAAM,yBAAyB,GAA+B;IACnE,gCAAgC,EAAC,KAAa;QAC5C,OAAO,CAAA,oDAAA,EAAuD,KAAK,CAAC,KAAK,CAAA,0BAAA,CAA4B,CAAC;IACxG,CAAC;IAED,gCAAgC,EAC9B,QAAgB,EAChB,WAAmB,EACnB,MAAc,EACd,IAAa,EACb,MAAe;QAEf,OAAO,AACL,CAAA,wBAAA,EAA2B,QAAQ,CAAC,MAAM,CACxC,WAAW,CACZ,CAAA,cAAA,EAAiB,WAAW,CAAA,CAAA,CAAG,GAAG,CAAA,SAAA,EAAY,MAAM,CAAA,YAAA,CAAc,CACpE,CAAC;IACJ,CAAC;CACF,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1535, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1541, "column": 0}, "map": {"version":3,"file":"lexer_public.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/scan/lexer_public.ts"],"sourcesContent":["import {\n  analyzeTokenTypes,\n  charCodeToOptimizedIndex,\n  cloneEmptyGroups,\n  DEFAULT_MODE,\n  IAnalyzeResult,\n  IPatternConfig,\n  LineTerminatorOptimizedTester,\n  performRuntimeChecks,\n  performWarningRuntimeChecks,\n  SUPPORT_STICKY,\n  validatePatterns,\n} from \"./lexer.js\";\nimport {\n  assign,\n  clone,\n  forEach,\n  identity,\n  isArray,\n  isEmpty,\n  isUndefined,\n  keys,\n  last,\n  map,\n  noop,\n  reduce,\n  reject,\n} from \"lodash-es\";\nimport { PRINT_WARNING, timer, toFastProperties } from \"@chevrotain/utils\";\nimport { augmentTokenTypes } from \"./tokens.js\";\nimport {\n  CustomPatternMatcherFunc,\n  CustomPatternMatcherReturn,\n  ILexerConfig,\n  ILexerDefinitionError,\n  ILexingError,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType,\n} from \"@chevrotain/types\";\nimport { defaultLexerErrorProvider } from \"./lexer_errors_public.js\";\nimport { clearRegExpParserCache } from \"./reg_exp_parser.js\";\n\nexport interface ILexingResult {\n  tokens: IToken[];\n  groups: { [groupName: string]: IToken[] };\n  errors: ILexingError[];\n}\n\nexport enum LexerDefinitionErrorType {\n  MISSING_PATTERN,\n  INVALID_PATTERN,\n  EOI_ANCHOR_FOUND,\n  UNSUPPORTED_FLAGS_FOUND,\n  DUPLICATE_PATTERNS_FOUND,\n  INVALID_GROUP_TYPE_FOUND,\n  PUSH_MODE_DOES_NOT_EXIST,\n  MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n  MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n  MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n  LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n  SOI_ANCHOR_FOUND,\n  EMPTY_MATCH_PATTERN,\n  NO_LINE_BREAKS_FLAGS,\n  UNREACHABLE_PATTERN,\n  IDENTIFY_TERMINATOR,\n  CUSTOM_LINE_BREAK,\n  MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\n}\n\nexport interface IRegExpExec {\n  exec: CustomPatternMatcherFunc;\n}\n\nconst DEFAULT_LEXER_CONFIG: Required<ILexerConfig> = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false,\n  recoveryEnabled: true,\n};\n\nObject.freeze(DEFAULT_LEXER_CONFIG);\n\nexport class Lexer {\n  public static SKIPPED =\n    \"This marks a skipped Token pattern, this means each token identified by it will\" +\n    \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n\n  public static NA = /NOT_APPLICABLE/;\n  public lexerDefinitionErrors: ILexerDefinitionError[] = [];\n  public lexerDefinitionWarning: ILexerDefinitionError[] = [];\n\n  protected patternIdxToConfig: Record<string, IPatternConfig[]> = {};\n  protected charCodeToPatternIdxToConfig: {\n    [modeName: string]: { [charCode: number]: IPatternConfig[] };\n  } = {};\n\n  protected modes: string[] = [];\n  protected defaultMode!: string;\n  protected emptyGroups: { [groupName: string]: IToken } = {};\n\n  private config: Required<ILexerConfig>;\n  private trackStartLines: boolean = true;\n  private trackEndLines: boolean = true;\n  private hasCustom: boolean = false;\n  private canModeBeOptimized: Record<string, boolean> = {};\n\n  private traceInitPerf!: boolean | number;\n  private traceInitMaxIdent!: number;\n  private traceInitIndent: number;\n\n  constructor(\n    protected lexerDefinition: TokenType[] | IMultiModeLexerDefinition,\n    config: ILexerConfig = DEFAULT_LEXER_CONFIG,\n  ) {\n    if (typeof config === \"boolean\") {\n      throw Error(\n        \"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n          \"a boolean 2nd argument is no longer supported\",\n      );\n    }\n\n    // todo: defaults func?\n    this.config = assign({}, DEFAULT_LEXER_CONFIG, config) as any;\n\n    const traceInitVal = this.config.traceInitPerf;\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity;\n      this.traceInitPerf = true;\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal;\n      this.traceInitPerf = true;\n    }\n    this.traceInitIndent = -1;\n\n    this.TRACE_INIT(\"Lexer Constructor\", () => {\n      let actualDefinition!: IMultiModeLexerDefinition;\n      let hasOnlySingleMode = true;\n      this.TRACE_INIT(\"Lexer Config handling\", () => {\n        if (\n          this.config.lineTerminatorsPattern ===\n          DEFAULT_LEXER_CONFIG.lineTerminatorsPattern\n        ) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n        } else {\n          if (\n            this.config.lineTerminatorCharacters ===\n            DEFAULT_LEXER_CONFIG.lineTerminatorCharacters\n          ) {\n            throw Error(\n              \"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\",\n            );\n          }\n        }\n\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error(\n            '\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.',\n          );\n        }\n\n        this.trackStartLines = /full|onlyStart/i.test(\n          this.config.positionTracking,\n        );\n        this.trackEndLines = /full/i.test(this.config.positionTracking);\n\n        // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n        if (isArray(lexerDefinition)) {\n          actualDefinition = {\n            modes: { defaultMode: clone(lexerDefinition) },\n            defaultMode: DEFAULT_MODE,\n          };\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false;\n          actualDefinition = clone(<IMultiModeLexerDefinition>lexerDefinition);\n        }\n      });\n\n      if (this.config.skipValidations === false) {\n        this.TRACE_INIT(\"performRuntimeChecks\", () => {\n          this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n            performRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters,\n            ),\n          );\n        });\n\n        this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n          this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(\n            performWarningRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters,\n            ),\n          );\n        });\n      }\n\n      // for extra robustness to avoid throwing an none informative error message\n      actualDefinition.modes = actualDefinition.modes\n        ? actualDefinition.modes\n        : {};\n\n      // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n      forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n        actualDefinition.modes[currModeName] = reject<TokenType>(\n          currModeValue,\n          (currTokType) => isUndefined(currTokType),\n        );\n      });\n\n      const allModeNames = keys(actualDefinition.modes);\n\n      forEach(\n        actualDefinition.modes,\n        (currModDef: TokenType[], currModName) => {\n          this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n            this.modes.push(currModName);\n\n            if (this.config.skipValidations === false) {\n              this.TRACE_INIT(`validatePatterns`, () => {\n                this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n                  validatePatterns(currModDef, allModeNames),\n                );\n              });\n            }\n\n            // If definition errors were encountered, the analysis phase may fail unexpectedly/\n            // Considering a lexer with definition errors may never be used, there is no point\n            // to performing the analysis anyhow...\n            if (isEmpty(this.lexerDefinitionErrors)) {\n              augmentTokenTypes(currModDef);\n\n              let currAnalyzeResult!: IAnalyzeResult;\n              this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                  lineTerminatorCharacters:\n                    this.config.lineTerminatorCharacters,\n                  positionTracking: config.positionTracking,\n                  ensureOptimizations: config.ensureOptimizations,\n                  safeMode: config.safeMode,\n                  tracer: this.TRACE_INIT,\n                });\n              });\n\n              this.patternIdxToConfig[currModName] =\n                currAnalyzeResult.patternIdxToConfig;\n\n              this.charCodeToPatternIdxToConfig[currModName] =\n                currAnalyzeResult.charCodeToPatternIdxToConfig;\n\n              this.emptyGroups = assign(\n                {},\n                this.emptyGroups,\n                currAnalyzeResult.emptyGroups,\n              ) as any;\n\n              this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;\n\n              this.canModeBeOptimized[currModName] =\n                currAnalyzeResult.canBeOptimized;\n            }\n          });\n        },\n      );\n\n      this.defaultMode = actualDefinition.defaultMode;\n\n      if (\n        !isEmpty(this.lexerDefinitionErrors) &&\n        !this.config.deferDefinitionErrorsHandling\n      ) {\n        const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n          return error.message;\n        });\n        const allErrMessagesString = allErrMessages.join(\n          \"-----------------------\\n\",\n        );\n        throw new Error(\n          \"Errors detected in definition of Lexer:\\n\" + allErrMessagesString,\n        );\n      }\n\n      // Only print warning if there are no errors, This will avoid pl\n      forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n        PRINT_WARNING(warningDescriptor.message);\n      });\n\n      this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (SUPPORT_STICKY) {\n          this.chopInput = <any>identity;\n          this.match = this.matchWithTest;\n        } else {\n          this.updateLastIndex = noop;\n          this.match = this.matchWithExec;\n        }\n\n        if (hasOnlySingleMode) {\n          this.handleModes = noop;\n        }\n\n        if (this.trackStartLines === false) {\n          this.computeNewColumn = identity;\n        }\n\n        if (this.trackEndLines === false) {\n          this.updateTokenEndLineColumnLocation = noop;\n        }\n\n        if (/full/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createFullToken;\n        } else if (/onlyStart/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createStartOnlyToken;\n        } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createOffsetOnlyToken;\n        } else {\n          throw Error(\n            `Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`,\n          );\n        }\n\n        if (this.hasCustom) {\n          this.addToken = this.addTokenUsingPush;\n          this.handlePayload = this.handlePayloadWithCustom;\n        } else {\n          this.addToken = this.addTokenUsingMemberAccess;\n          this.handlePayload = this.handlePayloadNoCustom;\n        }\n      });\n\n      this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n        const unOptimizedModes = reduce(\n          this.canModeBeOptimized,\n          (cannotBeOptimized, canBeOptimized, modeName) => {\n            if (canBeOptimized === false) {\n              cannotBeOptimized.push(modeName);\n            }\n            return cannotBeOptimized;\n          },\n          [] as string[],\n        );\n\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n          throw Error(\n            `Lexer Modes: < ${unOptimizedModes.join(\n              \", \",\n            )} > cannot be optimized.\\n` +\n              '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n              \"\\t Or inspect the console log for details on how to resolve these issues.\",\n          );\n        }\n      });\n\n      this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n        clearRegExpParserCache();\n      });\n\n      this.TRACE_INIT(\"toFastProperties\", () => {\n        toFastProperties(this);\n      });\n    });\n  }\n\n  public tokenize(\n    text: string,\n    initialMode: string = this.defaultMode,\n  ): ILexingResult {\n    if (!isEmpty(this.lexerDefinitionErrors)) {\n      const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n        return error.message;\n      });\n      const allErrMessagesString = allErrMessages.join(\n        \"-----------------------\\n\",\n      );\n      throw new Error(\n        \"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n          allErrMessagesString,\n      );\n    }\n\n    return this.tokenizeInternal(text, initialMode);\n  }\n\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  // this method also used quite a bit of `!` none null assertions because it is too optimized\n  // for `tsc` to always understand it is \"safe\"\n  private tokenizeInternal(text: string, initialMode: string): ILexingResult {\n    let i,\n      j,\n      k,\n      matchAltImage,\n      longerAlt,\n      matchedImage: string | null,\n      payload,\n      altPayload,\n      imageLength,\n      group,\n      tokType,\n      newToken: IToken,\n      errLength,\n      droppedChar,\n      msg,\n      match;\n    const orgText = text;\n    const orgLength = orgText.length;\n    let offset = 0;\n    let matchedTokensIndex = 0;\n    // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n    const guessedNumberOfTokens = this.hasCustom\n      ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n      : Math.floor(text.length / 10);\n    const matchedTokens = new Array(guessedNumberOfTokens);\n    const errors: ILexingError[] = [];\n    let line = this.trackStartLines ? 1 : undefined;\n    let column = this.trackStartLines ? 1 : undefined;\n    const groups: any = cloneEmptyGroups(this.emptyGroups);\n    const trackLines = this.trackStartLines;\n    const lineTerminatorPattern = this.config.lineTerminatorsPattern;\n\n    let currModePatternsLength = 0;\n    let patternIdxToConfig: IPatternConfig[] = [];\n    let currCharCodeToPatternIdxToConfig: {\n      [charCode: number]: IPatternConfig[];\n    } = [];\n\n    const modeStack: string[] = [];\n\n    const emptyArray: IPatternConfig[] = [];\n    Object.freeze(emptyArray);\n    let getPossiblePatterns!: (charCode: number) => IPatternConfig[];\n\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig;\n    }\n\n    function getPossiblePatternsOptimized(charCode: number): IPatternConfig[] {\n      const optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n      const possiblePatterns =\n        currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n      if (possiblePatterns === undefined) {\n        return emptyArray;\n      } else {\n        return possiblePatterns;\n      }\n    }\n\n    const pop_mode = (popToken: IToken) => {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (\n        modeStack.length === 1 &&\n        // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n        // So no error should occur.\n        popToken.tokenType.PUSH_MODE === undefined\n      ) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        const msg =\n          this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(\n            popToken,\n          );\n\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine,\n          column: popToken.startColumn,\n          length: popToken.image.length,\n          message: msg,\n        });\n      } else {\n        modeStack.pop();\n        const newMode = last(modeStack)!;\n        patternIdxToConfig = this.patternIdxToConfig[newMode];\n        currCharCodeToPatternIdxToConfig =\n          this.charCodeToPatternIdxToConfig[newMode];\n        currModePatternsLength = patternIdxToConfig.length;\n        const modeCanBeOptimized =\n          this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized;\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow;\n        }\n      }\n    };\n\n    function push_mode(this: Lexer, newMode: string) {\n      modeStack.push(newMode);\n      currCharCodeToPatternIdxToConfig =\n        this.charCodeToPatternIdxToConfig[newMode];\n\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\n      currModePatternsLength = patternIdxToConfig.length;\n\n      currModePatternsLength = patternIdxToConfig.length;\n      const modeCanBeOptimized =\n        this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized;\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow;\n      }\n    }\n\n    // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n    push_mode.call(this, initialMode);\n\n    let currConfig!: IPatternConfig;\n\n    const recoveryEnabled = this.config.recoveryEnabled;\n\n    while (offset < orgLength) {\n      matchedImage = null;\n\n      const nextCharCode = orgText.charCodeAt(offset);\n      const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n      const chosenPatternsLength = chosenPatternIdxToConfig.length;\n\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i];\n        const currPattern = currConfig.pattern;\n        payload = null;\n\n        // manually in-lined because > 600 chars won't be in-lined in V8\n        const singleCharCode = currConfig.short;\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern as string;\n          }\n        } else if (currConfig.isCustom === true) {\n          match = (currPattern as IRegExpExec).exec(\n            orgText,\n            offset,\n            matchedTokens,\n            groups,\n          );\n          if (match !== null) {\n            matchedImage = match[0];\n            if ((match as CustomPatternMatcherReturn).payload !== undefined) {\n              payload = (match as CustomPatternMatcherReturn).payload;\n            }\n          } else {\n            matchedImage = null;\n          }\n        } else {\n          this.updateLastIndex(currPattern as RegExp, offset);\n          matchedImage = this.match(currPattern as RegExp, text, offset);\n        }\n\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAlt = currConfig.longerAlt;\n          if (longerAlt !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            const longerAltLength = longerAlt.length;\n            for (k = 0; k < longerAltLength; k++) {\n              const longerAltConfig = patternIdxToConfig[longerAlt[k]];\n              const longerAltPattern = longerAltConfig.pattern;\n              altPayload = null;\n\n              // single Char can never be a longer alt so no need to test it.\n              // manually in-lined because > 600 chars won't be in-lined in V8\n              if (longerAltConfig.isCustom === true) {\n                match = (longerAltPattern as IRegExpExec).exec(\n                  orgText,\n                  offset,\n                  matchedTokens,\n                  groups,\n                );\n                if (match !== null) {\n                  matchAltImage = match[0];\n                  if (\n                    (match as CustomPatternMatcherReturn).payload !== undefined\n                  ) {\n                    altPayload = (match as CustomPatternMatcherReturn).payload;\n                  }\n                } else {\n                  matchAltImage = null;\n                }\n              } else {\n                this.updateLastIndex(longerAltPattern as RegExp, offset);\n                matchAltImage = this.match(\n                  longerAltPattern as RegExp,\n                  text,\n                  offset,\n                );\n              }\n\n              if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                matchedImage = matchAltImage;\n                payload = altPayload;\n                currConfig = longerAltConfig;\n                // Exit the loop early after matching one of the longer alternatives\n                // The first matched alternative takes precedence\n                break;\n              }\n            }\n          }\n          break;\n        }\n      }\n\n      // successful match\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length;\n        group = currConfig.group;\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx;\n          // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n          newToken = this.createTokenInstance(\n            matchedImage,\n            offset,\n            tokType,\n            currConfig.tokenType,\n            line,\n            column,\n            imageLength,\n          );\n\n          this.handlePayload(newToken, payload);\n\n          // TODO: optimize NOOP in case there are no special groups?\n          if (group === false) {\n            matchedTokensIndex = this.addToken(\n              matchedTokens,\n              matchedTokensIndex,\n              newToken,\n            );\n          } else {\n            groups[group].push(newToken);\n          }\n        }\n        text = this.chopInput(text, imageLength);\n        offset = offset + imageLength;\n\n        // TODO: with newlines the column may be assigned twice\n        column = this.computeNewColumn(column!, imageLength);\n\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          let numOfLTsInMatch = 0;\n          let foundTerminator;\n          let lastLTEndOffset: number;\n          lineTerminatorPattern.lastIndex = 0;\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n              numOfLTsInMatch++;\n            }\n          } while (foundTerminator === true);\n\n          if (numOfLTsInMatch !== 0) {\n            line = line! + numOfLTsInMatch;\n            column = imageLength - lastLTEndOffset!;\n            this.updateTokenEndLineColumnLocation(\n              newToken!,\n              group!,\n              lastLTEndOffset!,\n              numOfLTsInMatch,\n              line,\n              column,\n              imageLength,\n            );\n          }\n        }\n        // will be NOOP if no modes present\n        this.handleModes(currConfig, pop_mode, push_mode, newToken!);\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        const errorStartOffset = offset;\n        const errorLine = line;\n        const errorColumn = column;\n        let foundResyncPoint = recoveryEnabled === false;\n\n        while (foundResyncPoint === false && offset < orgLength) {\n          // Identity Func (when sticky flag is enabled)\n          text = this.chopInput(text, 1);\n          offset++;\n          for (j = 0; j < currModePatternsLength; j++) {\n            const currConfig = patternIdxToConfig[j];\n            const currPattern = currConfig.pattern;\n\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            const singleCharCode = currConfig.short;\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true;\n              }\n            } else if (currConfig.isCustom === true) {\n              foundResyncPoint =\n                (currPattern as IRegExpExec).exec(\n                  orgText,\n                  offset,\n                  matchedTokens,\n                  groups,\n                ) !== null;\n            } else {\n              this.updateLastIndex(currPattern as RegExp, offset);\n              foundResyncPoint = (currPattern as RegExp).exec(text) !== null;\n            }\n\n            if (foundResyncPoint === true) {\n              break;\n            }\n          }\n        }\n\n        errLength = offset - errorStartOffset;\n        column = this.computeNewColumn(column!, errLength);\n        // at this point we either re-synced or reached the end of the input text\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(\n          orgText,\n          errorStartOffset,\n          errLength,\n          errorLine,\n          errorColumn,\n        );\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg,\n        });\n\n        if (recoveryEnabled === false) {\n          break;\n        }\n      }\n    }\n\n    // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex;\n    }\n\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors,\n    };\n  }\n\n  private handleModes(\n    config: IPatternConfig,\n    pop_mode: (tok: IToken) => void,\n    push_mode: (this: Lexer, pushMode: string) => void,\n    newToken: IToken,\n  ) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      const pushMode = config.push;\n      pop_mode(newToken);\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode);\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push);\n    }\n  }\n\n  private chopInput(text: string, length: number): string {\n    return text.substring(length);\n  }\n\n  private updateLastIndex(regExp: RegExp, newLastIndex: number): void {\n    regExp.lastIndex = newLastIndex;\n  }\n\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  private updateTokenEndLineColumnLocation(\n    newToken: IToken,\n    group: string | false,\n    lastLTIdx: number,\n    numOfLTsInMatch: number,\n    line: number,\n    column: number,\n    imageLength: number,\n  ): void {\n    let lastCharIsLT, fixForEndingInLT;\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1;\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT;\n        // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\n      }\n      // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n    }\n  }\n\n  private computeNewColumn(oldColumn: number, imageLength: number) {\n    return oldColumn + imageLength;\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private createTokenInstance!: (...args: any[]) => IToken;\n\n  private createOffsetOnlyToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType,\n  ) {\n    return {\n      image,\n      startOffset,\n      tokenTypeIdx,\n      tokenType,\n    };\n  }\n\n  private createStartOnlyToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType,\n    startLine: number,\n    startColumn: number,\n  ) {\n    return {\n      image,\n      startOffset,\n      startLine,\n      startColumn,\n      tokenTypeIdx,\n      tokenType,\n    };\n  }\n\n  private createFullToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType,\n    startLine: number,\n    startColumn: number,\n    imageLength: number,\n  ): IToken {\n    return {\n      image,\n      startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine,\n      endLine: startLine,\n      startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx,\n      tokenType,\n    };\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private addToken!: (\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken,\n  ) => number;\n\n  private addTokenUsingPush(\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken,\n  ): number {\n    tokenVector.push(tokenToAdd);\n    return index;\n  }\n\n  private addTokenUsingMemberAccess(\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken,\n  ): number {\n    tokenVector[index] = tokenToAdd;\n    index++;\n    return index;\n  }\n\n  // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n  private handlePayload: (token: IToken, payload: any) => void;\n\n  private handlePayloadNoCustom(token: IToken, payload: any): void {}\n\n  private handlePayloadWithCustom(token: IToken, payload: any): void {\n    if (payload !== null) {\n      token.payload = payload;\n    }\n  }\n\n  // place holder to be replaced with chosen alternative at runtime\n  private match!: (\n    pattern: RegExp,\n    text: string,\n    offset: number,\n  ) => string | null;\n\n  private matchWithTest(\n    pattern: RegExp,\n    text: string,\n    offset: number,\n  ): string | null {\n    const found = pattern.test(text);\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex);\n    }\n    return null;\n  }\n\n  private matchWithExec(pattern: RegExp, text: string): string | null {\n    const regExpArray = pattern.exec(text);\n    return regExpArray !== null ? regExpArray[0] : null;\n  }\n\n  // Duplicated from the parser's perf trace trait to allow future extraction\n  // of the lexer to a separate package.\n  TRACE_INIT = <T>(phaseDesc: string, phaseImpl: () => T): T => {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++;\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`);\n      }\n      const { time, value } = timer(phaseImpl);\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      const traceMethod = time > 10 ? console.warn : console.log;\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n      }\n      this.traceInitIndent--;\n      return value;\n    } else {\n      return phaseImpl();\n    }\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2171, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2177, "column": 0}, "map": {"version":3,"file":"tokens_public.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/scan/tokens_public.ts"],"sourcesContent":["import { has, isString, isUndefined } from \"lodash-es\";\nimport { Lexer } from \"./lexer_public.js\";\nimport { augmentTokenTypes, tokenStructuredMatcher } from \"./tokens.js\";\nimport { IToken, ITokenConfig, TokenType } from \"@chevrotain/types\";\n\nexport function tokenLabel(tokType: TokenType): string {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n}\n\nexport function tokenName(tokType: TokenType): string {\n  return tokType.name;\n}\n\nexport function hasTokenLabel(\n  obj: TokenType,\n): obj is TokenType & Pick<Required<TokenType>, \"LABEL\"> {\n  return isString(obj.LABEL) && obj.LABEL !== \"\";\n}\n\nconst PARENT = \"parent\";\nconst CATEGORIES = \"categories\";\nconst LABEL = \"label\";\nconst GROUP = \"group\";\nconst PUSH_MODE = \"push_mode\";\nconst POP_MODE = \"pop_mode\";\nconst LONGER_ALT = \"longer_alt\";\nconst LINE_BREAKS = \"line_breaks\";\nconst START_CHARS_HINT = \"start_chars_hint\";\n\nexport function createToken(config: ITokenConfig): TokenType {\n  return createTokenInternal(config);\n}\n\nfunction createTokenInternal(config: ITokenConfig): TokenType {\n  const pattern = config.pattern;\n\n  const tokenType: TokenType = <any>{};\n  tokenType.name = config.name;\n\n  if (!isUndefined(pattern)) {\n    tokenType.PATTERN = pattern;\n  }\n\n  if (has(config, PARENT)) {\n    throw (\n      \"The parent property is no longer supported.\\n\" +\n      \"See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\"\n    );\n  }\n\n  if (has(config, CATEGORIES)) {\n    // casting to ANY as this will be fixed inside `augmentTokenTypes``\n    tokenType.CATEGORIES = <any>config[CATEGORIES];\n  }\n\n  augmentTokenTypes([tokenType]);\n\n  if (has(config, LABEL)) {\n    tokenType.LABEL = config[LABEL];\n  }\n\n  if (has(config, GROUP)) {\n    tokenType.GROUP = config[GROUP];\n  }\n\n  if (has(config, POP_MODE)) {\n    tokenType.POP_MODE = config[POP_MODE];\n  }\n\n  if (has(config, PUSH_MODE)) {\n    tokenType.PUSH_MODE = config[PUSH_MODE];\n  }\n\n  if (has(config, LONGER_ALT)) {\n    tokenType.LONGER_ALT = config[LONGER_ALT];\n  }\n\n  if (has(config, LINE_BREAKS)) {\n    tokenType.LINE_BREAKS = config[LINE_BREAKS];\n  }\n\n  if (has(config, START_CHARS_HINT)) {\n    tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n  }\n\n  return tokenType;\n}\n\nexport const EOF = createToken({ name: \"EOF\", pattern: Lexer.NA });\naugmentTokenTypes([EOF]);\n\nexport function createTokenInstance(\n  tokType: TokenType,\n  image: string,\n  startOffset: number,\n  endOffset: number,\n  startLine: number,\n  endLine: number,\n  startColumn: number,\n  endColumn: number,\n): IToken {\n  return {\n    image,\n    startOffset,\n    endOffset,\n    startLine,\n    endLine,\n    startColumn,\n    endColumn,\n    tokenTypeIdx: (<any>tokType).tokenTypeIdx,\n    tokenType: tokType,\n  };\n}\n\nexport function tokenMatcher(token: IToken, tokType: TokenType): boolean {\n  return tokenStructuredMatcher(token, tokType);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2282, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2288, "column": 0}, "map": {"version":3,"file":"errors_public.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/errors_public.ts"],"sourcesContent":["import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public.js\";\nimport { first, map, reduce } from \"lodash-es\";\nimport {\n  Alternation,\n  getProductionDslName,\n  NonTerminal,\n  Rule,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport {\n  IParserErrorMessageProvider,\n  IProductionWithOccurrence,\n  TokenType,\n} from \"@chevrotain/types\";\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider,\n} from \"./grammar/types.js\";\n\nexport const defaultParserErrorProvider: IParserErrorMessageProvider = {\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }): string {\n    const hasLabel = hasTokenLabel(expected);\n    const expectedMsg = hasLabel\n      ? `--> ${tokenLabel(expected)} <--`\n      : `token of type --> ${expected.name} <--`;\n\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\n\n    return msg;\n  },\n\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }): string {\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n\n  buildNoViableAltMessage({\n    expectedPathsPerAlt,\n    actual,\n    previous,\n    customUserDescription,\n    ruleName,\n  }): string {\n    const errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual)!.image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const allLookAheadPaths = reduce(\n        expectedPathsPerAlt,\n        (result, currAltPaths) => result.concat(currAltPaths),\n        [] as TokenType[][],\n      );\n      const nextValidTokenSequences = map(\n        allLookAheadPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \", \",\n          )}]`,\n      );\n      const nextValidSequenceItems = map(\n        nextValidTokenSequences,\n        (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`,\n      );\n      const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\n        \"\\n\",\n      )}`;\n\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n\n  buildEarlyExitMessage({\n    expectedIterationPaths,\n    actual,\n    customUserDescription,\n    ruleName,\n  }): string {\n    const errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual)!.image;\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      const nextValidTokenSequences = map(\n        expectedIterationPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \",\",\n          )}]`,\n      );\n      const calculatedDescription =\n        `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n        `<${nextValidTokenSequences.join(\" ,\")}>`;\n\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n};\n\nObject.freeze(defaultParserErrorProvider);\n\nexport const defaultGrammarResolverErrorProvider: IGrammarResolverErrorMessageProvider =\n  {\n    buildRuleNotFoundError(\n      topLevelRule: Rule,\n      undefinedRule: NonTerminal,\n    ): string {\n      const msg =\n        \"Invalid grammar, reference to a rule which is not defined: ->\" +\n        undefinedRule.nonTerminalName +\n        \"<-\\n\" +\n        \"inside top level rule: ->\" +\n        topLevelRule.name +\n        \"<-\";\n      return msg;\n    },\n  };\n\nexport const defaultGrammarValidatorErrorProvider: IGrammarValidatorErrorMessageProvider =\n  {\n    buildDuplicateFoundError(\n      topLevelRule: Rule,\n      duplicateProds: IProductionWithOccurrence[],\n    ): string {\n      function getExtraProductionArgument(\n        prod: IProductionWithOccurrence,\n      ): string {\n        if (prod instanceof Terminal) {\n          return prod.terminalType.name;\n        } else if (prod instanceof NonTerminal) {\n          return prod.nonTerminalName;\n        } else {\n          return \"\";\n        }\n      }\n\n      const topLevelName = topLevelRule.name;\n      const duplicateProd = first(duplicateProds)!;\n      const index = duplicateProd.idx;\n      const dslName = getProductionDslName(duplicateProd);\n      const extraArgument = getExtraProductionArgument(duplicateProd);\n\n      const hasExplicitIndex = index > 0;\n      let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${\n        extraArgument ? `with argument: ->${extraArgument}<-` : \"\"\n      }\n                  appears more than once (${\n                    duplicateProds.length\n                  } times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n\n      // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n      msg = msg.replace(/[ \\t]+/g, \" \");\n      msg = msg.replace(/\\s\\s+/g, \"\\n\");\n\n      return msg;\n    },\n\n    buildNamespaceConflictError(rule: Rule): string {\n      const errMsg =\n        `Namespace conflict found in grammar.\\n` +\n        `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n        `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n        `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n        `and Non-Terminal names start with a lower case letter.`;\n\n      return errMsg;\n    },\n\n    buildAlternationPrefixAmbiguityError(options: {\n      topLevelRule: Rule;\n      prefixPath: TokenType[];\n      ambiguityIndices: number[];\n      alternation: Alternation;\n    }): string {\n      const pathMsg = map(options.prefixPath, (currTok) =>\n        tokenLabel(currTok),\n      ).join(\", \");\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n      const errMsg =\n        `Ambiguous alternatives: <${options.ambiguityIndices.join(\n          \" ,\",\n        )}> due to common lookahead prefix\\n` +\n        `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n        `For Further details.`;\n\n      return errMsg;\n    },\n\n    buildAlternationAmbiguityError(options: {\n      topLevelRule: Rule;\n      prefixPath: TokenType[];\n      ambiguityIndices: number[];\n      alternation: Alternation;\n    }): string {\n      const pathMsg = map(options.prefixPath, (currtok) =>\n        tokenLabel(currtok),\n      ).join(\", \");\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n      let currMessage =\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\n          \" ,\",\n        )}> in <OR${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n\n      currMessage =\n        currMessage +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n        `For Further details.`;\n      return currMessage;\n    },\n\n    buildEmptyRepetitionError(options: {\n      topLevelRule: Rule;\n      repetition: IProductionWithOccurrence;\n    }): string {\n      let dslName = getProductionDslName(options.repetition);\n      if (options.repetition.idx !== 0) {\n        dslName += options.repetition.idx;\n      }\n\n      const errMsg =\n        `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n        `This could lead to an infinite loop.`;\n\n      return errMsg;\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options: {\n      tokenType: TokenType;\n      expectedPattern: RegExp;\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\";\n    },\n\n    buildEmptyAlternationError(options: {\n      topLevelRule: Rule;\n      alternation: Alternation;\n      emptyChoiceIdx: number;\n    }): string {\n      const errMsg =\n        `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n        ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n        `Only the last alternative may be an empty alternative.`;\n\n      return errMsg;\n    },\n\n    buildTooManyAlternativesError(options: {\n      topLevelRule: Rule;\n      alternation: Alternation;\n    }): string {\n      const errMsg =\n        `An Alternation cannot have more than 256 alternatives:\\n` +\n        `<OR${options.alternation.idx}> inside <${\n          options.topLevelRule.name\n        }> Rule.\\n has ${\n          options.alternation.definition.length + 1\n        } alternatives.`;\n\n      return errMsg;\n    },\n\n    buildLeftRecursionError(options: {\n      topLevelRule: Rule;\n      leftRecursionPath: Rule[];\n    }): string {\n      const ruleName = options.topLevelRule.name;\n      const pathNames = map(\n        options.leftRecursionPath,\n        (currRule) => currRule.name,\n      );\n      const leftRecursivePath = `${ruleName} --> ${pathNames\n        .concat([ruleName])\n        .join(\" --> \")}`;\n      const errMsg =\n        `Left Recursion found in grammar.\\n` +\n        `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n        `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n        ` To fix this refactor your grammar to remove the left recursion.\\n` +\n        `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n\n      return errMsg;\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options: {\n      topLevelRule: Rule;\n      expectedPattern: RegExp;\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\";\n    },\n\n    buildDuplicateRuleNameError(options: {\n      topLevelRule: Rule | string;\n      grammarName: string;\n    }): string {\n      let ruleName;\n      if (options.topLevelRule instanceof Rule) {\n        ruleName = options.topLevelRule.name;\n      } else {\n        ruleName = options.topLevelRule;\n      }\n\n      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n\n      return errMsg;\n    },\n  };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2438, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2444, "column": 0}, "map": {"version":3,"file":"resolver.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/grammar/resolver.ts"],"sourcesContent":["import {\n  IParserUnresolvedRefDefinitionError,\n  ParserDefinitionErrorType,\n} from \"../parser/parser.js\";\nimport { forEach, values } from \"lodash-es\";\nimport { GAstVisitor, NonTerminal, Rule } from \"@chevrotain/gast\";\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IParserDefinitionError,\n} from \"./types.js\";\n\nexport function resolveGrammar(\n  topLevels: Record<string, Rule>,\n  errMsgProvider: IGrammarResolverErrorMessageProvider,\n): IParserDefinitionError[] {\n  const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n  refResolver.resolveRefs();\n  return refResolver.errors;\n}\n\nexport class GastRefResolverVisitor extends GAstVisitor {\n  public errors: IParserUnresolvedRefDefinitionError[] = [];\n  private currTopLevel: Rule;\n\n  constructor(\n    private nameToTopRule: Record<string, Rule>,\n    private errMsgProvider: IGrammarResolverErrorMessageProvider,\n  ) {\n    super();\n  }\n\n  public resolveRefs(): void {\n    forEach(values(this.nameToTopRule), (prod) => {\n      this.currTopLevel = prod;\n      prod.accept(this);\n    });\n  }\n\n  public visitNonTerminal(node: NonTerminal): void {\n    const ref = this.nameToTopRule[node.nonTerminalName];\n\n    if (!ref) {\n      const msg = this.errMsgProvider.buildRuleNotFoundError(\n        this.currTopLevel,\n        node,\n      );\n      this.errors.push({\n        message: msg,\n        type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n        ruleName: this.currTopLevel.name,\n        unresolvedRefName: node.nonTerminalName,\n      });\n    } else {\n      node.referencedRule = ref;\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAEL,yBAAyB,GAC1B,MAAM,qBAAqB,CAAC;AAE7B,OAAO,EAAE,WAAW,EAAqB,MAAM,kBAAkB,CAAC;AADlE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,WAAW,CAAC;;;;;;AAOtC,SAAU,cAAc,CAC5B,SAA+B,EAC/B,cAAoD;IAEpD,MAAM,WAAW,GAAG,IAAI,sBAAsB,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;IAC1E,WAAW,CAAC,WAAW,EAAE,CAAC;IAC1B,OAAO,WAAW,CAAC,MAAM,CAAC;AAC5B,CAAC;AAEK,MAAO,sBAAuB,iMAAQ,eAAW;IAIrD,YACU,aAAmC,EACnC,cAAoD,CAAA;QAE5D,KAAK,EAAE,CAAC;QAHA,IAAA,CAAA,aAAa,GAAb,aAAa,CAAsB;QACnC,IAAA,CAAA,cAAc,GAAd,cAAc,CAAsC;QALvD,IAAA,CAAA,MAAM,GAA0C,EAAE,CAAC;IAQ1D,CAAC;IAEM,WAAW,GAAA;qNAChB,UAAA,AAAO,GAAC,mNAAA,AAAM,EAAC,IAAI,CAAC,aAAa,CAAC,EAAE,CAAC,IAAI,EAAE,EAAE;YAC3C,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;YACzB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACpB,CAAC,CAAC,CAAC;IACL,CAAC;IAEM,gBAAgB,CAAC,IAAiB,EAAA;QACvC,MAAM,GAAG,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAErD,IAAI,CAAC,GAAG,EAAE;YACR,MAAM,GAAG,GAAG,IAAI,CAAC,cAAc,CAAC,sBAAsB,CACpD,IAAI,CAAC,YAAY,EACjB,IAAI,CACL,CAAC;YACF,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;gBACf,OAAO,EAAE,GAAG;gBACZ,IAAI,mMAAE,4BAAyB,CAAC,sBAAsB;gBACtD,QAAQ,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI;gBAChC,iBAAiB,EAAE,IAAI,CAAC,eAAe;aACxC,CAAC,CAAC;SACJ,MAAM;YACL,IAAI,CAAC,cAAc,GAAG,GAAG,CAAC;SAC3B;IACH,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 2489, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2495, "column": 0}, "map": {"version":3,"file":"interpreter.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/grammar/interpreter.ts"],"sourcesContent":["import {\n  clone,\n  drop,\n  dropRight,\n  first as _first,\n  forEach,\n  isEmpty,\n  last,\n} from \"lodash-es\";\nimport { first } from \"./first.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { TokenMatcher } from \"../parser/parser.js\";\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport {\n  IGrammarPath,\n  IProduction,\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType,\n} from \"@chevrotain/types\";\n\nexport abstract class AbstractNextPossibleTokensWalker extends RestWalker {\n  protected possibleTokTypes: TokenType[] = [];\n  protected ruleStack: string[];\n  protected occurrenceStack: number[];\n\n  protected nextProductionName = \"\";\n  protected nextProductionOccurrence = 0;\n  protected found = false;\n  protected isAtEndOfPath = false;\n\n  constructor(\n    protected topProd: Rule,\n    protected path: IGrammarPath,\n  ) {\n    super();\n  }\n\n  startWalking(): TokenType[] {\n    this.found = false;\n\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    }\n\n    // immutable for the win\n    this.ruleStack = clone(this.path.ruleStack).reverse(); // intelij bug requires assertion\n    this.occurrenceStack = clone(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n\n    // already verified that the first production is valid, we now seek the 2nd production\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n\n    return this.possibleTokTypes;\n  }\n\n  walk(\n    prod: { definition: IProduction[] },\n    prevRest: IProduction[] = [],\n  ): void {\n    // stop scanning once we found the path\n    if (!this.found) {\n      super.walk(prod, prevRest);\n    }\n  }\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    // found the next production, need to keep walking in it\n    if (\n      refProd.referencedRule.name === this.nextProductionName &&\n      refProd.idx === this.nextProductionOccurrence\n    ) {\n      const fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, <any>fullRest);\n    }\n  }\n\n  updateExpectedNext(): void {\n    // need to consume the Terminal\n    if (isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop()!;\n      this.nextProductionOccurrence = this.occurrenceStack.pop()!;\n    }\n  }\n}\n\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n  private nextTerminalName = \"\";\n  private nextTerminalOccurrence = 0;\n\n  constructor(\n    topProd: Rule,\n    protected path: ITokenGrammarPath,\n  ) {\n    super(topProd, path);\n    this.nextTerminalName = this.path.lastTok.name;\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (\n      this.isAtEndOfPath &&\n      terminal.terminalType.name === this.nextTerminalName &&\n      terminal.idx === this.nextTerminalOccurrence &&\n      !this.found\n    ) {\n      const fullRest = currRest.concat(prevRest);\n      const restProd = new Alternative({ definition: fullRest });\n      this.possibleTokTypes = first(restProd);\n      this.found = true;\n    }\n  }\n}\n\nexport type AlternativesFirstTokens = TokenType[][];\n\nexport interface IFirstAfterRepetition {\n  token: TokenType | undefined;\n  occurrence: number | undefined;\n  isEndOfRule: boolean | undefined;\n}\n\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n  protected result: IFirstAfterRepetition = {\n    token: undefined,\n    occurrence: undefined,\n    isEndOfRule: undefined,\n  };\n\n  constructor(\n    protected topRule: Rule,\n    protected occurrence: number,\n  ) {\n    super();\n  }\n\n  startWalking(): IFirstAfterRepetition {\n    this.walk(this.topRule);\n    return this.result;\n  }\n}\n\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (manyProd.idx === this.occurrence) {\n      const firstAfterMany = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterMany === undefined;\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      super.walkMany(manyProd, currRest, prevRest);\n    }\n  }\n}\n\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (manySepProd.idx === this.occurrence) {\n      const firstAfterManySep = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterManySep === undefined;\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      super.walkManySep(manySepProd, currRest, prevRest);\n    }\n  }\n}\n\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (atLeastOneProd.idx === this.occurrence) {\n      const firstAfterAtLeastOne = _first(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n    }\n  }\n}\n\n// TODO: reduce code duplication in the AfterWalkers\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOneSep(\n    atleastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      const firstAfterfirstAfterAtLeastOneSep = _first(\n        currRest.concat(prevRest),\n      );\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n    }\n  }\n}\n\nexport interface PartialPathAndSuffixes {\n  partialPath: TokenType[];\n  suffixDef: IProduction[];\n}\n\nexport function possiblePathsFrom(\n  targetDef: IProduction[],\n  maxLength: number,\n  currPath: TokenType[] = [],\n): PartialPathAndSuffixes[] {\n  // avoid side effects\n  currPath = clone(currPath);\n  let result: PartialPathAndSuffixes[] = [];\n  let i = 0;\n\n  // TODO: avoid inner funcs\n  function remainingPathWith(nextDef: IProduction[]) {\n    return nextDef.concat(drop(targetDef, i + 1));\n  }\n\n  // TODO: avoid inner funcs\n  function getAlternativesForProd(definition: IProduction[]) {\n    const alternatives = possiblePathsFrom(\n      remainingPathWith(definition),\n      maxLength,\n      currPath,\n    );\n    return result.concat(alternatives);\n  }\n\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n  while (currPath.length < maxLength && i < targetDef.length) {\n    const prod = targetDef[i];\n\n    /* istanbul ignore else */\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof RepetitionMandatory) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition,\n        }),\n      ]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const newDef = [\n        new Alternative({ definition: prod.definition }),\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition,\n          ),\n        }),\n      ];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition,\n          ),\n        }),\n      ]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Repetition) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition,\n        }),\n      ]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, (currAlt) => {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if (isEmpty(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition);\n        }\n      });\n      return result;\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n\n    i++;\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i),\n  });\n\n  return result;\n}\n\ninterface IPathToExamine {\n  idx: number;\n  def: IProduction[];\n  ruleStack: string[];\n  occurrenceStack: number[];\n}\n\nexport function nextPossibleTokensAfter(\n  initialDef: IProduction[],\n  tokenVector: IToken[],\n  tokMatcher: TokenMatcher,\n  maxLookAhead: number,\n): ISyntacticContentAssistPath[] {\n  const EXIT_NON_TERMINAL: any = \"EXIT_NONE_TERMINAL\";\n  // to avoid creating a new Array each time.\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  const EXIT_ALTERNATIVE: any = \"EXIT_ALTERNATIVE\";\n  let foundCompletePath = false;\n\n  const tokenVectorLength = tokenVector.length;\n  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n\n  const result: ISyntacticContentAssistPath[] = [];\n\n  const possiblePaths: IPathToExamine[] = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: [],\n  });\n\n  while (!isEmpty(possiblePaths)) {\n    const currPath = possiblePaths.pop()!;\n\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (\n        foundCompletePath &&\n        last(possiblePaths)!.idx <= minimalAlternativesIndex\n      ) {\n        // remove irrelevant alternative\n        possiblePaths.pop();\n      }\n      continue;\n    }\n\n    const currDef = currPath.def;\n    const currIdx = currPath.idx;\n    const currRuleStack = currPath.ruleStack;\n    const currOccurrenceStack = currPath.occurrenceStack;\n\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n    if (isEmpty(currDef)) {\n      continue;\n    }\n\n    const prod = currDef[0];\n    /* istanbul ignore else */\n    if (prod === EXIT_NON_TERMINAL) {\n      const nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack),\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        const nextIdx = currIdx + 1;\n        const actualToken = tokenVector[nextIdx];\n        if (tokMatcher!(actualToken, prod.terminalType)) {\n          const nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack,\n          };\n          possiblePaths.push(nextPath);\n        }\n        // end of the line\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof NonTerminal) {\n      const newRuleStack = clone(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n\n      const newOccurrenceStack = clone(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n\n      const nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack,\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n\n      const nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx,\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const separatorGast = new Terminal({\n        terminalType: prod.separator,\n      });\n      const secondIteration = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx,\n      });\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef));\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n\n      const separatorGast = new Terminal({\n        terminalType: prod.separator,\n      });\n      const nthRepetition = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx,\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWithout);\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE);\n\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n      const nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx,\n      });\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\n        const currAlt: any = prod.definition[i];\n        const currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack,\n      });\n    } else if (prod instanceof Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(\n        expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack),\n      );\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n  return result;\n}\n\nfunction expandTopLevelRule(\n  topRule: Rule,\n  currIdx: number,\n  currRuleStack: string[],\n  currOccurrenceStack: number[],\n): IPathToExamine {\n  const newRuleStack = clone(currRuleStack);\n  newRuleStack.push(topRule.name);\n\n  const newCurrOccurrenceStack = clone(currOccurrenceStack);\n  // top rule is always assumed to have been called with occurrence index 1\n  newCurrOccurrenceStack.push(1);\n\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack,\n  };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2993, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2999, "column": 0}, "map": {"version":3,"file":"lookahead.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/grammar/lookahead.ts"],"sourcesContent":["import { every, flatten, forEach, has, isEmpty, map, reduce } from \"lodash-es\";\nimport { possiblePathsFrom } from \"./interpreter.js\";\nimport { RestWalker } from \"./rest.js\";\nimport { Predicate, TokenMatcher } from \"../parser/parser.js\";\nimport {\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories,\n} from \"../../scan/tokens.js\";\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  GAstVisitor,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n} from \"@chevrotain/gast\";\nimport {\n  BaseParser,\n  IOrAlt,\n  IProduction,\n  IProductionWithOccurrence,\n  LookaheadProductionType,\n  LookaheadSequence,\n  Rule,\n  TokenType,\n} from \"@chevrotain/types\";\n\nexport enum PROD_TYPE {\n  OPTION,\n  REPETITION,\n  REPETITION_MANDATORY,\n  REPETITION_MANDATORY_WITH_SEPARATOR,\n  REPETITION_WITH_SEPARATOR,\n  ALTERNATION,\n}\n\nexport function getProdType(\n  prod: IProduction | LookaheadProductionType,\n): PROD_TYPE {\n  /* istanbul ignore else */\n  if (prod instanceof Option || prod === \"Option\") {\n    return PROD_TYPE.OPTION;\n  } else if (prod instanceof Repetition || prod === \"Repetition\") {\n    return PROD_TYPE.REPETITION;\n  } else if (\n    prod instanceof RepetitionMandatory ||\n    prod === \"RepetitionMandatory\"\n  ) {\n    return PROD_TYPE.REPETITION_MANDATORY;\n  } else if (\n    prod instanceof RepetitionMandatoryWithSeparator ||\n    prod === \"RepetitionMandatoryWithSeparator\"\n  ) {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n  } else if (\n    prod instanceof RepetitionWithSeparator ||\n    prod === \"RepetitionWithSeparator\"\n  ) {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n  } else if (prod instanceof Alternation || prod === \"Alternation\") {\n    return PROD_TYPE.ALTERNATION;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexport function getLookaheadPaths(options: {\n  occurrence: number;\n  rule: Rule;\n  prodType: LookaheadProductionType;\n  maxLookahead: number;\n}): LookaheadSequence[] {\n  const { occurrence, rule, prodType, maxLookahead } = options;\n  const type = getProdType(prodType);\n  if (type === PROD_TYPE.ALTERNATION) {\n    return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n  } else {\n    return getLookaheadPathsForOptionalProd(\n      occurrence,\n      rule,\n      type,\n      maxLookahead,\n    );\n  }\n}\n\nexport function buildLookaheadFuncForOr(\n  occurrence: number,\n  ruleGrammar: Rule,\n  maxLookahead: number,\n  hasPredicates: boolean,\n  dynamicTokensEnabled: boolean,\n  laFuncBuilder: Function,\n): (orAlts?: IOrAlt<any>[]) => number | undefined {\n  const lookAheadPaths = getLookaheadPathsForOr(\n    occurrence,\n    ruleGrammar,\n    maxLookahead,\n  );\n\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n    ? tokenStructuredMatcherNoCategories\n    : tokenStructuredMatcher;\n\n  return laFuncBuilder(\n    lookAheadPaths,\n    hasPredicates,\n    tokenMatcher,\n    dynamicTokensEnabled,\n  );\n}\n\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(\n  occurrence: number,\n  ruleGrammar: Rule,\n  k: number,\n  dynamicTokensEnabled: boolean,\n  prodType: PROD_TYPE,\n  lookaheadBuilder: (\n    lookAheadSequence: LookaheadSequence,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean,\n  ) => () => boolean,\n): () => boolean {\n  const lookAheadPaths = getLookaheadPathsForOptionalProd(\n    occurrence,\n    ruleGrammar,\n    prodType,\n    k,\n  );\n\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n    ? tokenStructuredMatcherNoCategories\n    : tokenStructuredMatcher;\n\n  return lookaheadBuilder(\n    lookAheadPaths[0],\n    tokenMatcher,\n    dynamicTokensEnabled,\n  );\n}\n\nexport type Alternative = TokenType[][];\n\nexport function buildAlternativesLookAheadFunc(\n  alts: LookaheadSequence[],\n  hasPredicates: boolean,\n  tokenMatcher: TokenMatcher,\n  dynamicTokensEnabled: boolean,\n): (orAlts: IOrAlt<any>[]) => number | undefined {\n  const numOfAlts = alts.length;\n  const areAllOneTokenLookahead = every(alts, (currAlt) => {\n    return every(currAlt, (currPath) => {\n      return currPath.length === 1;\n    });\n  });\n\n  // This version takes into account the predicates as well.\n  if (hasPredicates) {\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (\n      this: BaseParser,\n      orAlts: IOrAlt<any>[],\n    ): number | undefined {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      const predicates: (Predicate | undefined)[] = map(\n        orAlts,\n        (currAlt) => currAlt.GATE,\n      );\n\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t];\n        const currNumOfPaths = currAlt.length;\n\n        const currPredicate = predicates[t];\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue;\n        }\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j];\n          const currPathLength = currPath.length;\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1);\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t;\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined;\n    };\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    const singleTokenAlts = map(alts, (currAlt) => {\n      return flatten(currAlt);\n    });\n\n    const choiceToAlt = reduce(\n      singleTokenAlts,\n      (result, currAlt, idx) => {\n        forEach(currAlt, (currTokType) => {\n          if (!has(result, currTokType.tokenTypeIdx!)) {\n            result[currTokType.tokenTypeIdx!] = idx;\n          }\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\n            if (!has(result, currExtendingType)) {\n              result[currExtendingType] = idx;\n            }\n          });\n        });\n        return result;\n      },\n      {} as Record<number, number>,\n    );\n\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (this: BaseParser): number {\n      const nextToken = this.LA(1);\n      return choiceToAlt[nextToken.tokenTypeIdx];\n    };\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (this: BaseParser): number | undefined {\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t];\n        const currNumOfPaths = currAlt.length;\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j];\n          const currPathLength = currPath.length;\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1);\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t;\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined;\n    };\n  }\n}\n\nexport function buildSingleAlternativeLookaheadFunction(\n  alt: LookaheadSequence,\n  tokenMatcher: TokenMatcher,\n  dynamicTokensEnabled: boolean,\n): () => boolean {\n  const areAllOneTokenLookahead = every(alt, (currPath) => {\n    return currPath.length === 1;\n  });\n\n  const numOfPaths = alt.length;\n\n  // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    const singleTokensTypes = flatten(alt);\n\n    if (\n      singleTokensTypes.length === 1 &&\n      isEmpty((<any>singleTokensTypes[0]).categoryMatches)\n    ) {\n      const expectedTokenType = singleTokensTypes[0];\n      const expectedTokenUniqueKey = (<any>expectedTokenType).tokenTypeIdx;\n\n      return function (this: BaseParser): boolean {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n      };\n    } else {\n      const choiceToAlt = reduce(\n        singleTokensTypes,\n        (result, currTokType, idx) => {\n          result[currTokType.tokenTypeIdx!] = true;\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\n            result[currExtendingType] = true;\n          });\n          return result;\n        },\n        [] as boolean[],\n      );\n\n      return function (this: BaseParser): boolean {\n        const nextToken = this.LA(1);\n        return choiceToAlt[nextToken.tokenTypeIdx] === true;\n      };\n    }\n  } else {\n    return function (this: BaseParser): boolean {\n      nextPath: for (let j = 0; j < numOfPaths; j++) {\n        const currPath = alt[j];\n        const currPathLength = currPath.length;\n        for (let i = 0; i < currPathLength; i++) {\n          const nextToken = this.LA(i + 1);\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath;\n          }\n        }\n        // found a full path that matches.\n        return true;\n      }\n\n      // none of the paths matched\n      return false;\n    };\n  }\n}\n\nclass RestDefinitionFinderWalker extends RestWalker {\n  private restDef: IProduction[];\n\n  constructor(\n    private topProd: Rule,\n    private targetOccurrence: number,\n    private targetProdType: PROD_TYPE,\n  ) {\n    super();\n  }\n\n  startWalking(): IProduction[] {\n    this.walk(this.topProd);\n    return this.restDef;\n  }\n\n  private checkIsTarget(\n    node: IProductionWithOccurrence,\n    expectedProdType: PROD_TYPE,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): boolean {\n    if (\n      node.idx === this.targetOccurrence &&\n      this.targetProdType === expectedProdType\n    ) {\n      this.restDef = currRest.concat(prevRest);\n      return true;\n    }\n    // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n    return false;\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      super.walkOption(optionProd, currRest, prevRest);\n    }\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (\n      !this.checkIsTarget(\n        atLeastOneProd,\n        PROD_TYPE.REPETITION_MANDATORY,\n        currRest,\n        prevRest,\n      )\n    ) {\n      super.walkOption(atLeastOneProd, currRest, prevRest);\n    }\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (\n      !this.checkIsTarget(\n        atLeastOneSepProd,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        currRest,\n        prevRest,\n      )\n    ) {\n      super.walkOption(atLeastOneSepProd, currRest, prevRest);\n    }\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (\n      !this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)\n    ) {\n      super.walkOption(manyProd, currRest, prevRest);\n    }\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[],\n  ): void {\n    if (\n      !this.checkIsTarget(\n        manySepProd,\n        PROD_TYPE.REPETITION_WITH_SEPARATOR,\n        currRest,\n        prevRest,\n      )\n    ) {\n      super.walkOption(manySepProd, currRest, prevRest);\n    }\n  }\n}\n\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\n  public result: IProduction[] = [];\n\n  constructor(\n    private targetOccurrence: number,\n    private targetProdType: PROD_TYPE,\n    private targetRef?: any,\n  ) {\n    super();\n  }\n\n  private checkIsTarget(\n    node: { definition: IProduction[] } & IProductionWithOccurrence,\n    expectedProdName: PROD_TYPE,\n  ): void {\n    if (\n      node.idx === this.targetOccurrence &&\n      this.targetProdType === expectedProdName &&\n      (this.targetRef === undefined || node === this.targetRef)\n    ) {\n      this.result = node.definition;\n    }\n  }\n\n  public visitOption(node: Option): void {\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\n  }\n\n  public visitRepetition(node: Repetition): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\n  }\n\n  public visitRepetitionMandatory(node: RepetitionMandatory): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator,\n  ): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n  }\n\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n  }\n\n  public visitAlternation(node: Alternation): void {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n  }\n}\n\nfunction initializeArrayOfArrays(size: number): any[][] {\n  const result = new Array(size);\n  for (let i = 0; i < size; i++) {\n    result[i] = [];\n  }\n  return result;\n}\n\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path: TokenType[]): string[] {\n  let keys = [\"\"];\n  for (let i = 0; i < path.length; i++) {\n    const tokType = path[i];\n    const longerKeys = [];\n    for (let j = 0; j < keys.length; j++) {\n      const currShorterKey = keys[j];\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n      for (let t = 0; t < tokType.categoryMatches!.length; t++) {\n        const categoriesKeySuffix = \"_\" + tokType.categoryMatches![t];\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\n      }\n    }\n    keys = longerKeys;\n  }\n  return keys;\n}\n\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(\n  altKnownPathsKeys: Record<string, boolean>[],\n  searchPathKeys: string[],\n  idx: number,\n): boolean {\n  for (\n    let currAltIdx = 0;\n    currAltIdx < altKnownPathsKeys.length;\n    currAltIdx++\n  ) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue;\n    }\n    const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n    for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      const searchKey = searchPathKeys[searchIdx];\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false;\n      }\n    }\n  }\n  // None of the SearchPathKeys were found in any of the other alternatives\n  return true;\n}\n\nexport function lookAheadSequenceFromAlternatives(\n  altsDefs: IProduction[],\n  k: number,\n): LookaheadSequence[] {\n  const partialAlts = map(altsDefs, (currAlt) =>\n    possiblePathsFrom([currAlt], 1),\n  );\n  const finalResult = initializeArrayOfArrays(partialAlts.length);\n  const altsHashes = map(partialAlts, (currAltPaths) => {\n    const dict: { [key: string]: boolean } = {};\n    forEach(currAltPaths, (item) => {\n      const keys = pathToHashKeys(item.partialPath);\n      forEach(keys, (currKey) => {\n        dict[currKey] = true;\n      });\n    });\n    return dict;\n  });\n  let newData = partialAlts;\n\n  // maxLookahead loop\n  for (let pathLength = 1; pathLength <= k; pathLength++) {\n    const currDataset = newData;\n    newData = initializeArrayOfArrays(currDataset.length);\n\n    // alternatives loop\n    for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      const currAltPathsAndSuffixes = currDataset[altIdx];\n      // paths in current alternative loop\n      for (\n        let currPathIdx = 0;\n        currPathIdx < currAltPathsAndSuffixes.length;\n        currPathIdx++\n      ) {\n        const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n        const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n        const prefixKeys = pathToHashKeys(currPathPrefix);\n        const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n        // End of the line for this path.\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n          const currAltResult = finalResult[altIdx];\n          // TODO: Can we implement a containsPath using Maps/Dictionaries?\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix);\n            // Update all new  keys for the current path.\n            for (let j = 0; j < prefixKeys.length; j++) {\n              const currKey = prefixKeys[j];\n              altsHashes[altIdx][currKey] = true;\n            }\n          }\n        }\n        // Expand longer paths\n        else {\n          const newPartialPathsAndSuffixes = possiblePathsFrom(\n            suffixDef,\n            pathLength + 1,\n            currPathPrefix,\n          );\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n\n          // Update keys for new known paths\n          forEach(newPartialPathsAndSuffixes, (item) => {\n            const prefixKeys = pathToHashKeys(item.partialPath);\n            forEach(prefixKeys, (key) => {\n              altsHashes[altIdx][key] = true;\n            });\n          });\n        }\n      }\n    }\n  }\n\n  return finalResult;\n}\n\nexport function getLookaheadPathsForOr(\n  occurrence: number,\n  ruleGrammar: Rule,\n  k: number,\n  orProd?: Alternation,\n): LookaheadSequence[] {\n  const visitor = new InsideDefinitionFinderVisitor(\n    occurrence,\n    PROD_TYPE.ALTERNATION,\n    orProd,\n  );\n  ruleGrammar.accept(visitor);\n  return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\n\nexport function getLookaheadPathsForOptionalProd(\n  occurrence: number,\n  ruleGrammar: Rule,\n  prodType: PROD_TYPE,\n  k: number,\n): LookaheadSequence[] {\n  const insideDefVisitor = new InsideDefinitionFinderVisitor(\n    occurrence,\n    prodType,\n  );\n  ruleGrammar.accept(insideDefVisitor);\n  const insideDef = insideDefVisitor.result;\n\n  const afterDefWalker = new RestDefinitionFinderWalker(\n    ruleGrammar,\n    occurrence,\n    prodType,\n  );\n  const afterDef = afterDefWalker.startWalking();\n\n  const insideFlat = new AlternativeGAST({ definition: insideDef });\n  const afterFlat = new AlternativeGAST({ definition: afterDef });\n\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\n\nexport function containsPath(\n  alternative: Alternative,\n  searchPath: TokenType[],\n): boolean {\n  compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n    const otherPath = alternative[i];\n    if (otherPath.length !== searchPath.length) {\n      continue;\n    }\n    for (let j = 0; j < otherPath.length; j++) {\n      const searchTok = searchPath[j];\n      const otherTok = otherPath[j];\n\n      const matchingTokens =\n        searchTok === otherTok ||\n        otherTok.categoryMatchesMap![searchTok.tokenTypeIdx!] !== undefined;\n      if (matchingTokens === false) {\n        continue compareOtherPath;\n      }\n    }\n    return true;\n  }\n\n  return false;\n}\n\nexport function isStrictPrefixOfPath(\n  prefix: TokenType[],\n  other: TokenType[],\n): boolean {\n  return (\n    prefix.length < other.length &&\n    every(prefix, (tokType, idx) => {\n      const otherTokType = other[idx];\n      return (\n        tokType === otherTokType ||\n        otherTokType.categoryMatchesMap![tokType.tokenTypeIdx!]\n      );\n    })\n  );\n}\n\nexport function areTokenCategoriesNotUsed(\n  lookAheadPaths: LookaheadSequence[],\n): boolean {\n  return every(lookAheadPaths, (singleAltPaths) =>\n    every(singleAltPaths, (singlePath) =>\n      every(singlePath, (token) => isEmpty(token.categoryMatches!)),\n    ),\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3455, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3461, "column": 0}, "map": {"version":3,"file":"checks.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/grammar/checks.ts"],"sourcesContent":["import {\n  clone,\n  compact,\n  difference,\n  drop,\n  dropRight,\n  filter,\n  first,\n  flatMap,\n  flatten,\n  forEach,\n  groupBy,\n  includes,\n  isEmpty,\n  map,\n  pickBy,\n  reduce,\n  reject,\n  values,\n} from \"lodash-es\";\nimport {\n  IParserAmbiguousAlternativesDefinitionError,\n  IParserDuplicatesDefinitionError,\n  IParserEmptyAlternativeDefinitionError,\n  ParserDefinitionErrorType,\n} from \"../parser/parser.js\";\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  GAstVisitor,\n  getProductionDslName,\n  isOptionalProd,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport {\n  Alternative,\n  containsPath,\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  getProdType,\n  isStrictPrefixOfPath,\n} from \"./lookahead.js\";\nimport { nextPossibleTokensAfter } from \"./interpreter.js\";\nimport {\n  ILookaheadStrategy,\n  IProduction,\n  IProductionWithOccurrence,\n  Rule,\n  TokenType,\n} from \"@chevrotain/types\";\nimport {\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError,\n} from \"./types.js\";\nimport { tokenStructuredMatcher } from \"../../scan/tokens.js\";\n\nexport function validateLookahead(options: {\n  lookaheadStrategy: ILookaheadStrategy;\n  rules: Rule[];\n  tokenTypes: TokenType[];\n  grammarName: string;\n}): IParserDefinitionError[] {\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName,\n  });\n  return map(lookaheadValidationErrorMessages, (errorMessage) => ({\n    type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION,\n    ...errorMessage,\n  }));\n}\n\nexport function validateGrammar(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  grammarName: string,\n): IParserDefinitionError[] {\n  const duplicateErrors: IParserDefinitionError[] = flatMap(\n    topLevels,\n    (currTopLevel) =>\n      validateDuplicateProductions(currTopLevel, errMsgProvider),\n  );\n\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\n    topLevels,\n    tokenTypes,\n    errMsgProvider,\n  );\n\n  const tooManyAltsErrors = flatMap(topLevels, (curRule) =>\n    validateTooManyAlts(curRule, errMsgProvider),\n  );\n\n  const duplicateRulesError = flatMap(topLevels, (curRule) =>\n    validateRuleDoesNotAlreadyExist(\n      curRule,\n      topLevels,\n      grammarName,\n      errMsgProvider,\n    ),\n  );\n\n  return duplicateErrors.concat(\n    termsNamespaceConflictErrors,\n    tooManyAltsErrors,\n    duplicateRulesError,\n  );\n}\n\nfunction validateDuplicateProductions(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDuplicatesDefinitionError[] {\n  const collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  const allRuleProductions = collectorVisitor.allProductions;\n\n  const productionGroups = groupBy(\n    allRuleProductions,\n    identifyProductionForDuplicates,\n  );\n\n  const duplicates: any = pickBy(productionGroups, (currGroup) => {\n    return currGroup.length > 1;\n  });\n\n  const errors = map(values(duplicates), (currDuplicates: any) => {\n    const firstProd: any = first(currDuplicates);\n    const msg = errMsgProvider.buildDuplicateFoundError(\n      topLevelRule,\n      currDuplicates,\n    );\n    const dslName = getProductionDslName(firstProd);\n    const defError: IParserDuplicatesDefinitionError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx,\n    };\n\n    const param = getExtraProductionArgument(firstProd);\n    if (param) {\n      defError.parameter = param;\n    }\n\n    return defError;\n  });\n  return errors;\n}\n\nexport function identifyProductionForDuplicates(\n  prod: IProductionWithOccurrence,\n): string {\n  return `${getProductionDslName(prod)}_#_${\n    prod.idx\n  }_#_${getExtraProductionArgument(prod)}`;\n}\n\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  public allProductions: IProductionWithOccurrence[] = [];\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    this.allProductions.push(subrule);\n  }\n\n  public visitOption(option: Option): void {\n    this.allProductions.push(option);\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep);\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne);\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator,\n  ): void {\n    this.allProductions.push(atLeastOneSep);\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many);\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.allProductions.push(or);\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    this.allProductions.push(terminal);\n  }\n}\n\nexport function validateRuleDoesNotAlreadyExist(\n  rule: Rule,\n  allRules: Rule[],\n  className: string,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDefinitionError[] {\n  const errors = [];\n  const occurrences = reduce(\n    allRules,\n    (result, curRule) => {\n      if (curRule.name === rule.name) {\n        return result + 1;\n      }\n      return result;\n    },\n    0,\n  );\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className,\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name,\n    });\n  }\n\n  return errors;\n}\n\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(\n  ruleName: string,\n  definedRulesNames: string[],\n  className: string,\n): IParserDefinitionError[] {\n  const errors = [];\n  let errMsg;\n\n  if (!includes(definedRulesNames, ruleName)) {\n    errMsg =\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n      `as it is not defined in any of the super grammars `;\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName,\n    });\n  }\n\n  return errors;\n}\n\nexport function validateNoLeftRecursion(\n  topRule: Rule,\n  currRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  path: Rule[] = [],\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = [];\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n  if (isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    const ruleName = topRule.name;\n    const foundLeftRecursion = includes(nextNonTerminals, topRule);\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path,\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName,\n      });\n    }\n\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]));\n    const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n      const newPath = clone(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(\n        topRule,\n        currRefRule,\n        errMsgProvider,\n        newPath,\n      );\n    });\n\n    return errors.concat(errorsFromNextSteps);\n  }\n}\n\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\n  let result: Rule[] = [];\n  if (isEmpty(definition)) {\n    return result;\n  }\n  const firstProd = first(definition);\n\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (\n    firstProd instanceof AlternativeGAST ||\n    firstProd instanceof Option ||\n    firstProd instanceof RepetitionMandatory ||\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\n    firstProd instanceof RepetitionWithSeparator ||\n    firstProd instanceof Repetition\n  ) {\n    result = result.concat(\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition),\n    );\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = flatten(\n      map(firstProd.definition, (currSubDef) =>\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition),\n      ),\n    );\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n\n  const isFirstOptional = isOptionalProd(firstProd);\n  const hasMore = definition.length > 1;\n  if (isFirstOptional && hasMore) {\n    const rest = drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n\nclass OrCollector extends GAstVisitor {\n  public alternations: Alternation[] = [];\n\n  public visitAlternation(node: Alternation): void {\n    this.alternations.push(node);\n  }\n}\n\nexport function validateEmptyOrAlternative(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserEmptyAlternativeDefinitionError[] {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n\n  const errors = flatMap<Alternation, IParserEmptyAlternativeDefinitionError>(\n    ors,\n    (currOr) => {\n      const exceptLast = dropRight(currOr.definition);\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n        const possibleFirstInAlt = nextPossibleTokensAfter(\n          [currAlternative],\n          [],\n          tokenStructuredMatcher,\n          1,\n        );\n        if (isEmpty(possibleFirstInAlt)) {\n          return [\n            {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx,\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1,\n            },\n          ];\n        } else {\n          return [];\n        }\n      });\n    },\n  );\n\n  return errors;\n}\n\nexport function validateAmbiguousAlternationAlternatives(\n  topLevelRule: Rule,\n  globalMaxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  let ors = orCollector.alternations;\n\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true);\n\n  const errors = flatMap(ors, (currOr: Alternation) => {\n    const currOccurrence = currOr.idx;\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    const alternatives = getLookaheadPathsForOr(\n      currOccurrence,\n      topLevelRule,\n      actualMaxLookahead,\n      currOr,\n    );\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider,\n    );\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider,\n    );\n\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n\n  return errors;\n}\n\nexport class RepetitionCollector extends GAstVisitor {\n  public allProductions: (IProductionWithOccurrence & {\n    maxLookahead?: number;\n  })[] = [];\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep);\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne);\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator,\n  ): void {\n    this.allProductions.push(atLeastOneSep);\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many);\n  }\n}\n\nexport function validateTooManyAlts(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDefinitionError[] {\n  const orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  const ors = orCollector.alternations;\n\n  const errors = flatMap(ors, (currOr) => {\n    if (currOr.definition.length > 255) {\n      return [\n        {\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n        },\n      ];\n    } else {\n      return [];\n    }\n  });\n\n  return errors;\n}\n\nexport function validateSomeNonEmptyLookaheadPath(\n  topLevelRules: Rule[],\n  maxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = [];\n  forEach(topLevelRules, (currTopRule) => {\n    const collectorVisitor = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor);\n    const allRuleProductions = collectorVisitor.allProductions;\n    forEach(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd);\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      const currOccurrence = currProd.idx;\n      const paths = getLookaheadPathsForOptionalProd(\n        currOccurrence,\n        currTopRule,\n        prodType,\n        actualMaxLookahead,\n      );\n      const pathsInsideProduction = paths[0];\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd,\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name,\n        });\n      }\n    });\n  });\n\n  return errors;\n}\n\nexport interface IAmbiguityDescriptor {\n  alts: number[];\n  path: TokenType[];\n}\n\nfunction checkAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const foundAmbiguousPaths: Alternative = [];\n  const identicalAmbiguities = reduce(\n    alternatives,\n    (result, currAlt, currAltIdx) => {\n      // ignore (skip) ambiguities with this alternative\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n        return result;\n      }\n\n      forEach(currAlt, (currPath) => {\n        const altsCurrPathAppearsIn = [currAltIdx];\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n          if (\n            currAltIdx !== currOtherAltIdx &&\n            containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n          ) {\n            altsCurrPathAppearsIn.push(currOtherAltIdx);\n          }\n        });\n\n        if (\n          altsCurrPathAppearsIn.length > 1 &&\n          !containsPath(foundAmbiguousPaths, currPath)\n        ) {\n          foundAmbiguousPaths.push(currPath);\n          result.push({\n            alts: altsCurrPathAppearsIn,\n            path: currPath,\n          });\n        }\n      });\n      return result;\n    },\n    [] as { alts: number[]; path: TokenType[] }[],\n  );\n\n  const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map(\n      currAmbDescriptor.alts,\n      (currAltIdx) => currAltIdx + 1,\n    );\n\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path,\n    });\n\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts,\n    };\n  });\n\n  return currErrors;\n}\n\nexport function checkPrefixAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserAmbiguousAlternativesDefinitionError[] {\n  // flatten\n  const pathsAndIndices = reduce(\n    alternatives,\n    (result, currAlt, idx) => {\n      const currPathsAndIdx = map(currAlt, (currPath) => {\n        return { idx: idx, path: currPath };\n      });\n      return result.concat(currPathsAndIdx);\n    },\n    [] as { idx: number; path: TokenType[] }[],\n  );\n\n  const errors = compact(\n    flatMap(pathsAndIndices, (currPathAndIdx) => {\n      const alternativeGast = alternation.definition[currPathAndIdx.idx];\n      // ignore (skip) ambiguities with this alternative\n      if (alternativeGast.ignoreAmbiguities === true) {\n        return [];\n      }\n      const targetIdx = currPathAndIdx.idx;\n      const targetPath = currPathAndIdx.path;\n\n      const prefixAmbiguitiesPathsAndIndices = filter(\n        pathsAndIndices,\n        (searchPathAndIdx) => {\n          // prefix ambiguity can only be created from lower idx (higher priority) path\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n              true &&\n            searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          );\n        },\n      );\n\n      const currPathPrefixErrors = map(\n        prefixAmbiguitiesPathsAndIndices,\n        (currAmbPathAndIdx): IParserAmbiguousAlternativesDefinitionError => {\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n          const occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path,\n          });\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices,\n          };\n        },\n      );\n\n      return currPathPrefixErrors;\n    }),\n  );\n\n  return errors;\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = [];\n\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name);\n\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name;\n    if (includes(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName,\n      });\n    }\n  });\n\n  return errors;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3923, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3929, "column": 0}, "map": {"version":3,"file":"gast_resolver_public.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/grammar/gast/gast_resolver_public.ts"],"sourcesContent":["import { Rule } from \"@chevrotain/gast\";\nimport { defaults, forEach } from \"lodash-es\";\nimport { resolveGrammar as orgResolveGrammar } from \"../resolver.js\";\nimport { validateGrammar as orgValidateGrammar } from \"../checks.js\";\nimport {\n  defaultGrammarResolverErrorProvider,\n  defaultGrammarValidatorErrorProvider,\n} from \"../../errors_public.js\";\nimport { TokenType } from \"@chevrotain/types\";\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError,\n} from \"../types.js\";\n\ntype ResolveGrammarOpts = {\n  rules: Rule[];\n  errMsgProvider?: IGrammarResolverErrorMessageProvider;\n};\nexport function resolveGrammar(\n  options: ResolveGrammarOpts,\n): IParserDefinitionError[] {\n  const actualOptions: Required<ResolveGrammarOpts> = defaults(options, {\n    errMsgProvider: defaultGrammarResolverErrorProvider,\n  });\n\n  const topRulesTable: { [ruleName: string]: Rule } = {};\n  forEach(options.rules, (rule) => {\n    topRulesTable[rule.name] = rule;\n  });\n  return orgResolveGrammar(topRulesTable, actualOptions.errMsgProvider);\n}\n\nexport function validateGrammar(options: {\n  rules: Rule[];\n  tokenTypes: TokenType[];\n  grammarName: string;\n  errMsgProvider: IGrammarValidatorErrorMessageProvider;\n}): IParserDefinitionError[] {\n  options = defaults(options, {\n    errMsgProvider: defaultGrammarValidatorErrorProvider,\n  });\n\n  return orgValidateGrammar(\n    options.rules,\n    options.tokenTypes,\n    options.errMsgProvider,\n    options.grammarName,\n  );\n}\n"],"names":[],"mappings":";;;;AAEA,OAAO,EAAE,cAAc,IAAI,iBAAiB,EAAE,MAAM,gBAAgB,CAAC;AACrE,OAAO,EAAE,eAAe,IAAI,kBAAkB,EAAE,MAAM,cAAc,CAAC;AACrE,OAAO,EACL,mCAAmC,EACnC,oCAAoC,GACrC,MAAM,wBAAwB,CAAC;;AANhC,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;;;;;AAkBxC,SAAU,cAAc,CAC5B,OAA2B;IAE3B,MAAM,aAAa,kNAAiC,WAAA,AAAQ,EAAC,OAAO,EAAE;QACpE,cAAc,gMAAE,sCAAmC;KACpD,CAAC,CAAC;IAEH,MAAM,aAAa,GAAiC,CAAA,CAAE,CAAC;IACvD,uNAAA,AAAO,EAAC,OAAO,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,EAAE;QAC9B,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;IAClC,CAAC,CAAC,CAAC;IACH,+MAAO,iBAAA,AAAiB,EAAC,aAAa,EAAE,aAAa,CAAC,cAAc,CAAC,CAAC;AACxE,CAAC;AAEK,SAAU,eAAe,CAAC,OAK/B;IACC,OAAO,kNAAG,WAAA,AAAQ,EAAC,OAAO,EAAE;QAC1B,cAAc,gMAAE,uCAAoC;KACrD,CAAC,CAAC;IAEH,6MAAO,kBAAA,AAAkB,EACvB,OAAO,CAAC,KAAK,EACb,OAAO,CAAC,UAAU,EAClB,OAAO,CAAC,cAAc,EACtB,OAAO,CAAC,WAAW,CACpB,CAAC;AACJ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 3958, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3964, "column": 0}, "map": {"version":3,"file":"exceptions_public.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/exceptions_public.ts"],"sourcesContent":["import { includes } from \"lodash-es\";\nimport {\n  IRecognitionException,\n  IRecognizerContext,\n  IToken,\n} from \"@chevrotain/types\";\n\nconst MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\nconst NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\nconst EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\nconst NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\n\nconst RECOGNITION_EXCEPTION_NAMES = [\n  MISMATCHED_TOKEN_EXCEPTION,\n  NO_VIABLE_ALT_EXCEPTION,\n  EARLY_EXIT_EXCEPTION,\n  NOT_ALL_INPUT_PARSED_EXCEPTION,\n];\n\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\n\n// hacks to bypass no support for custom Errors in javascript/typescript\nexport function isRecognitionException(error: Error) {\n  // can't do instanceof on hacked custom js exceptions\n  return includes(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\n\nabstract class RecognitionException\n  extends Error\n  implements IRecognitionException\n{\n  context: IRecognizerContext;\n  resyncedTokens: IToken[] = [];\n\n  protected constructor(\n    message: string,\n    public token: IToken,\n  ) {\n    super(message);\n\n    // fix prototype chain when typescript target is ES5\n    Object.setPrototypeOf(this, new.target.prototype);\n\n    /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class MismatchedTokenException extends RecognitionException {\n  constructor(\n    message: string,\n    token: IToken,\n    public previousToken: IToken,\n  ) {\n    super(message, token);\n    this.name = MISMATCHED_TOKEN_EXCEPTION;\n  }\n}\n\nexport class NoViableAltException extends RecognitionException {\n  constructor(\n    message: string,\n    token: IToken,\n    public previousToken: IToken,\n  ) {\n    super(message, token);\n    this.name = NO_VIABLE_ALT_EXCEPTION;\n  }\n}\n\nexport class NotAllInputParsedException extends RecognitionException {\n  constructor(message: string, token: IToken) {\n    super(message, token);\n    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n  }\n}\n\nexport class EarlyExitException extends RecognitionException {\n  constructor(\n    message: string,\n    token: IToken,\n    public previousToken: IToken,\n  ) {\n    super(message, token);\n    this.name = EARLY_EXIT_EXCEPTION;\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,WAAW,CAAC;;AAOrC,MAAM,0BAA0B,GAAG,0BAA0B,CAAC;AAC9D,MAAM,uBAAuB,GAAG,sBAAsB,CAAC;AACvD,MAAM,oBAAoB,GAAG,oBAAoB,CAAC;AAClD,MAAM,8BAA8B,GAAG,4BAA4B,CAAC;AAEpE,MAAM,2BAA2B,GAAG;IAClC,0BAA0B;IAC1B,uBAAuB;IACvB,oBAAoB;IACpB,8BAA8B;CAC/B,CAAC;AAEF,MAAM,CAAC,MAAM,CAAC,2BAA2B,CAAC,CAAC;AAGrC,SAAU,sBAAsB,CAAC,KAAY;IACjD,qDAAqD;IACrD,OAAO,0NAAA,AAAQ,EAAC,2BAA2B,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;AAC3D,CAAC;AAED,MAAe,oBACb,SAAQ,KAAK;IAMb,YACE,OAAe,EACR,KAAa,CAAA;QAEpB,KAAK,CAAC,OAAO,CAAC,CAAC;QAFR,IAAA,CAAA,KAAK,GAAL,KAAK,CAAQ;QAJtB,IAAA,CAAA,cAAc,GAAa,EAAE,CAAC;QAQ5B,oDAAoD;QACpD,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAElD,4GAAA,EAA8G,CAC9G,IAAI,KAAK,CAAC,iBAAiB,EAAE;YAC3B,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;SACjD;IACH,CAAC;CACF;AAEK,MAAO,wBAAyB,SAAQ,oBAAoB;IAChE,YACE,OAAe,EACf,KAAa,EACN,aAAqB,CAAA;QAE5B,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QAFf,IAAA,CAAA,aAAa,GAAb,aAAa,CAAQ;QAG5B,IAAI,CAAC,IAAI,GAAG,0BAA0B,CAAC;IACzC,CAAC;CACF;AAEK,MAAO,oBAAqB,SAAQ,oBAAoB;IAC5D,YACE,OAAe,EACf,KAAa,EACN,aAAqB,CAAA;QAE5B,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QAFf,IAAA,CAAA,aAAa,GAAb,aAAa,CAAQ;QAG5B,IAAI,CAAC,IAAI,GAAG,uBAAuB,CAAC;IACtC,CAAC;CACF;AAEK,MAAO,0BAA2B,SAAQ,oBAAoB;IAClE,YAAY,OAAe,EAAE,KAAa,CAAA;QACxC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACtB,IAAI,CAAC,IAAI,GAAG,8BAA8B,CAAC;IAC7C,CAAC;CACF;AAEK,MAAO,kBAAmB,SAAQ,oBAAoB;IAC1D,YACE,OAAe,EACf,KAAa,EACN,aAAqB,CAAA;QAE5B,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QAFf,IAAA,CAAA,aAAa,GAAb,aAAa,CAAQ;QAG5B,IAAI,CAAC,IAAI,GAAG,oBAAoB,CAAC;IACnC,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 4027, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4033, "column": 0}, "map": {"version":3,"file":"recoverable.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/parser/traits/recoverable.ts"],"sourcesContent":["import {\n  createTokenInstance,\n  EOF,\n  tokenMatcher,\n} from \"../../../scan/tokens_public.js\";\nimport {\n  AbstractNextTerminalAfterProductionWalker,\n  IFirstAfterRepetition,\n} from \"../../grammar/interpreter.js\";\nimport {\n  clone,\n  dropRight,\n  find,\n  flatten,\n  has,\n  includes,\n  isEmpty,\n  map,\n} from \"lodash-es\";\nimport {\n  IParserConfig,\n  IToken,\n  ITokenGrammarPath,\n  TokenType,\n} from \"@chevrotain/types\";\nimport { MismatchedTokenException } from \"../../exceptions_public.js\";\nimport { IN } from \"../../constants.js\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n\nexport const EOF_FOLLOW_KEY: any = {};\n\nexport interface IFollowKey {\n  ruleName: string;\n  idxInCallingRule: number;\n  inRule: string;\n}\n\nexport const IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\n\nexport class InRuleRecoveryException extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = IN_RULE_RECOVERY_EXCEPTION;\n  }\n}\n\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nexport class Recoverable {\n  recoveryEnabled: boolean;\n  firstAfterRepMap: Record<string, IFirstAfterRepetition>;\n  resyncFollows: Record<string, TokenType[]>;\n\n  initRecoverable(config: IParserConfig) {\n    this.firstAfterRepMap = {};\n    this.resyncFollows = {};\n\n    this.recoveryEnabled = has(config, \"recoveryEnabled\")\n      ? (config.recoveryEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n\n    // performance optimization, NOOP will be inlined which\n    // effectively means that this optional feature does not exist\n    // when not used.\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n    }\n  }\n\n  public getTokenToInsert(tokType: TokenType): IToken {\n    const tokToInsert = createTokenInstance(\n      tokType,\n      \"\",\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n    );\n    tokToInsert.isInsertedInRecovery = true;\n    return tokToInsert;\n  }\n\n  public canTokenTypeBeInsertedInRecovery(tokType: TokenType): boolean {\n    return true;\n  }\n\n  public canTokenTypeBeDeletedInRecovery(tokType: TokenType): boolean {\n    return true;\n  }\n\n  tryInRepetitionRecovery(\n    this: MixedInParser,\n    grammarRule: Function,\n    grammarRuleArgs: any[],\n    lookAheadFunc: () => boolean,\n    expectedTokType: TokenType,\n  ): void {\n    // TODO: can the resyncTokenType be cached?\n    const reSyncTokType = this.findReSyncTokenType();\n    const savedLexerState = this.exportLexerState();\n    const resyncedTokens: IToken[] = [];\n    let passedResyncPoint = false;\n\n    const nextTokenWithoutResync = this.LA(1);\n    let currToken = this.LA(1);\n\n    const generateErrorMessage = () => {\n      const previousToken = this.LA(0);\n      // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n      // the error that would have been thrown\n      const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName(),\n      });\n      const error = new MismatchedTokenException(\n        msg,\n        nextTokenWithoutResync,\n        this.LA(0),\n      );\n      // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n      error.resyncedTokens = dropRight(resyncedTokens);\n      this.SAVE_ERROR(error);\n    };\n\n    while (!passedResyncPoint) {\n      // re-synced to a point where we can safely exit the repetition/\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage();\n        return; // must return here to avoid reverting the inputIdx\n      } else if (lookAheadFunc.call(this)) {\n        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n        generateErrorMessage();\n        // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n        grammarRule.apply(this, grammarRuleArgs);\n        return; // must return here to avoid reverting the inputIdx\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true;\n      } else {\n        currToken = this.SKIP_TOKEN();\n        this.addToResyncTokens(currToken, resyncedTokens);\n      }\n    }\n\n    // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n    // \"between rules\" resync recovery later in the flow.\n    this.importLexerState(savedLexerState);\n  }\n\n  shouldInRepetitionRecoveryBeTried(\n    this: MixedInParser,\n    expectTokAfterLastMatch: TokenType,\n    nextTokIdx: number,\n    notStuck: boolean | undefined,\n  ): boolean {\n    // Edge case of arriving from a MANY repetition which is stuck\n    // Attempting recovery in this case could cause an infinite loop\n    if (notStuck === false) {\n      return false;\n    }\n\n    // no need to recover, next token is what we expect...\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false;\n    }\n\n    // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n    // and prefer some backtracking path that includes recovered errors.\n    if (this.isBackTracking()) {\n      return false;\n    }\n\n    // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n    //noinspection RedundantIfStatementJS\n    if (\n      this.canPerformInRuleRecovery(\n        expectTokAfterLastMatch,\n        this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx),\n      )\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  // Error Recovery functionality\n  getFollowsForInRuleRecovery(\n    this: MixedInParser,\n    tokType: TokenType,\n    tokIdxInRule: number,\n  ): TokenType[] {\n    const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n    const follows = this.getNextPossibleTokenTypes(grammarPath);\n    return follows;\n  }\n\n  tryInRuleRecovery(\n    this: MixedInParser,\n    expectedTokType: TokenType,\n    follows: TokenType[],\n  ): IToken {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      const tokToInsert = this.getTokenToInsert(expectedTokType);\n      return tokToInsert;\n    }\n\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      const nextTok = this.SKIP_TOKEN();\n      this.consumeToken();\n      return nextTok;\n    }\n\n    throw new InRuleRecoveryException(\"sad sad panda\");\n  }\n\n  canPerformInRuleRecovery(\n    this: MixedInParser,\n    expectedToken: TokenType,\n    follows: TokenType[],\n  ): boolean {\n    return (\n      this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n      this.canRecoverWithSingleTokenDeletion(expectedToken)\n    );\n  }\n\n  canRecoverWithSingleTokenInsertion(\n    this: MixedInParser,\n    expectedTokType: TokenType,\n    follows: TokenType[],\n  ): boolean {\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false;\n    }\n\n    // must know the possible following tokens to perform single token insertion\n    if (isEmpty(follows)) {\n      return false;\n    }\n\n    const mismatchedTok = this.LA(1);\n    const isMisMatchedTokInFollows =\n      find(follows, (possibleFollowsTokType: TokenType) => {\n        return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n      }) !== undefined;\n\n    return isMisMatchedTokInFollows;\n  }\n\n  canRecoverWithSingleTokenDeletion(\n    this: MixedInParser,\n    expectedTokType: TokenType,\n  ): boolean {\n    if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n      return false;\n    }\n\n    const isNextTokenWhatIsExpected = this.tokenMatcher(\n      this.LA(2),\n      expectedTokType,\n    );\n    return isNextTokenWhatIsExpected;\n  }\n\n  isInCurrentRuleReSyncSet(\n    this: MixedInParser,\n    tokenTypeIdx: TokenType,\n  ): boolean {\n    const followKey = this.getCurrFollowKey();\n    const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n    return includes(currentRuleReSyncSet, tokenTypeIdx);\n  }\n\n  findReSyncTokenType(this: MixedInParser): TokenType {\n    const allPossibleReSyncTokTypes = this.flattenFollowSet();\n    // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n    let nextToken = this.LA(1);\n    let k = 2;\n    while (true) {\n      const foundMatch = find(allPossibleReSyncTokTypes, (resyncTokType) => {\n        const canMatch = tokenMatcher(nextToken, resyncTokType);\n        return canMatch;\n      });\n      if (foundMatch !== undefined) {\n        return foundMatch;\n      }\n      nextToken = this.LA(k);\n      k++;\n    }\n  }\n\n  getCurrFollowKey(this: MixedInParser): IFollowKey {\n    // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n    if (this.RULE_STACK.length === 1) {\n      return EOF_FOLLOW_KEY;\n    }\n    const currRuleShortName = this.getLastExplicitRuleShortName();\n    const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n    const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName),\n    };\n  }\n\n  buildFullFollowKeyStack(this: MixedInParser): IFollowKey[] {\n    const explicitRuleStack = this.RULE_STACK;\n    const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n\n    return map(explicitRuleStack, (ruleName, idx) => {\n      if (idx === 0) {\n        return EOF_FOLLOW_KEY;\n      }\n      return {\n        ruleName: this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),\n      };\n    });\n  }\n\n  flattenFollowSet(this: MixedInParser): TokenType[] {\n    const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n      return this.getFollowSetFromFollowKey(currKey);\n    });\n    return <any>flatten(followStack);\n  }\n\n  getFollowSetFromFollowKey(\n    this: MixedInParser,\n    followKey: IFollowKey,\n  ): TokenType[] {\n    if (followKey === EOF_FOLLOW_KEY) {\n      return [EOF];\n    }\n\n    const followName =\n      followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n\n    return this.resyncFollows[followName];\n  }\n\n  // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n  addToResyncTokens(\n    this: MixedInParser,\n    token: IToken,\n    resyncTokens: IToken[],\n  ): IToken[] {\n    if (!this.tokenMatcher(token, EOF)) {\n      resyncTokens.push(token);\n    }\n    return resyncTokens;\n  }\n\n  reSyncTo(this: MixedInParser, tokType: TokenType): IToken[] {\n    const resyncedTokens: IToken[] = [];\n    let nextTok = this.LA(1);\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN();\n      this.addToResyncTokens(nextTok, resyncedTokens);\n    }\n    // the last token is not part of the error.\n    return dropRight(resyncedTokens);\n  }\n\n  attemptInRepetitionRecovery(\n    this: MixedInParser,\n    prodFunc: Function,\n    args: any[],\n    lookaheadFunc: () => boolean,\n    dslMethodIdx: number,\n    prodOccurrence: number,\n    nextToksWalker: typeof AbstractNextTerminalAfterProductionWalker,\n    notStuck?: boolean,\n  ): void {\n    // by default this is a NO-OP\n    // The actual implementation is with the function(not method) below\n  }\n\n  getCurrentGrammarPath(\n    this: MixedInParser,\n    tokType: TokenType,\n    tokIdxInRule: number,\n  ): ITokenGrammarPath {\n    const pathRuleStack: string[] = this.getHumanReadableRuleStack();\n    const pathOccurrenceStack: number[] = clone(this.RULE_OCCURRENCE_STACK);\n    const grammarPath: any = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule,\n    };\n\n    return grammarPath;\n  }\n  getHumanReadableRuleStack(this: MixedInParser): string[] {\n    return map(this.RULE_STACK, (currShortName) =>\n      this.shortRuleNameToFullName(currShortName),\n    );\n  }\n}\n\nexport function attemptInRepetitionRecovery(\n  this: MixedInParser,\n  prodFunc: Function,\n  args: any[],\n  lookaheadFunc: () => boolean,\n  dslMethodIdx: number,\n  prodOccurrence: number,\n  nextToksWalker: typeof AbstractNextTerminalAfterProductionWalker,\n  notStuck?: boolean,\n): void {\n  const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n  let firstAfterRepInfo = this.firstAfterRepMap[key];\n  if (firstAfterRepInfo === undefined) {\n    const currRuleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[currRuleName];\n    const walker: AbstractNextTerminalAfterProductionWalker =\n      new nextToksWalker(ruleGrammar, prodOccurrence);\n    firstAfterRepInfo = walker.startWalking();\n    this.firstAfterRepMap[key] = firstAfterRepInfo;\n  }\n\n  let expectTokAfterLastMatch = firstAfterRepInfo.token;\n  let nextTokIdx = firstAfterRepInfo.occurrence;\n  const isEndOfRule = firstAfterRepInfo.isEndOfRule;\n\n  // special edge case of a TOP most repetition after which the input should END.\n  // this will force an attempt for inRule recovery in that scenario.\n  if (\n    this.RULE_STACK.length === 1 &&\n    isEndOfRule &&\n    expectTokAfterLastMatch === undefined\n  ) {\n    expectTokAfterLastMatch = EOF;\n    nextTokIdx = 1;\n  }\n\n  // We don't have anything to re-sync to...\n  // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n  if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n    return;\n  }\n\n  if (\n    this.shouldInRepetitionRecoveryBeTried(\n      expectTokAfterLastMatch,\n      nextTokIdx,\n      notStuck,\n    )\n  ) {\n    // TODO: performance optimization: instead of passing the original args here, we modify\n    // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n    // to avoid searching the cache for it once more.\n    this.tryInRepetitionRecovery(\n      prodFunc,\n      args,\n      lookaheadFunc,\n      expectTokAfterLastMatch,\n    );\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4333, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4339, "column": 0}, "map": {"version":3,"file":"keys.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/grammar/keys.ts"],"sourcesContent":["// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\n\nexport const BITS_FOR_METHOD_TYPE = 4;\nexport const BITS_FOR_OCCURRENCE_IDX = 8;\nexport const BITS_FOR_RULE_IDX = 12;\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexport const BITS_FOR_ALT_IDX = 8;\n\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\nexport const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nexport const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nexport const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nexport const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nexport const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nexport const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n\n// this actually returns a number, but it is always used as a string (object prop key)\nexport function getKeyForAutomaticLookahead(\n  ruleIdx: number,\n  dslMethodIdx: number,\n  occurrence: number,\n): number {\n  return occurrence | dslMethodIdx | ruleIdx;\n}\n\nconst BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\n"],"names":[],"mappings":"AAAA,gDAAgD;AAChD,sCAAsC;AACtC,mCAAmC;AACnC,kCAAkC;AAClC,8CAA8C;AAC9C,oDAAoD;;;;;;;;;;;;;;AAE7C,MAAM,oBAAoB,GAAG,CAAC,CAAC;AAC/B,MAAM,uBAAuB,GAAG,CAAC,CAAC;AAClC,MAAM,iBAAiB,GAAG,EAAE,CAAC;AAE7B,MAAM,gBAAgB,GAAG,CAAC,CAAC;AAK3B,MAAM,MAAM,GAAG,CAAC,IAAI,uBAAuB,CAAC;AAC5C,MAAM,UAAU,GAAG,CAAC,IAAI,uBAAuB,CAAC;AAChD,MAAM,QAAQ,GAAG,CAAC,IAAI,uBAAuB,CAAC;AAC9C,MAAM,gBAAgB,GAAG,CAAC,IAAI,uBAAuB,CAAC;AACtD,MAAM,YAAY,GAAG,CAAC,IAAI,uBAAuB,CAAC;AAClD,MAAM,oBAAoB,GAAG,CAAC,IAAI,uBAAuB,CAAC;AAG3D,SAAU,2BAA2B,CACzC,OAAe,EACf,YAAoB,EACpB,UAAkB;IAElB,OAAO,UAAU,GAAG,YAAY,GAAG,OAAO,CAAC;AAC7C,CAAC;AAED,MAAM,sBAAsB,GAAG,EAAE,GAAG,gBAAgB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4372, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4378, "column": 0}, "map": {"version":3,"file":"llk_lookahead.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/grammar/llk_lookahead.ts"],"sourcesContent":["import {\n  ILookaheadStrategy,\n  ILookaheadValidationError,\n  IOrAlt,\n  OptionalProductionType,\n  Rule,\n  TokenType,\n} from \"@chevrotain/types\";\nimport { flatMap, isEmpty } from \"lodash-es\";\nimport { defaultGrammarValidatorErrorProvider } from \"../errors_public.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser/parser.js\";\nimport {\n  validateAmbiguousAlternationAlternatives,\n  validateEmptyOrAlternative,\n  validateNoLeftRecursion,\n  validateSomeNonEmptyLookaheadPath,\n} from \"./checks.js\";\nimport {\n  buildAlternativesLookAheadFunc,\n  buildLookaheadFuncForOptionalProd,\n  buildLookaheadFuncForOr,\n  buildSingleAlternativeLookaheadFunction,\n  getProdType,\n} from \"./lookahead.js\";\nimport { IParserDefinitionError } from \"./types.js\";\n\nexport class LLkLookaheadStrategy implements ILookaheadStrategy {\n  readonly maxLookahead: number;\n\n  constructor(options?: { maxLookahead?: number }) {\n    this.maxLookahead =\n      options?.maxLookahead ?? DEFAULT_PARSER_CONFIG.maxLookahead;\n  }\n\n  validate(options: {\n    rules: Rule[];\n    tokenTypes: TokenType[];\n    grammarName: string;\n  }): ILookaheadValidationError[] {\n    const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n\n    if (isEmpty(leftRecursionErrors)) {\n      const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n      const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(\n        options.rules,\n        this.maxLookahead,\n      );\n      const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(\n        options.rules,\n        this.maxLookahead,\n      );\n      const allErrors = [\n        ...leftRecursionErrors,\n        ...emptyAltErrors,\n        ...ambiguousAltsErrors,\n        ...emptyRepetitionErrors,\n      ];\n      return allErrors;\n    }\n    return leftRecursionErrors;\n  }\n\n  validateNoLeftRecursion(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateNoLeftRecursion(\n        currTopRule,\n        currTopRule,\n        defaultGrammarValidatorErrorProvider,\n      ),\n    );\n  }\n\n  validateEmptyOrAlternatives(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateEmptyOrAlternative(\n        currTopRule,\n        defaultGrammarValidatorErrorProvider,\n      ),\n    );\n  }\n\n  validateAmbiguousAlternationAlternatives(\n    rules: Rule[],\n    maxLookahead: number,\n  ): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateAmbiguousAlternationAlternatives(\n        currTopRule,\n        maxLookahead,\n        defaultGrammarValidatorErrorProvider,\n      ),\n    );\n  }\n\n  validateSomeNonEmptyLookaheadPath(\n    rules: Rule[],\n    maxLookahead: number,\n  ): IParserDefinitionError[] {\n    return validateSomeNonEmptyLookaheadPath(\n      rules,\n      maxLookahead,\n      defaultGrammarValidatorErrorProvider,\n    );\n  }\n\n  buildLookaheadForAlternation(options: {\n    prodOccurrence: number;\n    rule: Rule;\n    maxLookahead: number;\n    hasPredicates: boolean;\n    dynamicTokensEnabled: boolean;\n  }): (orAlts?: IOrAlt<any>[] | undefined) => number | undefined {\n    return buildLookaheadFuncForOr(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.hasPredicates,\n      options.dynamicTokensEnabled,\n      buildAlternativesLookAheadFunc,\n    );\n  }\n\n  buildLookaheadForOptional(options: {\n    prodOccurrence: number;\n    prodType: OptionalProductionType;\n    rule: Rule;\n    maxLookahead: number;\n    dynamicTokensEnabled: boolean;\n  }): () => boolean {\n    return buildLookaheadFuncForOptionalProd(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.dynamicTokensEnabled,\n      getProdType(options.prodType),\n      buildSingleAlternativeLookaheadFunction,\n    );\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4432, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4438, "column": 0}, "map": {"version":3,"file":"looksahead.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/parser/traits/looksahead.ts"],"sourcesContent":["import { forEach, has } from \"lodash-es\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\nimport {\n  ILookaheadStrategy,\n  IParserConfig,\n  OptionalProductionType,\n} from \"@chevrotain/types\";\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  getKeyForAutomaticLookahead,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX,\n} from \"../../grammar/keys.js\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport {\n  Alternation,\n  GAstVisitor,\n  getProductionDslName,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n} from \"@chevrotain/gast\";\nimport { LLkLookaheadStrategy } from \"../../grammar/llk_lookahead.js\";\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n  maxLookahead: number;\n  lookAheadFuncsCache: any;\n  dynamicTokensEnabled: boolean;\n  lookaheadStrategy: ILookaheadStrategy;\n\n  initLooksAhead(config: IParserConfig) {\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n      ? (config.dynamicTokensEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n\n    this.maxLookahead = has(config, \"maxLookahead\")\n      ? (config.maxLookahead as number) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.maxLookahead;\n\n    this.lookaheadStrategy = has(config, \"lookaheadStrategy\")\n      ? (config.lookaheadStrategy as ILookaheadStrategy) // assumes end user provides the correct config value/type\n      : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });\n\n    this.lookAheadFuncsCache = new Map();\n  }\n\n  preComputeLookaheadFunctions(this: MixedInParser, rules: Rule[]): void {\n    forEach(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const {\n          alternation,\n          repetition,\n          option,\n          repetitionMandatory,\n          repetitionMandatoryWithSeparator,\n          repetitionWithSeparator,\n        } = collectMethods(currRule);\n\n        forEach(alternation, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n              prodOccurrence: currProd.idx,\n              rule: currRule,\n              maxLookahead: currProd.maxLookahead || this.maxLookahead,\n              hasPredicates: currProd.hasPredicates,\n              dynamicTokensEnabled: this.dynamicTokensEnabled,\n            });\n\n            const key = getKeyForAutomaticLookahead(\n              this.fullRuleNameToShort[currRule.name],\n              OR_IDX,\n              currProd.idx,\n            );\n            this.setLaFuncCache(key, laFunc);\n          });\n        });\n\n        forEach(repetition, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_IDX,\n            \"Repetition\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd),\n          );\n        });\n\n        forEach(option, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            OPTION_IDX,\n            \"Option\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd),\n          );\n        });\n\n        forEach(repetitionMandatory, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_IDX,\n            \"RepetitionMandatory\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd),\n          );\n        });\n\n        forEach(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_SEP_IDX,\n            \"RepetitionMandatoryWithSeparator\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd),\n          );\n        });\n\n        forEach(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_SEP_IDX,\n            \"RepetitionWithSeparator\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd),\n          );\n        });\n      });\n    });\n  }\n\n  computeLookaheadFunc(\n    this: MixedInParser,\n    rule: Rule,\n    prodOccurrence: number,\n    prodKey: number,\n    prodType: OptionalProductionType,\n    prodMaxLookahead: number | undefined,\n    dslMethodName: string,\n  ): void {\n    this.TRACE_INIT(\n      `${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`,\n      () => {\n        const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n          prodOccurrence,\n          rule,\n          maxLookahead: prodMaxLookahead || this.maxLookahead,\n          dynamicTokensEnabled: this.dynamicTokensEnabled,\n          prodType,\n        });\n        const key = getKeyForAutomaticLookahead(\n          this.fullRuleNameToShort[rule.name],\n          prodKey,\n          prodOccurrence,\n        );\n        this.setLaFuncCache(key, laFunc);\n      },\n    );\n  }\n\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(\n    this: MixedInParser,\n    dslMethodIdx: number,\n    occurrence: number,\n  ): number {\n    const currRuleShortName: any = this.getLastExplicitRuleShortName();\n    return getKeyForAutomaticLookahead(\n      currRuleShortName,\n      dslMethodIdx,\n      occurrence,\n    );\n  }\n\n  getLaFuncFromCache(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache.get(key);\n  }\n\n  /* istanbul ignore next */\n  setLaFuncCache(this: MixedInParser, key: number, value: Function): void {\n    this.lookAheadFuncsCache.set(key, value);\n  }\n}\n\nclass DslMethodsCollectorVisitor extends GAstVisitor {\n  public dslMethods: {\n    option: Option[];\n    alternation: Alternation[];\n    repetition: Repetition[];\n    repetitionWithSeparator: RepetitionWithSeparator[];\n    repetitionMandatory: RepetitionMandatory[];\n    repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[];\n  } = {\n    option: [],\n    alternation: [],\n    repetition: [],\n    repetitionWithSeparator: [],\n    repetitionMandatory: [],\n    repetitionMandatoryWithSeparator: [],\n  };\n\n  reset() {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: [],\n    };\n  }\n\n  public visitOption(option: Option): void {\n    this.dslMethods.option.push(option);\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.dslMethods.repetitionWithSeparator.push(manySep);\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.dslMethods.repetitionMandatory.push(atLeastOne);\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator,\n  ): void {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.dslMethods.repetition.push(many);\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.dslMethods.alternation.push(or);\n  }\n}\n\nconst collectorVisitor = new DslMethodsCollectorVisitor();\nexport function collectMethods(rule: Rule): {\n  option: Option[];\n  alternation: Alternation[];\n  repetition: Repetition[];\n  repetitionWithSeparator: RepetitionWithSeparator[];\n  repetitionMandatory: RepetitionMandatory[];\n  repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[];\n} {\n  collectorVisitor.reset();\n  rule.accept(collectorVisitor);\n  const dslMethods = collectorVisitor.dslMethods;\n  // avoid uncleaned references\n  collectorVisitor.reset();\n  return <any>dslMethods;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4578, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4584, "column": 0}, "map": {"version":3,"file":"cst.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/cst/cst.ts"],"sourcesContent":["import { CstNode, CstNodeLocation, IToken } from \"@chevrotain/types\";\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(\n  currNodeLocation: CstNodeLocation,\n  newLocationInfo: Required<Pick<IToken, \"startOffset\" | \"endOffset\">>,\n): void {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (both start/end offsets exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n  // Once the startOffset has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset! < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n}\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(\n  currNodeLocation: CstNodeLocation,\n  newLocationInfo: CstNodeLocation,\n): void {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (all start/end props exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.startColumn = newLocationInfo.startColumn;\n    currNodeLocation.startLine = newLocationInfo.startLine;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n  // Once the start props has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset! < newLocationInfo.endOffset! === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n}\n\nexport function addTerminalToCst(\n  node: CstNode,\n  token: IToken,\n  tokenTypeName: string,\n): void {\n  if (node.children[tokenTypeName] === undefined) {\n    node.children[tokenTypeName] = [token];\n  } else {\n    node.children[tokenTypeName].push(token);\n  }\n}\n\nexport function addNoneTerminalToCst(\n  node: CstNode,\n  ruleName: string,\n  ruleResult: any,\n): void {\n  if (node.children[ruleName] === undefined) {\n    node.children[ruleName] = [ruleResult];\n  } else {\n    node.children[ruleName].push(ruleResult);\n  }\n}\n"],"names":[],"mappings":"AAEA;;;;;;GAMG;;;;;;AACG,SAAU,yBAAyB,CACvC,gBAAiC,EACjC,eAAoE;IAEpE,yCAAyC;IACzC,IAAI,KAAK,CAAC,gBAAgB,CAAC,WAAW,CAAC,KAAK,IAAI,EAAE;QAChD,0EAA0E;QAC1E,qEAAqE;QACrE,kDAAkD;QAClD,gBAAgB,CAAC,WAAW,GAAG,eAAe,CAAC,WAAW,CAAC;QAC3D,gBAAgB,CAAC,SAAS,GAAG,eAAe,CAAC,SAAS,CAAC;KACxD,MAKI,IAAI,gBAAgB,CAAC,SAAU,GAAG,eAAe,CAAC,SAAS,KAAK,IAAI,EAAE;QACzE,gBAAgB,CAAC,SAAS,GAAG,eAAe,CAAC,SAAS,CAAC;KACxD;AACH,CAAC;AASK,SAAU,mBAAmB,CACjC,gBAAiC,EACjC,eAAgC;IAEhC,yCAAyC;IACzC,IAAI,KAAK,CAAC,gBAAgB,CAAC,WAAW,CAAC,KAAK,IAAI,EAAE;QAChD,0EAA0E;QAC1E,qEAAqE;QACrE,+CAA+C;QAC/C,gBAAgB,CAAC,WAAW,GAAG,eAAe,CAAC,WAAW,CAAC;QAC3D,gBAAgB,CAAC,WAAW,GAAG,eAAe,CAAC,WAAW,CAAC;QAC3D,gBAAgB,CAAC,SAAS,GAAG,eAAe,CAAC,SAAS,CAAC;QACvD,gBAAgB,CAAC,SAAS,GAAG,eAAe,CAAC,SAAS,CAAC;QACvD,gBAAgB,CAAC,SAAS,GAAG,eAAe,CAAC,SAAS,CAAC;QACvD,gBAAgB,CAAC,OAAO,GAAG,eAAe,CAAC,OAAO,CAAC;KACpD,MAKI,IAAI,gBAAgB,CAAC,SAAU,GAAG,eAAe,CAAC,SAAU,KAAK,IAAI,EAAE;QAC1E,gBAAgB,CAAC,SAAS,GAAG,eAAe,CAAC,SAAS,CAAC;QACvD,gBAAgB,CAAC,SAAS,GAAG,eAAe,CAAC,SAAS,CAAC;QACvD,gBAAgB,CAAC,OAAO,GAAG,eAAe,CAAC,OAAO,CAAC;KACpD;AACH,CAAC;AAEK,SAAU,gBAAgB,CAC9B,IAAa,EACb,KAAa,EACb,aAAqB;IAErB,IAAI,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK,SAAS,EAAE;QAC9C,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,GAAG;YAAC,KAAK;SAAC,CAAC;KACxC,MAAM;QACL,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAC1C;AACH,CAAC;AAEK,SAAU,oBAAoB,CAClC,IAAa,EACb,QAAgB,EAChB,UAAe;IAEf,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;QACzC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG;YAAC,UAAU;SAAC,CAAC;KACxC,MAAM;QACL,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;KAC1C;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4644, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4650, "column": 0}, "map": {"version":3,"file":"lang_extensions.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/lang/lang_extensions.ts"],"sourcesContent":["const NAME = \"name\";\n\nexport function defineNameProp(obj: {}, nameValue: string): void {\n  Object.defineProperty(obj, NAME, {\n    enumerable: false,\n    configurable: true,\n    writable: false,\n    value: nameValue,\n  });\n}\n"],"names":[],"mappings":";;;AAAA,MAAM,IAAI,GAAG,MAAM,CAAC;AAEd,SAAU,cAAc,CAAC,GAAO,EAAE,SAAiB;IACvD,MAAM,CAAC,cAAc,CAAC,GAAG,EAAE,IAAI,EAAE;QAC/B,UAAU,EAAE,KAAK;QACjB,YAAY,EAAE,IAAI;QAClB,QAAQ,EAAE,KAAK;QACf,KAAK,EAAE,SAAS;KACjB,CAAC,CAAC;AACL,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4662, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4668, "column": 0}, "map": {"version":3,"file":"cst_visitor.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/cst/cst_visitor.ts"],"sourcesContent":["import {\n  compact,\n  filter,\n  forEach,\n  isArray,\n  isEmpty,\n  isFunction,\n  isUndefined,\n  keys,\n  map,\n} from \"lodash-es\";\nimport { defineNameProp } from \"../../lang/lang_extensions.js\";\nimport { CstNode, ICstVisitor } from \"@chevrotain/types\";\n\nexport function defaultVisit<IN>(ctx: any, param: IN): void {\n  const childrenNames = keys(ctx);\n  const childrenNamesLength = childrenNames.length;\n  for (let i = 0; i < childrenNamesLength; i++) {\n    const currChildName = childrenNames[i];\n    const currChildArray = ctx[currChildName];\n    const currChildArrayLength = currChildArray.length;\n    for (let j = 0; j < currChildArrayLength; j++) {\n      const currChild: any = currChildArray[j];\n      // distinction between Tokens Children and CstNode children\n      if (currChild.tokenTypeIdx === undefined) {\n        this[currChild.name](currChild.children, param);\n      }\n    }\n  }\n  // defaultVisit does not support generic out param\n}\n\nexport function createBaseSemanticVisitorConstructor(\n  grammarName: string,\n  ruleNames: string[],\n): {\n  new (...args: any[]): ICstVisitor<any, any>;\n} {\n  const derivedConstructor: any = function () {};\n\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n\n  const semanticProto = {\n    visit: function (cstNode: CstNode | CstNode[], param: any) {\n      // enables writing more concise visitor methods when CstNode has only a single child\n      if (isArray(cstNode)) {\n        // A CST Node's children dictionary can never have empty arrays as values\n        // If a key is defined there will be at least one element in the corresponding value array.\n        cstNode = cstNode[0];\n      }\n\n      // enables passing optional CstNodes concisely.\n      if (isUndefined(cstNode)) {\n        return undefined;\n      }\n\n      return this[cstNode.name](cstNode.children, param);\n    },\n\n    validateVisitor: function () {\n      const semanticDefinitionErrors = validateVisitor(this, ruleNames);\n      if (!isEmpty(semanticDefinitionErrors)) {\n        const errorMessages = map(\n          semanticDefinitionErrors,\n          (currDefError) => currDefError.msg,\n        );\n        throw Error(\n          `Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n            `${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")}`,\n        );\n      }\n    },\n  };\n\n  derivedConstructor.prototype = semanticProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n\n  derivedConstructor._RULE_NAMES = ruleNames;\n\n  return derivedConstructor;\n}\n\nexport function createBaseVisitorConstructorWithDefaults(\n  grammarName: string,\n  ruleNames: string[],\n  baseConstructor: Function,\n): {\n  new (...args: any[]): ICstVisitor<any, any>;\n} {\n  const derivedConstructor: any = function () {};\n\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n\n  const withDefaultsProto = Object.create(baseConstructor.prototype);\n  forEach(ruleNames, (ruleName) => {\n    withDefaultsProto[ruleName] = defaultVisit;\n  });\n\n  derivedConstructor.prototype = withDefaultsProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n\n  return derivedConstructor;\n}\n\nexport enum CstVisitorDefinitionError {\n  REDUNDANT_METHOD,\n  MISSING_METHOD,\n}\n\nexport interface IVisitorDefinitionError {\n  msg: string;\n  type: CstVisitorDefinitionError;\n  methodName: string;\n}\n\nexport function validateVisitor(\n  visitorInstance: ICstVisitor<unknown, unknown>,\n  ruleNames: string[],\n): IVisitorDefinitionError[] {\n  const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n\n  return missingErrors;\n}\n\nexport function validateMissingCstMethods(\n  visitorInstance: ICstVisitor<unknown, unknown>,\n  ruleNames: string[],\n): IVisitorDefinitionError[] {\n  const missingRuleNames = filter(ruleNames, (currRuleName) => {\n    return isFunction((visitorInstance as any)[currRuleName]) === false;\n  });\n\n  const errors: IVisitorDefinitionError[] = map(\n    missingRuleNames,\n    (currRuleName) => {\n      return {\n        msg: `Missing visitor method: <${currRuleName}> on ${<any>(\n          visitorInstance.constructor.name\n        )} CST Visitor.`,\n        type: CstVisitorDefinitionError.MISSING_METHOD,\n        methodName: currRuleName,\n      };\n    },\n  );\n\n  return compact<IVisitorDefinitionError>(errors);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4774, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4780, "column": 0}, "map": {"version":3,"file":"tree_builder.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/parser/traits/tree_builder.ts"],"sourcesContent":["import {\n  addNoneTerminalToCst,\n  addTerminalToCst,\n  setNodeLocationFull,\n  setNodeLocationOnlyOffset,\n} from \"../../cst/cst.js\";\nimport { has, isUndefined, keys, noop } from \"lodash-es\";\nimport {\n  createBaseSemanticVisitorConstructor,\n  createBaseVisitorConstructorWithDefaults,\n} from \"../../cst/cst_visitor.js\";\nimport {\n  CstNode,\n  CstNodeLocation,\n  ICstVisitor,\n  IParserConfig,\n  IToken,\n  nodeLocationTrackingOptions,\n} from \"@chevrotain/types\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n\n/**\n * This trait is responsible for the CST building logic.\n */\nexport class TreeBuilder {\n  outputCst: boolean;\n  CST_STACK: CstNode[];\n  baseCstVisitorConstructor: Function;\n  baseCstVisitorWithDefaultsConstructor: Function;\n\n  // dynamically assigned Methods\n  setNodeLocationFromNode: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation,\n  ) => void;\n  setNodeLocationFromToken: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation,\n  ) => void;\n  cstPostRule: (this: MixedInParser, ruleCstNode: CstNode) => void;\n\n  setInitialNodeLocation: (cstNode: CstNode) => void;\n  nodeLocationTracking: nodeLocationTrackingOptions;\n\n  initTreeBuilder(this: MixedInParser, config: IParserConfig) {\n    this.CST_STACK = [];\n\n    // outputCst is no longer exposed/defined in the pubic API\n    this.outputCst = (config as any).outputCst;\n\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n      ? (config.nodeLocationTracking as nodeLocationTrackingOptions) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = noop;\n      this.cstFinallyStateUpdate = noop;\n      this.cstPostTerminal = noop;\n      this.cstPostNonTerminal = noop;\n      this.cstPostRule = noop;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull;\n          this.setNodeLocationFromNode = setNodeLocationFull;\n          this.cstPostRule = noop;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop;\n          this.setNodeLocationFromNode = noop;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = <any>setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = <any>setNodeLocationOnlyOffset;\n          this.cstPostRule = noop;\n          this.setInitialNodeLocation =\n            this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop;\n          this.setNodeLocationFromNode = noop;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation =\n            this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = noop;\n        this.setNodeLocationFromNode = noop;\n        this.cstPostRule = noop;\n        this.setInitialNodeLocation = noop;\n      } else {\n        throw Error(\n          `Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`,\n        );\n      }\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRecovery(\n    this: MixedInParser,\n    cstNode: any,\n  ): void {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN,\n    };\n  }\n\n  setInitialNodeLocationOnlyOffsetRegular(\n    this: MixedInParser,\n    cstNode: any,\n  ): void {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN,\n    };\n  }\n\n  setInitialNodeLocationFullRecovery(this: MixedInParser, cstNode: any): void {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN,\n    };\n  }\n\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n\n     * @param cstNode\n     */\n  setInitialNodeLocationFullRegular(this: MixedInParser, cstNode: any): void {\n    const nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN,\n    };\n  }\n\n  cstInvocationStateUpdate(this: MixedInParser, fullRuleName: string): void {\n    const cstNode: CstNode = {\n      name: fullRuleName,\n      children: Object.create(null),\n    };\n\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  }\n\n  cstFinallyStateUpdate(this: MixedInParser): void {\n    this.CST_STACK.pop();\n  }\n\n  cstPostRuleFull(this: MixedInParser, ruleCstNode: CstNode): void {\n    // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n    const prevToken = this.LA(0) as Required<CstNodeLocation>;\n    const loc = ruleCstNode.location as Required<CstNodeLocation>;\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  }\n\n  cstPostRuleOnlyOffset(this: MixedInParser, ruleCstNode: CstNode): void {\n    const prevToken = this.LA(0);\n    // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n    const loc = ruleCstNode.location!;\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n    }\n  }\n\n  cstPostTerminal(\n    this: MixedInParser,\n    key: string,\n    consumedToken: IToken,\n  ): void {\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    addTerminalToCst(rootCst, consumedToken, key);\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromToken(rootCst.location!, <any>consumedToken);\n  }\n\n  cstPostNonTerminal(\n    this: MixedInParser,\n    ruleCstResult: CstNode,\n    ruleName: string,\n  ): void {\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromNode(preCstNode.location!, ruleCstResult.location!);\n  }\n\n  getBaseCstVisitorConstructor<IN = any, OUT = any>(\n    this: MixedInParser,\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>;\n  } {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(\n        this.className,\n        keys(this.gastProductionsCache),\n      );\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n\n    return <any>this.baseCstVisitorConstructor;\n  }\n\n  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(\n    this: MixedInParser,\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>;\n  } {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      const newConstructor = createBaseVisitorConstructorWithDefaults(\n        this.className,\n        keys(this.gastProductionsCache),\n        this.getBaseCstVisitorConstructor(),\n      );\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n\n    return <any>this.baseCstVisitorWithDefaultsConstructor;\n  }\n\n  getLastExplicitRuleShortName(this: MixedInParser): number {\n    const ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  }\n\n  getPreviousExplicitRuleShortName(this: MixedInParser): number {\n    const ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  }\n\n  getLastExplicitRuleOccurrenceIndex(this: MixedInParser): number {\n    const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4963, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4969, "column": 0}, "map": {"version":3,"file":"lexer_adapter.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/parser/traits/lexer_adapter.ts"],"sourcesContent":["import { END_OF_FILE } from \"../parser.js\";\nimport { IToken } from \"@chevrotain/types\";\nimport { MixedInParser } from \"./parser_traits.js\";\n\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nexport class LexerAdapter {\n  tokVector: IToken[];\n  tokVectorLength: number;\n  currIdx: number;\n\n  initLexerAdapter() {\n    this.tokVector = [];\n    this.tokVectorLength = 0;\n    this.currIdx = -1;\n  }\n\n  set input(newInput: IToken[]) {\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    if (this.selfAnalysisDone !== true) {\n      throw Error(\n        `Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`,\n      );\n    }\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    this.reset();\n    this.tokVector = newInput;\n    this.tokVectorLength = newInput.length;\n  }\n\n  get input(): IToken[] {\n    return this.tokVector;\n  }\n\n  // skips a token and returns the next token\n  SKIP_TOKEN(this: MixedInParser): IToken {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken();\n      return this.LA(1);\n    } else {\n      return END_OF_FILE;\n    }\n  }\n\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n  LA(this: MixedInParser, howMuch: number): IToken {\n    const soughtIdx = this.currIdx + howMuch;\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return END_OF_FILE;\n    } else {\n      return this.tokVector[soughtIdx];\n    }\n  }\n\n  consumeToken(this: MixedInParser) {\n    this.currIdx++;\n  }\n\n  exportLexerState(this: MixedInParser): number {\n    return this.currIdx;\n  }\n\n  importLexerState(this: MixedInParser, newState: number) {\n    this.currIdx = newState;\n  }\n\n  resetLexerState(this: MixedInParser): void {\n    this.currIdx = -1;\n  }\n\n  moveToTerminatedState(this: MixedInParser): void {\n    this.currIdx = this.tokVector.length - 1;\n  }\n\n  getLexerPosition(this: MixedInParser): number {\n    return this.exportLexerState();\n  }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,cAAc,CAAC;;AAWrC,MAAO,YAAY;IAKvB,gBAAgB,GAAA;QACd,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC;QACzB,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;IACpB,CAAC;IAED,IAAI,KAAK,CAAC,QAAkB,EAAA;QAC1B,iEAAiE;QACjE,kFAAkF;QAClF,IAAI,IAAI,CAAC,gBAAgB,KAAK,IAAI,EAAE;YAClC,MAAM,KAAK,CACT,CAAA,gFAAA,CAAkF,CACnF,CAAC;SACH;QACD,iEAAiE;QACjE,kFAAkF;QAClF,IAAI,CAAC,KAAK,EAAE,CAAC;QACb,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAC1B,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC,MAAM,CAAC;IACzC,CAAC;IAED,IAAI,KAAK,GAAA;QACP,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAED,2CAA2C;IAC3C,UAAU,GAAA;QACR,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;YAC7C,IAAI,CAAC,YAAY,EAAE,CAAC;YACpB,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;SACnB,MAAM;YACL,wMAAO,cAAW,CAAC;SACpB;IACH,CAAC;IAED,kGAAkG;IAClG,yCAAyC;IACzC,EAAE,CAAsB,OAAe,EAAA;QACrC,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACzC,IAAI,SAAS,GAAG,CAAC,IAAI,IAAI,CAAC,eAAe,IAAI,SAAS,EAAE;YACtD,wMAAO,cAAW,CAAC;SACpB,MAAM;YACL,OAAO,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;SAClC;IACH,CAAC;IAED,YAAY,GAAA;QACV,IAAI,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;IAED,gBAAgB,GAAA;QACd,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAED,gBAAgB,CAAsB,QAAgB,EAAA;QACpD,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC;IAC1B,CAAC;IAED,eAAe,GAAA;QACb,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;IACpB,CAAC;IAED,qBAAqB,GAAA;QACnB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC;IAC3C,CAAC;IAED,gBAAgB,GAAA;QACd,OAAO,IAAI,CAAC,gBAAgB,EAAE,CAAC;IACjC,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 5033, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5039, "column": 0}, "map": {"version":3,"file":"recognizer_api.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/parser/traits/recognizer_api.ts"],"sourcesContent":["import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IRuleConfig,\n  ISerializedGast,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType,\n} from \"@chevrotain/types\";\nimport { includes, values } from \"lodash-es\";\nimport { isRecognitionException } from \"../../exceptions_public.js\";\nimport { DEFAULT_RULE_CONFIG, ParserDefinitionErrorType } from \"../parser.js\";\nimport { defaultGrammarValidatorErrorProvider } from \"../../errors_public.js\";\nimport { validateRuleIsOverridden } from \"../../grammar/checks.js\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport { Rule, serializeGrammar } from \"@chevrotain/gast\";\nimport { IParserDefinitionError } from \"../../grammar/types.js\";\nimport { ParserMethodInternal } from \"../types.js\";\n\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nexport class RecognizerApi {\n  ACTION<T>(this: MixedInParser, impl: () => T): T {\n    return impl.call(this);\n  }\n\n  consume(\n    this: MixedInParser,\n    idx: number,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, idx, options);\n  }\n\n  subrule<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    idx: number,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, idx, options);\n  }\n\n  option<OUT>(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, idx);\n  }\n\n  or(\n    this: MixedInParser,\n    idx: number,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>,\n  ): any {\n    return this.orInternal(altsOrOpts, idx);\n  }\n\n  many(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\n  ): void {\n    return this.manyInternal(idx, actionORMethodDef);\n  }\n\n  atLeastOne(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\n  ): void {\n    return this.atLeastOneInternal(idx, actionORMethodDef);\n  }\n\n  CONSUME(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 0, options);\n  }\n\n  CONSUME1(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 1, options);\n  }\n\n  CONSUME2(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 2, options);\n  }\n\n  CONSUME3(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 3, options);\n  }\n\n  CONSUME4(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 4, options);\n  }\n\n  CONSUME5(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 5, options);\n  }\n\n  CONSUME6(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 6, options);\n  }\n\n  CONSUME7(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 7, options);\n  }\n\n  CONSUME8(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 8, options);\n  }\n\n  CONSUME9(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    return this.consumeInternal(tokType, 9, options);\n  }\n\n  SUBRULE<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 0, options);\n  }\n\n  SUBRULE1<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 1, options);\n  }\n\n  SUBRULE2<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 2, options);\n  }\n\n  SUBRULE3<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 3, options);\n  }\n\n  SUBRULE4<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 4, options);\n  }\n\n  SUBRULE5<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 5, options);\n  }\n\n  SUBRULE6<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 6, options);\n  }\n\n  SUBRULE7<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 7, options);\n  }\n\n  SUBRULE8<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 8, options);\n  }\n\n  SUBRULE9<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    return this.subruleInternal(ruleToCall, 9, options);\n  }\n\n  OPTION<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 0);\n  }\n\n  OPTION1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 1);\n  }\n\n  OPTION2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 2);\n  }\n\n  OPTION3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 3);\n  }\n\n  OPTION4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 4);\n  }\n\n  OPTION5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 5);\n  }\n\n  OPTION6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 6);\n  }\n\n  OPTION7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 7);\n  }\n\n  OPTION8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 8);\n  }\n\n  OPTION9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 9);\n  }\n\n  OR<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 0);\n  }\n\n  OR1<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 1);\n  }\n\n  OR2<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 2);\n  }\n\n  OR3<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 3);\n  }\n\n  OR4<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 4);\n  }\n\n  OR5<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 5);\n  }\n\n  OR6<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 6);\n  }\n\n  OR7<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 7);\n  }\n\n  OR8<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 8);\n  }\n\n  OR9<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n  ): T {\n    return this.orInternal(altsOrOpts, 9);\n  }\n\n  MANY<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(0, actionORMethodDef);\n  }\n\n  MANY1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(1, actionORMethodDef);\n  }\n\n  MANY2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(2, actionORMethodDef);\n  }\n\n  MANY3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(3, actionORMethodDef);\n  }\n\n  MANY4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(4, actionORMethodDef);\n  }\n\n  MANY5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(5, actionORMethodDef);\n  }\n\n  MANY6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(6, actionORMethodDef);\n  }\n\n  MANY7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(7, actionORMethodDef);\n  }\n\n  MANY8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(8, actionORMethodDef);\n  }\n\n  MANY9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    this.manyInternal(9, actionORMethodDef);\n  }\n\n  MANY_SEP<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(0, options);\n  }\n\n  MANY_SEP1<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(1, options);\n  }\n\n  MANY_SEP2<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(2, options);\n  }\n\n  MANY_SEP3<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(3, options);\n  }\n\n  MANY_SEP4<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(4, options);\n  }\n\n  MANY_SEP5<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(5, options);\n  }\n\n  MANY_SEP6<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(6, options);\n  }\n\n  MANY_SEP7<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(7, options);\n  }\n\n  MANY_SEP8<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(8, options);\n  }\n\n  MANY_SEP9<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(9, options);\n  }\n\n  AT_LEAST_ONE<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(0, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    return this.atLeastOneInternal(1, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(2, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(3, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(4, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(5, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(6, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(7, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(8, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    this.atLeastOneInternal(9, actionORMethodDef);\n  }\n\n  AT_LEAST_ONE_SEP<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(0, options);\n  }\n\n  AT_LEAST_ONE_SEP1<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(1, options);\n  }\n\n  AT_LEAST_ONE_SEP2<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(2, options);\n  }\n\n  AT_LEAST_ONE_SEP3<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(3, options);\n  }\n\n  AT_LEAST_ONE_SEP4<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(4, options);\n  }\n\n  AT_LEAST_ONE_SEP5<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(5, options);\n  }\n\n  AT_LEAST_ONE_SEP6<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(6, options);\n  }\n\n  AT_LEAST_ONE_SEP7<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(7, options);\n  }\n\n  AT_LEAST_ONE_SEP8<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(8, options);\n  }\n\n  AT_LEAST_ONE_SEP9<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    this.atLeastOneSepFirstInternal(9, options);\n  }\n\n  RULE<T>(\n    this: MixedInParser,\n    name: string,\n    implementation: (...implArgs: any[]) => T,\n    config: IRuleConfig<T> = DEFAULT_RULE_CONFIG,\n  ): (idxInCallingRule?: number, ...args: any[]) => T | any {\n    if (includes(this.definedRulesNames, name)) {\n      const errMsg =\n        defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n          topLevelRule: name,\n          grammarName: this.className,\n        });\n\n      const error = {\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n        ruleName: name,\n      };\n      this.definitionErrors.push(error);\n    }\n\n    this.definedRulesNames.push(name);\n\n    const ruleImplementation = this.defineRule(name, implementation, config);\n    (this as any)[name] = ruleImplementation;\n    return ruleImplementation;\n  }\n\n  OVERRIDE_RULE<T>(\n    this: MixedInParser,\n    name: string,\n    impl: (...implArgs: any[]) => T,\n    config: IRuleConfig<T> = DEFAULT_RULE_CONFIG,\n  ): (idxInCallingRule?: number, ...args: any[]) => T {\n    const ruleErrors: IParserDefinitionError[] = validateRuleIsOverridden(\n      name,\n      this.definedRulesNames,\n      this.className,\n    );\n    this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n\n    const ruleImplementation = this.defineRule(name, impl, config);\n    (this as any)[name] = ruleImplementation;\n    return ruleImplementation;\n  }\n\n  BACKTRACK<T>(\n    this: MixedInParser,\n    grammarRule: (...args: any[]) => T,\n    args?: any[],\n  ): () => boolean {\n    return function () {\n      // save org state\n      this.isBackTrackingStack.push(1);\n      const orgState = this.saveRecogState();\n      try {\n        grammarRule.apply(this, args);\n        // if no exception was thrown we have succeed parsing the rule.\n        return true;\n      } catch (e) {\n        if (isRecognitionException(e)) {\n          return false;\n        } else {\n          throw e;\n        }\n      } finally {\n        this.reloadRecogState(orgState);\n        this.isBackTrackingStack.pop();\n      }\n    };\n  }\n\n  // GAST export APIs\n  public getGAstProductions(this: MixedInParser): Record<string, Rule> {\n    return this.gastProductionsCache;\n  }\n\n  public getSerializedGastProductions(this: MixedInParser): ISerializedGast[] {\n    return serializeGrammar(values(this.gastProductionsCache));\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5372, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5378, "column": 0}, "map": {"version":3,"file":"recognizer_engine.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/parser/traits/recognizer_engine.ts"],"sourcesContent":["import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IRuleConfig,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  ParserMethod,\n  SubruleMethodOpts,\n  TokenType,\n  TokenTypeDictionary,\n  TokenVocabulary,\n} from \"@chevrotain/types\";\nimport {\n  clone,\n  every,\n  flatten,\n  has,\n  isArray,\n  isEmpty,\n  isObject,\n  reduce,\n  uniq,\n  values,\n} from \"lodash-es\";\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  BITS_FOR_METHOD_TYPE,\n  BITS_FOR_OCCURRENCE_IDX,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX,\n} from \"../../grammar/keys.js\";\nimport {\n  isRecognitionException,\n  MismatchedTokenException,\n  NotAllInputParsedException,\n} from \"../../exceptions_public.js\";\nimport { PROD_TYPE } from \"../../grammar/lookahead.js\";\nimport {\n  AbstractNextTerminalAfterProductionWalker,\n  NextTerminalAfterAtLeastOneSepWalker,\n  NextTerminalAfterAtLeastOneWalker,\n  NextTerminalAfterManySepWalker,\n  NextTerminalAfterManyWalker,\n} from \"../../grammar/interpreter.js\";\nimport { DEFAULT_RULE_CONFIG, IParserState, TokenMatcher } from \"../parser.js\";\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable.js\";\nimport { EOF } from \"../../../scan/tokens_public.js\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport {\n  augmentTokenTypes,\n  isTokenType,\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories,\n} from \"../../../scan/tokens.js\";\nimport { Rule } from \"@chevrotain/gast\";\nimport { ParserMethodInternal } from \"../types.js\";\n\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nexport class RecognizerEngine {\n  isBackTrackingStack: boolean[];\n  className: string;\n  RULE_STACK: number[];\n  RULE_OCCURRENCE_STACK: number[];\n  definedRulesNames: string[];\n  tokensMap: { [fqn: string]: TokenType };\n  gastProductionsCache: Record<string, Rule>;\n  shortRuleNameToFull: Record<string, string>;\n  fullRuleNameToShort: Record<string, number>;\n  // The shortName Index must be coded \"after\" the first 8bits to enable building unique lookahead keys\n  ruleShortNameIdx: number;\n  tokenMatcher: TokenMatcher;\n  subruleIdx: number;\n\n  initRecognizerEngine(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfig,\n  ) {\n    this.className = this.constructor.name;\n    // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n    this.shortRuleNameToFull = {};\n    this.fullRuleNameToShort = {};\n    this.ruleShortNameIdx = 256;\n    this.tokenMatcher = tokenStructuredMatcherNoCategories;\n    this.subruleIdx = 0;\n\n    this.definedRulesNames = [];\n    this.tokensMap = {};\n    this.isBackTrackingStack = [];\n    this.RULE_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n    this.gastProductionsCache = {};\n\n    if (has(config, \"serializedGrammar\")) {\n      throw Error(\n        \"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n          \"\\tFor Further details.\",\n      );\n    }\n\n    if (isArray(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if (isEmpty(tokenVocabulary as any[])) {\n        throw Error(\n          \"A Token Vocabulary cannot be empty.\\n\" +\n            \"\\tNote that the first argument for the parser constructor\\n\" +\n            \"\\tis no longer a Token vector (since v4.0).\",\n        );\n      }\n\n      if (typeof (tokenVocabulary as any[])[0].startOffset === \"number\") {\n        throw Error(\n          \"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n            \"\\tFor Further details.\",\n        );\n      }\n    }\n\n    if (isArray(tokenVocabulary)) {\n      this.tokensMap = reduce(\n        tokenVocabulary,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType;\n          return acc;\n        },\n        {} as { [tokenName: string]: TokenType },\n      );\n    } else if (\n      has(tokenVocabulary, \"modes\") &&\n      every(flatten(values((<any>tokenVocabulary).modes)), isTokenType)\n    ) {\n      const allTokenTypes = flatten(values((<any>tokenVocabulary).modes));\n      const uniqueTokens = uniq(allTokenTypes);\n      this.tokensMap = <any>reduce(\n        uniqueTokens,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType;\n          return acc;\n        },\n        {} as { [tokenName: string]: TokenType },\n      );\n    } else if (isObject(tokenVocabulary)) {\n      this.tokensMap = clone(tokenVocabulary as TokenTypeDictionary);\n    } else {\n      throw new Error(\n        \"<tokensDictionary> argument must be An Array of Token constructors,\" +\n          \" A dictionary of Token constructors or an IMultiModeLexerDefinition\",\n      );\n    }\n\n    // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n    this.tokensMap[\"EOF\"] = EOF;\n\n    const allTokenTypes = has(tokenVocabulary, \"modes\")\n      ? flatten(values((<any>tokenVocabulary).modes))\n      : values(tokenVocabulary);\n    const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) =>\n      isEmpty(tokenConstructor.categoryMatches),\n    );\n\n    this.tokenMatcher = noTokenCategoriesUsed\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher;\n\n    // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n    augmentTokenTypes(values(this.tokensMap));\n  }\n\n  defineRule<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleName: string,\n    impl: (...args: ARGS) => R,\n    config: IRuleConfig<R>,\n  ): ParserMethodInternal<ARGS, R> {\n    if (this.selfAnalysisDone) {\n      throw Error(\n        `Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n          `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`,\n      );\n    }\n    const resyncEnabled: boolean = has(config, \"resyncEnabled\")\n      ? (config.resyncEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_RULE_CONFIG.resyncEnabled;\n    const recoveryValueFunc = has(config, \"recoveryValueFunc\")\n      ? (config.recoveryValueFunc as () => R) // assumes end user provides the correct config value/type\n      : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n\n    // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n    const shortName =\n      this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX);\n\n    this.ruleShortNameIdx++;\n    this.shortRuleNameToFull[shortName] = ruleName;\n    this.fullRuleNameToShort[ruleName] = shortName;\n\n    let invokeRuleWithTry: ParserMethod<ARGS, R>;\n\n    // Micro optimization, only check the condition **once** on rule definition\n    // instead of **every single** rule invocation.\n    if (this.outputCst === true) {\n      invokeRuleWithTry = function invokeRuleWithTry(\n        this: MixedInParser,\n        ...args: ARGS\n      ): R {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          impl.apply(this, args);\n          const cst = this.CST_STACK[this.CST_STACK.length - 1];\n          this.cstPostRule(cst);\n          return cst as unknown as R;\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc) as R;\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      };\n    } else {\n      invokeRuleWithTry = function invokeRuleWithTryCst(\n        this: MixedInParser,\n        ...args: ARGS\n      ): R {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n          return impl.apply(this, args);\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc) as R;\n        } finally {\n          this.ruleFinallyStateUpdate();\n        }\n      };\n    }\n\n    const wrappedGrammarRule: ParserMethodInternal<ARGS, R> = Object.assign(\n      invokeRuleWithTry as any,\n      { ruleName, originalGrammarAction: impl },\n    );\n\n    return wrappedGrammarRule;\n  }\n\n  invokeRuleCatch(\n    this: MixedInParser,\n    e: Error,\n    resyncEnabledConfig: boolean,\n    recoveryValueFunc: Function,\n  ): unknown {\n    const isFirstInvokedRule = this.RULE_STACK.length === 1;\n    // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n    const reSyncEnabled =\n      resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n\n    if (isRecognitionException(e)) {\n      const recogError: any = e;\n      if (reSyncEnabled) {\n        const reSyncTokType = this.findReSyncTokenType();\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n          if (this.outputCst) {\n            const partialCstResult: any =\n              this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            return partialCstResult;\n          } else {\n            return recoveryValueFunc(e);\n          }\n        } else {\n          if (this.outputCst) {\n            const partialCstResult: any =\n              this.CST_STACK[this.CST_STACK.length - 1];\n            partialCstResult.recoveredNode = true;\n            recogError.partialCstResult = partialCstResult;\n          }\n          // to be handled Further up the call stack\n          throw recogError;\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState();\n        // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n        return recoveryValueFunc(e);\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError;\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e;\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternal<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number,\n  ): OUT | undefined {\n    const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n  }\n\n  optionInternalLogic<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number,\n    key: number,\n  ): OUT | undefined {\n    let lookAheadFunc = this.getLaFuncFromCache(key);\n    let action: GrammarAction<OUT>;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc;\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this);\n    }\n    return undefined;\n  }\n\n  atLeastOneInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_IDX,\n      prodOccurrence,\n    );\n    return this.atLeastOneInternalLogic(\n      prodOccurrence,\n      actionORMethodDef,\n      laKey,\n    );\n  }\n\n  atLeastOneInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n    key: number,\n  ): void {\n    let lookAheadFunc = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc;\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    if ((<Function>lookAheadFunc).call(this) === true) {\n      let notStuck = this.doSingleRepetition(action);\n      while (\n        (<Function>lookAheadFunc).call(this) === true &&\n        notStuck === true\n      ) {\n        notStuck = this.doSingleRepetition(action);\n      }\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY,\n        (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).ERR_MSG,\n      );\n    }\n\n    // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.atLeastOneInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookAheadFunc,\n      AT_LEAST_ONE_IDX,\n      prodOccurrence,\n      NextTerminalAfterAtLeastOneWalker,\n    );\n  }\n\n  atLeastOneSepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence,\n    );\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n  }\n\n  atLeastOneSepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>,\n    key: number,\n  ): void {\n    const action = options.DEF;\n    const separator = options.SEP;\n\n    const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n\n    // 1st iteration\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      (<GrammarAction<OUT>>action).call(this);\n\n      //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator);\n      };\n\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        // No need for checking infinite loop here due to consuming the separator.\n        (<GrammarAction<OUT>>action).call(this);\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterAtLeastOneSepWalker,\n        ],\n        separatorLookAheadFunc,\n        AT_LEAST_ONE_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterAtLeastOneSepWalker,\n      );\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        options.ERR_MSG,\n      );\n    }\n  }\n\n  manyInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n  }\n\n  manyInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    key: number,\n  ) {\n    let lookaheadFunction = this.getLaFuncFromCache(key);\n    let action;\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF;\n      const predicate = actionORMethodDef.GATE;\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookaheadFunction;\n        lookaheadFunction = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this);\n        };\n      }\n    } else {\n      action = actionORMethodDef;\n    }\n\n    let notStuck = true;\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action);\n    }\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.manyInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookaheadFunction,\n      MANY_IDX,\n      prodOccurrence,\n      NextTerminalAfterManyWalker,\n      // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n      // An infinite loop cannot occur as:\n      // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n      notStuck,\n    );\n  }\n\n  manySepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>,\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      MANY_SEP_IDX,\n      prodOccurrence,\n    );\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n  }\n\n  manySepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>,\n    key: number,\n  ): void {\n    const action = options.DEF;\n    const separator = options.SEP;\n    const firstIterationLaFunc = this.getLaFuncFromCache(key);\n\n    // 1st iteration\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this);\n\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator);\n      };\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator);\n        // No need for checking infinite loop here due to consuming the separator.\n        action.call(this);\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterManySepWalker,\n        ],\n        separatorLookAheadFunc,\n        MANY_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterManySepWalker,\n      );\n    }\n  }\n\n  repetitionSepSecondInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    separator: TokenType,\n    separatorLookAheadFunc: () => boolean,\n    action: GrammarAction<OUT>,\n    nextTerminalAfterWalker: typeof AbstractNextTerminalAfterProductionWalker,\n  ): void {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator);\n      action.call(this);\n    }\n\n    // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    /* istanbul ignore else */\n    this.attemptInRepetitionRecovery(\n      this.repetitionSepSecondInternal,\n      [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        nextTerminalAfterWalker,\n      ],\n      separatorLookAheadFunc,\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence,\n      nextTerminalAfterWalker,\n    );\n  }\n\n  doSingleRepetition(this: MixedInParser, action: Function): any {\n    const beforeIteration = this.getLexerPosition();\n    action.call(this);\n    const afterIteration = this.getLexerPosition();\n\n    // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n    return afterIteration > beforeIteration;\n  }\n\n  orInternal<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number,\n  ): T {\n    const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n    const alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n\n    const laFunc = this.getLaFuncFromCache(laKey);\n    const altIdxToTake = laFunc.call(this, alts);\n    if (altIdxToTake !== undefined) {\n      const chosenAlternative: any = alts[altIdxToTake];\n      return chosenAlternative.ALT.call(this);\n    }\n    this.raiseNoAltException(\n      occurrence,\n      (altsOrOpts as OrMethodOpts<unknown>).ERR_MSG,\n    );\n  }\n\n  ruleFinallyStateUpdate(this: MixedInParser): void {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop();\n\n    // NOOP when cst is disabled\n    this.cstFinallyStateUpdate();\n\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      const firstRedundantTok = this.LA(1);\n      const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName(),\n      });\n      this.SAVE_ERROR(\n        new NotAllInputParsedException(errMsg, firstRedundantTok),\n      );\n    }\n  }\n\n  subruleInternal<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    idx: number,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R {\n    let ruleResult;\n    try {\n      const args = options !== undefined ? options.ARGS : undefined;\n      this.subruleIdx = idx;\n      ruleResult = ruleToCall.apply(this, args);\n      this.cstPostNonTerminal(\n        ruleResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : ruleToCall.ruleName,\n      );\n      return ruleResult;\n    } catch (e) {\n      throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n    }\n  }\n\n  subruleInternalError(\n    this: MixedInParser,\n    e: any,\n    options: SubruleMethodOpts<unknown[]> | undefined,\n    ruleName: string,\n  ): void {\n    if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(\n        e.partialCstResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : ruleName,\n      );\n\n      delete e.partialCstResult;\n    }\n    throw e;\n  }\n\n  consumeInternal(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    options: ConsumeMethodOpts | undefined,\n  ): IToken {\n    let consumedToken!: IToken;\n    try {\n      const nextToken = this.LA(1);\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken();\n        consumedToken = nextToken;\n      } else {\n        this.consumeInternalError(tokType, nextToken, options);\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(\n        tokType,\n        idx,\n        eFromConsumption,\n      );\n    }\n\n    this.cstPostTerminal(\n      options !== undefined && options.LABEL !== undefined\n        ? options.LABEL\n        : tokType.name,\n      consumedToken,\n    );\n    return consumedToken;\n  }\n\n  consumeInternalError(\n    this: MixedInParser,\n    tokType: TokenType,\n    nextToken: IToken,\n    options: ConsumeMethodOpts | undefined,\n  ): void {\n    let msg;\n    const previousToken = this.LA(0);\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG;\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName(),\n      });\n    }\n    throw this.SAVE_ERROR(\n      new MismatchedTokenException(msg, nextToken, previousToken),\n    );\n  }\n\n  consumeInternalRecovery(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    eFromConsumption: Error,\n  ): IToken {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (\n      this.recoveryEnabled &&\n      // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n      eFromConsumption.name === \"MismatchedTokenException\" &&\n      !this.isBackTracking()\n    ) {\n      const follows = this.getFollowsForInRuleRecovery(<any>tokType, idx);\n      try {\n        return this.tryInRuleRecovery(<any>tokType, follows);\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption;\n        } else {\n          throw eFromInRuleRecovery;\n        }\n      }\n    } else {\n      throw eFromConsumption;\n    }\n  }\n\n  saveRecogState(this: MixedInParser): IParserState {\n    // errors is a getter which will clone the errors array\n    const savedErrors = this.errors;\n    const savedRuleStack = clone(this.RULE_STACK);\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK,\n    };\n  }\n\n  reloadRecogState(this: MixedInParser, newState: IParserState) {\n    this.errors = newState.errors;\n    this.importLexerState(newState.lexerState);\n    this.RULE_STACK = newState.RULE_STACK;\n  }\n\n  ruleInvocationStateUpdate(\n    this: MixedInParser,\n    shortName: number,\n    fullName: string,\n    idxInCallingRule: number,\n  ): void {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n    this.RULE_STACK.push(shortName);\n    // NOOP when cst is disabled\n    this.cstInvocationStateUpdate(fullName);\n  }\n\n  isBackTracking(this: MixedInParser): boolean {\n    return this.isBackTrackingStack.length !== 0;\n  }\n\n  getCurrRuleFullName(this: MixedInParser): string {\n    const shortName = this.getLastExplicitRuleShortName();\n    return this.shortRuleNameToFull[shortName];\n  }\n\n  shortRuleNameToFullName(this: MixedInParser, shortName: number) {\n    return this.shortRuleNameToFull[shortName];\n  }\n\n  public isAtEndOfInput(this: MixedInParser): boolean {\n    return this.tokenMatcher(this.LA(1), EOF);\n  }\n\n  public reset(this: MixedInParser): void {\n    this.resetLexerState();\n    this.subruleIdx = 0;\n    this.isBackTrackingStack = [];\n    this.errors = [];\n    this.RULE_STACK = [];\n    // TODO: extract a specific reset for TreeBuilder trait\n    this.CST_STACK = [];\n    this.RULE_OCCURRENCE_STACK = [];\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5894, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5900, "column": 0}, "map": {"version":3,"file":"error_handler.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/parser/traits/error_handler.ts"],"sourcesContent":["import {\n  IParserConfig,\n  IParserErrorMessageProvider,\n  IRecognitionException,\n} from \"@chevrotain/types\";\nimport {\n  EarlyExitException,\n  isRecognitionException,\n  NoViableAltException,\n} from \"../../exceptions_public.js\";\nimport { clone, has } from \"lodash-es\";\nimport {\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  PROD_TYPE,\n} from \"../../grammar/lookahead.js\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class ErrorHandler {\n  _errors: IRecognitionException[];\n  errorMessageProvider: IParserErrorMessageProvider;\n\n  initErrorHandler(config: IParserConfig) {\n    this._errors = [];\n    this.errorMessageProvider = has(config, \"errorMessageProvider\")\n      ? (config.errorMessageProvider as IParserErrorMessageProvider) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n  }\n\n  SAVE_ERROR(\n    this: MixedInParser,\n    error: IRecognitionException,\n  ): IRecognitionException {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK),\n      };\n      this._errors.push(error);\n      return error;\n    } else {\n      throw Error(\n        \"Trying to save an Error which is not a RecognitionException\",\n      );\n    }\n  }\n\n  get errors(): IRecognitionException[] {\n    return clone(this._errors);\n  }\n\n  set errors(newErrors: IRecognitionException[]) {\n    this._errors = newErrors;\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseEarlyExitException(\n    this: MixedInParser,\n    occurrence: number,\n    prodType: PROD_TYPE,\n    userDefinedErrMsg: string | undefined,\n  ): never {\n    const ruleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[ruleName];\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(\n      occurrence,\n      ruleGrammar,\n      prodType,\n      this.maxLookahead,\n    );\n    const insideProdPaths = lookAheadPathsPerAlternative[0];\n    const actualTokens = [];\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    const msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName,\n    });\n\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseNoAltException(\n    this: MixedInParser,\n    occurrence: number,\n    errMsgTypes: string | undefined,\n  ): never {\n    const ruleName = this.getCurrRuleFullName();\n    const ruleGrammar = this.getGAstProductions()[ruleName];\n    // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOr(\n      occurrence,\n      ruleGrammar,\n      this.maxLookahead,\n    );\n\n    const actualTokens = [];\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n    const previousToken = this.LA(0);\n\n    const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName(),\n    });\n\n    throw this.SAVE_ERROR(\n      new NoViableAltException(errMsg, this.LA(1), previousToken),\n    );\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5976, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5982, "column": 0}, "map": {"version":3,"file":"context_assist.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/parser/traits/context_assist.ts"],"sourcesContent":["import {\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType,\n} from \"@chevrotain/types\";\nimport {\n  NextAfterTokenWalker,\n  nextPossibleTokensAfter,\n} from \"../../grammar/interpreter.js\";\nimport { first, isUndefined } from \"lodash-es\";\nimport { MixedInParser } from \"./parser_traits.js\";\n\nexport class ContentAssist {\n  initContentAssist() {}\n\n  public computeContentAssist(\n    this: MixedInParser,\n    startRuleName: string,\n    precedingInput: IToken[],\n  ): ISyntacticContentAssistPath[] {\n    const startRuleGast = this.gastProductionsCache[startRuleName];\n\n    if (isUndefined(startRuleGast)) {\n      throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);\n    }\n\n    return nextPossibleTokensAfter(\n      [startRuleGast],\n      precedingInput,\n      this.tokenMatcher,\n      this.maxLookahead,\n    );\n  }\n\n  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n  // TODO: should this be more explicitly part of the public API?\n  public getNextPossibleTokenTypes(\n    this: MixedInParser,\n    grammarPath: ITokenGrammarPath,\n  ): TokenType[] {\n    const topRuleName = first(grammarPath.ruleStack)!;\n    const gastProductions = this.getGAstProductions();\n    const topProduction = gastProductions[topRuleName];\n    const nextPossibleTokenTypes = new NextAfterTokenWalker(\n      topProduction,\n      grammarPath,\n    ).startWalking();\n    return nextPossibleTokenTypes;\n  }\n}\n"],"names":[],"mappings":";;;AAMA,OAAO,EACL,oBAAoB,EACpB,uBAAuB,GACxB,MAAM,8BAA8B,CAAC;AACtC,OAAO,EAAE,KAAK,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;;;;AAGzC,MAAO,aAAa;IACxB,iBAAiB,GAAA,CAAI,CAAC;IAEf,oBAAoB,CAEzB,aAAqB,EACrB,cAAwB,EAAA;QAExB,MAAM,aAAa,GAAG,IAAI,CAAC,oBAAoB,CAAC,aAAa,CAAC,CAAC;QAE/D,yNAAI,cAAA,AAAW,EAAC,aAAa,CAAC,EAAE;YAC9B,MAAM,KAAK,CAAC,CAAA,OAAA,EAAU,aAAa,CAAA,kCAAA,CAAoC,CAAC,CAAC;SAC1E;QAED,kNAAO,0BAAA,AAAuB,EAC5B;YAAC,aAAa;SAAC,EACf,cAAc,EACd,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,YAAY,CAClB,CAAC;IACJ,CAAC;IAED,sGAAsG;IACtG,+DAA+D;IACxD,yBAAyB,CAE9B,WAA8B,EAAA;QAE9B,MAAM,WAAW,2MAAG,QAAA,AAAK,EAAC,WAAW,CAAC,SAAS,CAAE,CAAC;QAClD,MAAM,eAAe,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAClD,MAAM,aAAa,GAAG,eAAe,CAAC,WAAW,CAAC,CAAC;QACnD,MAAM,sBAAsB,GAAG,2MAAI,uBAAoB,CACrD,aAAa,EACb,WAAW,CACZ,CAAC,YAAY,EAAE,CAAC;QACjB,OAAO,sBAAsB,CAAC;IAChC,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 6011, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6017, "column": 0}, "map": {"version":3,"file":"gast_recorder.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/parser/traits/gast_recorder.ts"],"sourcesContent":["import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  CstNode,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IProduction,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType,\n} from \"@chevrotain/types\";\nimport {\n  forEach,\n  has,\n  isArray,\n  isFunction,\n  last as peek,\n  some,\n} from \"lodash-es\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n} from \"@chevrotain/gast\";\nimport { Lexer } from \"../../../scan/lexer_public.js\";\nimport {\n  augmentTokenTypes,\n  hasShortKeyProperty,\n} from \"../../../scan/tokens.js\";\nimport {\n  createToken,\n  createTokenInstance,\n} from \"../../../scan/tokens_public.js\";\nimport { END_OF_FILE } from \"../parser.js\";\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys.js\";\nimport { ParserMethodInternal } from \"../types.js\";\n\ntype ProdWithDef = IProduction & { definition?: IProduction[] };\nconst RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\",\n};\nObject.freeze(RECORDING_NULL_OBJECT);\n\nconst HANDLE_SEPARATOR = true;\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\n\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA });\naugmentTokenTypes([RFT]);\nconst RECORDING_PHASE_TOKEN = createTokenInstance(\n  RFT,\n  \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n);\nObject.freeze(RECORDING_PHASE_TOKEN);\n\nconst RECORDING_PHASE_CSTNODE: CstNode = {\n  name:\n    \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {},\n};\n\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nexport class GastRecorder {\n  recordingProdStack: ProdWithDef[];\n  RECORDING_PHASE: boolean;\n\n  initGastRecorder(this: MixedInParser, config: IParserConfig): void {\n    this.recordingProdStack = [];\n    this.RECORDING_PHASE = false;\n  }\n\n  enableRecording(this: MixedInParser): void {\n    this.RECORDING_PHASE = true;\n\n    this.TRACE_INIT(\"Enable Recording\", () => {\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\";\n        this[`CONSUME${idx}` as \"CONSUME\"] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2);\n        };\n        this[`SUBRULE${idx}` as \"SUBRULE\"] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2) as any;\n        };\n        this[`OPTION${idx}` as \"OPTION\"] = function (arg1) {\n          return this.optionInternalRecord(arg1, i);\n        };\n        this[`OR${idx}` as \"OR\"] = function (arg1) {\n          return this.orInternalRecord(arg1, i);\n        };\n        this[`MANY${idx}` as \"MANY\"] = function (arg1) {\n          this.manyInternalRecord(i, arg1);\n        };\n        this[`MANY_SEP${idx}` as \"MANY_SEP\"] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1);\n        };\n        this[`AT_LEAST_ONE${idx}` as \"AT_LEAST_ONE\"] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1);\n        };\n        this[`AT_LEAST_ONE_SEP${idx}` as \"AT_LEAST_ONE_SEP\"] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\n        };\n      }\n\n      // DSL methods with the idx(suffix) as an argument\n      this[`consume`] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2);\n      };\n      this[`subrule`] = function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2) as any;\n      };\n      this[`option`] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx);\n      };\n      this[`or`] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx);\n      };\n      this[`many`] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1);\n      };\n      this[`atLeastOne`] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1);\n      };\n\n      this.ACTION = this.ACTION_RECORD;\n      this.BACKTRACK = this.BACKTRACK_RECORD;\n      this.LA = this.LA_RECORD;\n    });\n  }\n\n  disableRecording(this: MixedInParser) {\n    this.RECORDING_PHASE = false;\n    // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n    this.TRACE_INIT(\"Deleting Recording methods\", () => {\n      const that: any = this;\n\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\";\n        delete that[`CONSUME${idx}`];\n        delete that[`SUBRULE${idx}`];\n        delete that[`OPTION${idx}`];\n        delete that[`OR${idx}`];\n        delete that[`MANY${idx}`];\n        delete that[`MANY_SEP${idx}`];\n        delete that[`AT_LEAST_ONE${idx}`];\n        delete that[`AT_LEAST_ONE_SEP${idx}`];\n      }\n\n      delete that[`consume`];\n      delete that[`subrule`];\n      delete that[`option`];\n      delete that[`or`];\n      delete that[`many`];\n      delete that[`atLeastOne`];\n\n      delete that.ACTION;\n      delete that.BACKTRACK;\n      delete that.LA;\n    });\n  }\n\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  // @ts-expect-error -- noop place holder\n  ACTION_RECORD<T>(this: MixedInParser, impl: () => T): T {\n    // NO-OP during recording\n  }\n\n  // Executing backtracking logic will break our recording logic assumptions\n  BACKTRACK_RECORD<T>(\n    grammarRule: (...args: any[]) => T,\n    args?: any[],\n  ): () => boolean {\n    return () => true;\n  }\n\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  LA_RECORD(howMuch: number): IToken {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return END_OF_FILE;\n  }\n\n  topLevelRuleRecord(name: string, def: Function): Rule {\n    try {\n      const newTopLevelRule = new Rule({ definition: [], name: name });\n      newTopLevelRule.name = name;\n      this.recordingProdStack.push(newTopLevelRule);\n      def.call(this);\n      this.recordingProdStack.pop();\n      return newTopLevelRule;\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message =\n            originalError.message +\n            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError;\n        }\n      }\n      throw originalError;\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternalRecord<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number,\n  ): OUT {\n    return recordProd.call(this, Option, actionORMethodDef, occurrence);\n  }\n\n  atLeastOneInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n  ): void {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n  }\n\n  atLeastOneSepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>,\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionMandatoryWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR,\n    );\n  }\n\n  manyInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n  ): void {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n  }\n\n  manySepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: ManySepMethodOpts<OUT>,\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR,\n    );\n  }\n\n  orInternalRecord<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number,\n  ): T {\n    return recordOrProd.call(this, altsOrOpts, occurrence);\n  }\n\n  subruleInternalRecord<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    occurrence: number,\n    options?: SubruleMethodOpts<ARGS>,\n  ): R | CstNode {\n    assertMethodIdxIsValid(occurrence);\n    if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n      const error: any = new Error(\n        `<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a Parser method reference but got: <${JSON.stringify(\n            ruleToCall,\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`,\n      );\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n\n    const prevProd: any = peek(this.recordingProdStack);\n    const ruleName = ruleToCall.ruleName;\n    const newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options?.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined,\n    });\n    prevProd.definition.push(newNoneTerminal);\n\n    return this.outputCst\n      ? RECORDING_PHASE_CSTNODE\n      : <any>RECORDING_NULL_OBJECT;\n  }\n\n  consumeInternalRecord(\n    this: MixedInParser,\n    tokType: TokenType,\n    occurrence: number,\n    options?: ConsumeMethodOpts,\n  ): IToken {\n    assertMethodIdxIsValid(occurrence);\n    if (!hasShortKeyProperty(tokType)) {\n      const error: any = new Error(\n        `<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a TokenType reference but got: <${JSON.stringify(\n            tokType,\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`,\n      );\n      error.KNOWN_RECORDER_ERROR = true;\n      throw error;\n    }\n    const prevProd: any = peek(this.recordingProdStack);\n    const newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options?.LABEL,\n    });\n    prevProd.definition.push(newNoneTerminal);\n\n    return RECORDING_PHASE_TOKEN;\n  }\n}\n\nfunction recordProd(\n  prodConstructor: any,\n  mainProdArg: any,\n  occurrence: number,\n  handleSep: boolean = false,\n): any {\n  assertMethodIdxIsValid(occurrence);\n  const prevProd: any = peek(this.recordingProdStack);\n  const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n\n  const newProd = new prodConstructor({ definition: [], idx: occurrence });\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP;\n  }\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  this.recordingProdStack.push(newProd);\n  grammarAction.call(this);\n  prevProd.definition.push(newProd);\n  this.recordingProdStack.pop();\n\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction recordOrProd(mainProdArg: any, occurrence: number): any {\n  assertMethodIdxIsValid(occurrence);\n  const prevProd: any = peek(this.recordingProdStack);\n  // Only an array of alternatives\n  const hasOptions = isArray(mainProdArg) === false;\n  const alts: IOrAlt<unknown>[] =\n    hasOptions === false ? mainProdArg : mainProdArg.DEF;\n\n  const newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true,\n  });\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n  }\n\n  const hasPredicates = some(alts, (currAlt: any) => isFunction(currAlt.GATE));\n  newOrProd.hasPredicates = hasPredicates;\n\n  prevProd.definition.push(newOrProd);\n\n  forEach(alts, (currAlt) => {\n    const currAltFlat = new Alternative({ definition: [] });\n    newOrProd.definition.push(currAltFlat);\n    if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES as boolean; // assumes end user provides the correct config value/type\n    }\n    // **implicit** ignoreAmbiguities due to usage of gate\n    else if (has(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true;\n    }\n    this.recordingProdStack.push(currAltFlat);\n    currAlt.ALT.call(this);\n    this.recordingProdStack.pop();\n  });\n  return RECORDING_NULL_OBJECT;\n}\n\nfunction getIdxSuffix(idx: number): string {\n  return idx === 0 ? \"\" : `${idx}`;\n}\n\nfunction assertMethodIdxIsValid(idx: number): void {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    const error: any = new Error(\n      // The stack trace will contain all the needed details\n      `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n        `Idx value must be a none negative value smaller than ${\n          MAX_METHOD_IDX + 1\n        }`,\n    );\n    error.KNOWN_RECORDER_ERROR = true;\n    throw error;\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6317, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6323, "column": 0}, "map": {"version":3,"file":"perf_tracer.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/parser/traits/perf_tracer.ts"],"sourcesContent":["import { IParserConfig } from \"@chevrotain/types\";\nimport { has } from \"lodash-es\";\nimport { timer } from \"@chevrotain/utils\";\nimport { MixedInParser } from \"./parser_traits.js\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class PerformanceTracer {\n  traceInitPerf: boolean | number;\n  traceInitMaxIdent: number;\n  traceInitIndent: number;\n\n  initPerformanceTracer(config: IParserConfig) {\n    if (has(config, \"traceInitPerf\")) {\n      const userTraceInitPerf = config.traceInitPerf;\n      const traceIsNumber = typeof userTraceInitPerf === \"number\";\n      this.traceInitMaxIdent = traceIsNumber\n        ? <number>userTraceInitPerf\n        : Infinity;\n      this.traceInitPerf = traceIsNumber\n        ? userTraceInitPerf > 0\n        : (userTraceInitPerf as boolean); // assumes end user provides the correct config value/type\n    } else {\n      this.traceInitMaxIdent = 0;\n      this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\n    }\n\n    this.traceInitIndent = -1;\n  }\n\n  TRACE_INIT<T>(this: MixedInParser, phaseDesc: string, phaseImpl: () => T): T {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++;\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`);\n      }\n      const { time, value } = timer(phaseImpl);\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      const traceMethod = time > 10 ? console.warn : console.log;\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n      }\n      this.traceInitIndent--;\n      return value;\n    } else {\n      return phaseImpl();\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,KAAK,EAAE,MAAM,mBAAmB,CAAC;AAE1C,OAAO,EAAE,qBAAqB,EAAE,MAAM,cAAc,CAAC;AAHrD,OAAO,EAAE,GAAG,EAAE,MAAM,WAAW,CAAC;;;;;AAQ1B,MAAO,iBAAiB;IAK5B,qBAAqB,CAAC,MAAqB,EAAA;QACzC,yMAAI,MAAA,AAAG,EAAC,MAAM,EAAE,eAAe,CAAC,EAAE;YAChC,MAAM,iBAAiB,GAAG,MAAM,CAAC,aAAa,CAAC;YAC/C,MAAM,aAAa,GAAG,OAAO,iBAAiB,KAAK,QAAQ,CAAC;YAC5D,IAAI,CAAC,iBAAiB,GAAG,aAAa,GAC1B,iBAAiB,GACzB,QAAQ,CAAC;YACb,IAAI,CAAC,aAAa,GAAG,aAAa,GAC9B,iBAAiB,GAAG,CAAC,GACpB,iBAA6B,CAAC,CAAC,0DAA0D;SAC/F,MAAM;YACL,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;YAC3B,IAAI,CAAC,aAAa,GAAG,yNAAqB,CAAC,aAAa,CAAC;SAC1D;QAED,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC;IAC5B,CAAC;IAED,UAAU,CAAyB,SAAiB,EAAE,SAAkB,EAAA;QACtE,sDAAsD;QACtD,oCAAoC;QACpC,IAAI,IAAI,CAAC,aAAa,KAAK,IAAI,EAAE;YAC/B,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,MAAM,MAAM,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC9D,IAAI,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,iBAAiB,EAAE;gBACjD,OAAO,CAAC,GAAG,CAAC,GAAG,MAAM,CAAA,KAAA,EAAQ,SAAS,CAAA,CAAA,CAAG,CAAC,CAAC;aAC5C;YACD,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,+LAAG,QAAA,AAAK,EAAC,SAAS,CAAC,CAAC;YACzC,gGAAA,EAAkG,CAClG,MAAM,WAAW,GAAG,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC;YAC3D,IAAI,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,iBAAiB,EAAE;gBACjD,WAAW,CAAC,GAAG,MAAM,CAAA,KAAA,EAAQ,SAAS,CAAA,QAAA,EAAW,IAAI,CAAA,EAAA,CAAI,CAAC,CAAC;aAC5D;YACD,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,OAAO,KAAK,CAAC;SACd,MAAM;YACL,OAAO,SAAS,EAAE,CAAC;SACpB;IACH,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 6367, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6373, "column": 0}, "map": {"version":3,"file":"apply_mixins.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/parser/utils/apply_mixins.ts"],"sourcesContent":["export function applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach((baseCtor) => {\n    const baseProto = baseCtor.prototype;\n    Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n      if (propName === \"constructor\") {\n        return;\n      }\n\n      const basePropDescriptor = Object.getOwnPropertyDescriptor(\n        baseProto,\n        propName,\n      );\n      // Handle Accessors\n      if (\n        basePropDescriptor &&\n        (basePropDescriptor.get || basePropDescriptor.set)\n      ) {\n        Object.defineProperty(\n          derivedCtor.prototype,\n          propName,\n          basePropDescriptor,\n        );\n      } else {\n        derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n      }\n    });\n  });\n}\n"],"names":[],"mappings":";;;AAAM,SAAU,WAAW,CAAC,WAAgB,EAAE,SAAgB;IAC5D,SAAS,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;QAC7B,MAAM,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC;QACrC,MAAM,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;YACzD,IAAI,QAAQ,KAAK,aAAa,EAAE;gBAC9B,OAAO;aACR;YAED,MAAM,kBAAkB,GAAG,MAAM,CAAC,wBAAwB,CACxD,SAAS,EACT,QAAQ,CACT,CAAC;YACF,mBAAmB;YACnB,IACE,kBAAkB,IAClB,CAAC,kBAAkB,CAAC,GAAG,IAAI,kBAAkB,CAAC,GAAG,CAAC,EAClD;gBACA,MAAM,CAAC,cAAc,CACnB,WAAW,CAAC,SAAS,EACrB,QAAQ,EACR,kBAAkB,CACnB,CAAC;aACH,MAAM;gBACL,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;aAChE;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC","ignoreList":[0]}},
    {"offset": {"line": 6393, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6399, "column": 0}, "map": {"version":3,"file":"parser.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/parse/parser/parser.ts"],"sourcesContent":["import { clone, forEach, has, isEmpty, map, values } from \"lodash-es\";\nimport { toFastProperties } from \"@chevrotain/utils\";\nimport { computeAllProdsFollows } from \"../grammar/follow.js\";\nimport { createTokenInstance, EOF } from \"../../scan/tokens_public.js\";\nimport {\n  defaultGrammarValidatorErrorProvider,\n  defaultParserErrorProvider,\n} from \"../errors_public.js\";\nimport {\n  resolveGrammar,\n  validateGrammar,\n} from \"../grammar/gast/gast_resolver_public.js\";\nimport {\n  CstNode,\n  IParserConfig,\n  IRecognitionException,\n  IRuleConfig,\n  IToken,\n  TokenType,\n  TokenVocabulary,\n} from \"@chevrotain/types\";\nimport { Recoverable } from \"./traits/recoverable.js\";\nimport { LooksAhead } from \"./traits/looksahead.js\";\nimport { TreeBuilder } from \"./traits/tree_builder.js\";\nimport { LexerAdapter } from \"./traits/lexer_adapter.js\";\nimport { RecognizerApi } from \"./traits/recognizer_api.js\";\nimport { RecognizerEngine } from \"./traits/recognizer_engine.js\";\n\nimport { ErrorHandler } from \"./traits/error_handler.js\";\nimport { MixedInParser } from \"./traits/parser_traits.js\";\nimport { ContentAssist } from \"./traits/context_assist.js\";\nimport { GastRecorder } from \"./traits/gast_recorder.js\";\nimport { PerformanceTracer } from \"./traits/perf_tracer.js\";\nimport { applyMixins } from \"./utils/apply_mixins.js\";\nimport { IParserDefinitionError } from \"../grammar/types.js\";\nimport { Rule } from \"@chevrotain/gast\";\nimport { IParserConfigInternal, ParserMethodInternal } from \"./types.js\";\nimport { validateLookahead } from \"../grammar/checks.js\";\n\nexport const END_OF_FILE = createTokenInstance(\n  EOF,\n  \"\",\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n);\nObject.freeze(END_OF_FILE);\n\nexport type TokenMatcher = (token: IToken, tokType: TokenType) => boolean;\n\nexport const DEFAULT_PARSER_CONFIG: Required<\n  Omit<IParserConfigInternal, \"lookaheadStrategy\">\n> = Object.freeze({\n  recoveryEnabled: false,\n  maxLookahead: 3,\n  dynamicTokensEnabled: false,\n  outputCst: true,\n  errorMessageProvider: defaultParserErrorProvider,\n  nodeLocationTracking: \"none\",\n  traceInitPerf: false,\n  skipValidations: false,\n});\n\nexport const DEFAULT_RULE_CONFIG: Required<IRuleConfig<any>> = Object.freeze({\n  recoveryValueFunc: () => undefined,\n  resyncEnabled: true,\n});\n\nexport enum ParserDefinitionErrorType {\n  INVALID_RULE_NAME = 0,\n  DUPLICATE_RULE_NAME = 1,\n  INVALID_RULE_OVERRIDE = 2,\n  DUPLICATE_PRODUCTIONS = 3,\n  UNRESOLVED_SUBRULE_REF = 4,\n  LEFT_RECURSION = 5,\n  NONE_LAST_EMPTY_ALT = 6,\n  AMBIGUOUS_ALTS = 7,\n  CONFLICT_TOKENS_RULES_NAMESPACE = 8,\n  INVALID_TOKEN_NAME = 9,\n  NO_NON_EMPTY_LOOKAHEAD = 10,\n  AMBIGUOUS_PREFIX_ALTS = 11,\n  TOO_MANY_ALTS = 12,\n  CUSTOM_LOOKAHEAD_VALIDATION = 13,\n}\n\nexport interface IParserDuplicatesDefinitionError\n  extends IParserDefinitionError {\n  dslName: string;\n  occurrence: number;\n  parameter?: string;\n}\n\nexport interface IParserEmptyAlternativeDefinitionError\n  extends IParserDefinitionError {\n  occurrence: number;\n  alternative: number;\n}\n\nexport interface IParserAmbiguousAlternativesDefinitionError\n  extends IParserDefinitionError {\n  occurrence: number | string;\n  alternatives: number[];\n}\n\nexport interface IParserUnresolvedRefDefinitionError\n  extends IParserDefinitionError {\n  unresolvedRefName: string;\n}\n\nexport interface IParserState {\n  errors: IRecognitionException[];\n  lexerState: any;\n  RULE_STACK: number[];\n  CST_STACK: CstNode[];\n}\n\nexport type Predicate = () => boolean;\n\nexport function EMPTY_ALT(): () => undefined;\nexport function EMPTY_ALT<T>(value: T): () => T;\nexport function EMPTY_ALT(value: any = undefined) {\n  return function () {\n    return value;\n  };\n}\n\nexport class Parser {\n  // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n  // (normally during the parser's constructor).\n  // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n  // for example: duplicate rule names, referencing an unresolved subrule, ect...\n  // This flag should not be enabled during normal usage, it is used in special situations, for example when\n  // needing to display the parser definition errors in some GUI(online playground).\n  static DEFER_DEFINITION_ERRORS_HANDLING: boolean = false;\n\n  /**\n   *  @deprecated use the **instance** method with the same name instead\n   */\n  static performSelfAnalysis(parserInstance: Parser): void {\n    throw Error(\n      \"The **static** `performSelfAnalysis` method has been deprecated.\" +\n        \"\\t\\nUse the **instance** method with the same name instead.\",\n    );\n  }\n\n  public performSelfAnalysis(this: MixedInParser): void {\n    this.TRACE_INIT(\"performSelfAnalysis\", () => {\n      let defErrorsMsgs;\n\n      this.selfAnalysisDone = true;\n      const className = this.className;\n\n      this.TRACE_INIT(\"toFastProps\", () => {\n        // Without this voodoo magic the parser would be x3-x4 slower\n        // It seems it is better to invoke `toFastProperties` **before**\n        // Any manipulations of the `this` object done during the recording phase.\n        toFastProperties(this);\n      });\n\n      this.TRACE_INIT(\"Grammar Recording\", () => {\n        try {\n          this.enableRecording();\n          // Building the GAST\n          forEach(this.definedRulesNames, (currRuleName) => {\n            const wrappedRule = (this as any)[\n              currRuleName\n            ] as ParserMethodInternal<unknown[], unknown>;\n            const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n            let recordedRuleGast!: Rule;\n            this.TRACE_INIT(`${currRuleName} Rule`, () => {\n              recordedRuleGast = this.topLevelRuleRecord(\n                currRuleName,\n                originalGrammarAction,\n              );\n            });\n            this.gastProductionsCache[currRuleName] = recordedRuleGast;\n          });\n        } finally {\n          this.disableRecording();\n        }\n      });\n\n      let resolverErrors: IParserDefinitionError[] = [];\n      this.TRACE_INIT(\"Grammar Resolving\", () => {\n        resolverErrors = resolveGrammar({\n          rules: values(this.gastProductionsCache),\n        });\n        this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n      });\n\n      this.TRACE_INIT(\"Grammar Validations\", () => {\n        // only perform additional grammar validations IFF no resolving errors have occurred.\n        // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n        if (isEmpty(resolverErrors) && this.skipValidations === false) {\n          const validationErrors = validateGrammar({\n            rules: values(this.gastProductionsCache),\n            tokenTypes: values(this.tokensMap),\n            errMsgProvider: defaultGrammarValidatorErrorProvider,\n            grammarName: className,\n          });\n          const lookaheadValidationErrors = validateLookahead({\n            lookaheadStrategy: this.lookaheadStrategy,\n            rules: values(this.gastProductionsCache),\n            tokenTypes: values(this.tokensMap),\n            grammarName: className,\n          });\n          this.definitionErrors = this.definitionErrors.concat(\n            validationErrors,\n            lookaheadValidationErrors,\n          );\n        }\n      });\n\n      // this analysis may fail if the grammar is not perfectly valid\n      if (isEmpty(this.definitionErrors)) {\n        // The results of these computations are not needed unless error recovery is enabled.\n        if (this.recoveryEnabled) {\n          this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n            const allFollows = computeAllProdsFollows(\n              values(this.gastProductionsCache),\n            );\n            this.resyncFollows = allFollows;\n          });\n        }\n\n        this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n          this.lookaheadStrategy.initialize?.({\n            rules: values(this.gastProductionsCache),\n          });\n          this.preComputeLookaheadFunctions(values(this.gastProductionsCache));\n        });\n      }\n\n      if (\n        !Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n        !isEmpty(this.definitionErrors)\n      ) {\n        defErrorsMsgs = map(\n          this.definitionErrors,\n          (defError) => defError.message,\n        );\n        throw new Error(\n          `Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\n            \"\\n-------------------------------\\n\",\n          )}`,\n        );\n      }\n    });\n  }\n\n  definitionErrors: IParserDefinitionError[] = [];\n  selfAnalysisDone = false;\n  protected skipValidations: boolean;\n\n  constructor(tokenVocabulary: TokenVocabulary, config: IParserConfig) {\n    const that: MixedInParser = this as any;\n    that.initErrorHandler(config);\n    that.initLexerAdapter();\n    that.initLooksAhead(config);\n    that.initRecognizerEngine(tokenVocabulary, config);\n    that.initRecoverable(config);\n    that.initTreeBuilder(config);\n    that.initContentAssist();\n    that.initGastRecorder(config);\n    that.initPerformanceTracer(config);\n\n    if (has(config, \"ignoredIssues\")) {\n      throw new Error(\n        \"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n          \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n          \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n          \"For further details.\",\n      );\n    }\n\n    this.skipValidations = has(config, \"skipValidations\")\n      ? (config.skipValidations as boolean) // casting assumes the end user passing the correct type\n      : DEFAULT_PARSER_CONFIG.skipValidations;\n  }\n}\n\napplyMixins(Parser, [\n  Recoverable,\n  LooksAhead,\n  TreeBuilder,\n  LexerAdapter,\n  RecognizerEngine,\n  RecognizerApi,\n  ErrorHandler,\n  ContentAssist,\n  GastRecorder,\n  PerformanceTracer,\n]);\n\nexport class CstParser extends Parser {\n  constructor(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfigInternal = DEFAULT_PARSER_CONFIG,\n  ) {\n    const configClone = clone(config);\n    configClone.outputCst = true;\n    super(tokenVocabulary, configClone);\n  }\n}\n\nexport class EmbeddedActionsParser extends Parser {\n  constructor(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfigInternal = DEFAULT_PARSER_CONFIG,\n  ) {\n    const configClone = clone(config);\n    configClone.outputCst = false;\n    super(tokenVocabulary, configClone);\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6625, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6631, "column": 0}, "map": {"version":3,"file":"render_public.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/diagrams/render_public.ts"],"sourcesContent":["import { VERSION } from \"../version.js\";\nimport { ISerializedGast } from \"@chevrotain/types\";\n\nexport function createSyntaxDiagramsCode(\n  grammar: ISerializedGast[],\n  {\n    resourceBase = `https://unpkg.com/chevrotain@${VERSION}/diagrams/`,\n    css = `https://unpkg.com/chevrotain@${VERSION}/diagrams/diagrams.css`,\n  }: {\n    resourceBase?: string;\n    css?: string;\n  } = {},\n) {\n  const header = `\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n`;\n  const cssHtml = `\n<link rel='stylesheet' href='${css}'>\n`;\n\n  const scripts = `\n<script src='${resourceBase}vendor/railroad-diagrams.js'></script>\n<script src='${resourceBase}src/diagrams_builder.js'></script>\n<script src='${resourceBase}src/diagrams_behavior.js'></script>\n<script src='${resourceBase}src/main.js'></script>\n`;\n  const diagramsDiv = `\n<div id=\"diagrams\" align=\"center\"></div>    \n`;\n  const serializedGrammar = `\n<script>\n    window.serializedGrammar = ${JSON.stringify(grammar, null, \"  \")};\n</script>\n`;\n\n  const initLogic = `\n<script>\n    var diagramsDiv = document.getElementById(\"diagrams\");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n`;\n  return (\n    header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic\n  );\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;;AAGlC,SAAU,wBAAwB,CACtC,OAA0B,EAC1B,EACE,YAAY,GAAG,CAAA,6BAAA,iLAAgC,UAAO,CAAA,UAAA,CAAY,EAClE,GAAG,GAAG,CAAA,6BAAA,iLAAgC,UAAO,CAAA,sBAAA,CAAwB,EAAA,GAInE,CAAA,CAAE;IAEN,MAAM,MAAM,GAAG,CAAA;;;;;;;;;;CAUhB,CAAC;IACA,MAAM,OAAO,GAAG,CAAA;+BACa,GAAG,CAAA;CACjC,CAAC;IAEA,MAAM,OAAO,GAAG,CAAA;eACH,YAAY,CAAA;eACZ,YAAY,CAAA;eACZ,YAAY,CAAA;eACZ,YAAY,CAAA;CAC1B,CAAC;IACA,MAAM,WAAW,GAAG,CAAA;;CAErB,CAAC;IACA,MAAM,iBAAiB,GAAG,CAAA;;iCAEK,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,CAAA;;CAEnE,CAAC;IAEA,MAAM,SAAS,GAAG,CAAA;;;;;CAKnB,CAAC;IACA,OAAO,AACL,MAAM,GAAG,OAAO,GAAG,OAAO,GAAG,WAAW,GAAG,iBAAiB,GAAG,SAAS,CACzE,CAAC;AACJ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 6673, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6679, "column": 0}, "map": {"version":3,"file":"api.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/chevrotain/src/api.ts"],"sourcesContent":["/* istanbul ignore file - tricky to import some things from this module during testing */\n\n// semantic version\nexport { VERSION } from \"./version.js\";\n\nexport {\n  CstParser,\n  EmbeddedActionsParser,\n  ParserDefinitionErrorType,\n  EMPTY_ALT,\n} from \"./parse/parser/parser.js\";\n\nexport { Lexer, LexerDefinitionErrorType } from \"./scan/lexer_public.js\";\n\n// Tokens utilities\nexport {\n  createToken,\n  createTokenInstance,\n  EOF,\n  tokenLabel,\n  tokenMatcher,\n  tokenName,\n} from \"./scan/tokens_public.js\";\n\n// Lookahead\n\nexport { getLookaheadPaths } from \"./parse/grammar/lookahead.js\";\n\nexport { LLkLookaheadStrategy } from \"./parse/grammar/llk_lookahead.js\";\n\n// Other Utilities\n\nexport { defaultParserErrorProvider } from \"./parse/errors_public.js\";\n\nexport {\n  EarlyExitException,\n  isRecognitionException,\n  MismatchedTokenException,\n  NotAllInputParsedException,\n  NoViableAltException,\n} from \"./parse/exceptions_public.js\";\n\nexport { defaultLexerErrorProvider } from \"./scan/lexer_errors_public.js\";\n\n// grammar reflection API\nexport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n} from \"@chevrotain/gast\";\n\n// GAST Utilities\n\nexport {\n  serializeGrammar,\n  serializeProduction,\n  GAstVisitor,\n} from \"@chevrotain/gast\";\n\nexport { generateCstDts } from \"@chevrotain/cst-dts-gen\";\n\n/* istanbul ignore next */\nexport function clearCache() {\n  console.warn(\n    \"The clearCache function was 'soft' removed from the Chevrotain API.\" +\n      \"\\n\\t It performs no action other than printing this message.\" +\n      \"\\n\\t Please avoid using it as it will be completely removed in the future\",\n  );\n}\n\nexport { createSyntaxDiagramsCode } from \"./diagrams/render_public.js\";\n\nexport class Parser {\n  constructor() {\n    throw new Error(\n      \"The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.\\t\\n\" +\n        \"See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0\",\n    );\n  }\n}\n"],"names":[],"mappings":"AAAA,uFAAA,EAAyF,CAEzF,mBAAmB;;;;;;;;;;;;;;;;;AAmEb,SAAU,UAAU;IACxB,OAAO,CAAC,IAAI,CACV,qEAAqE,GACnE,8DAA8D,GAC9D,2EAA2E,CAC9E,CAAC;AACJ,CAAC;;AAIK,MAAO,MAAM;IACjB,aAAA;QACE,MAAM,IAAI,KAAK,CACb,2FAA2F,GACzF,sEAAsE,CACzE,CAAC;IACJ,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 6705, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}