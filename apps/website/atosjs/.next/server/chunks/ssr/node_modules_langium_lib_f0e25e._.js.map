{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"syntax-tree.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/syntax-tree.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { TokenType } from 'chevrotain';\nimport type { URI } from './utils/uri-utils.js';\nimport type { AbstractElement } from './languages/generated/ast.js';\nimport type { DocumentSegment, LangiumDocument } from './workspace/documents.js';\n\n/**\n * A node in the Abstract Syntax Tree (AST).\n */\nexport interface AstNode {\n    /** Every AST node has a type corresponding to what was specified in the grammar declaration. */\n    readonly $type: string;\n    /** The container node in the AST; every node except the root node has a container. */\n    readonly $container?: AstNode;\n    /** The property of the `$container` node that contains this node. This is either a direct reference or an array. */\n    readonly $containerProperty?: string;\n    /** In case `$containerProperty` is an array, the array index is stored here. */\n    readonly $containerIndex?: number;\n    /** The Concrete Syntax Tree (CST) node of the text range from which this node was parsed. */\n    readonly $cstNode?: CstNode;\n    /** The document containing the AST; only the root node has a direct reference to the document. */\n    readonly $document?: LangiumDocument;\n}\n\nexport function isAstNode(obj: unknown): obj is AstNode {\n    return typeof obj === 'object' && obj !== null && typeof (obj as AstNode).$type === 'string';\n}\n\nexport interface GenericAstNode extends AstNode {\n    [key: string]: unknown\n}\n\ntype SpecificNodeProperties<N extends AstNode> = keyof Omit<N, keyof AstNode | number | symbol>;\n\n/**\n * The property names of a given AST node type.\n */\nexport type Properties<N extends AstNode> = SpecificNodeProperties<N> extends never ? string : SpecificNodeProperties<N>\n\n/**\n * A cross-reference in the AST. Cross-references may or may not be successfully resolved.\n */\nexport interface Reference<T extends AstNode = AstNode> {\n    /**\n     * The target AST node of this reference. Accessing this property may trigger cross-reference\n     * resolution by the `Linker` in case it has not been done yet. If the reference cannot be resolved,\n     * the value is `undefined`.\n     */\n    readonly ref?: T;\n\n    /** If any problem occurred while resolving the reference, it is described by this property. */\n    readonly error?: LinkingError;\n    /** The CST node from which the reference was parsed */\n    readonly $refNode?: CstNode;\n    /** The actual text used to look up in the surrounding scope */\n    readonly $refText: string;\n    /** The node description for the AstNode returned by `ref`  */\n    readonly $nodeDescription?: AstNodeDescription;\n}\n\nexport function isReference(obj: unknown): obj is Reference {\n    return typeof obj === 'object' && obj !== null && typeof (obj as Reference).$refText === 'string';\n}\n\nexport type ResolvedReference<T extends AstNode = AstNode> = Reference<T> & {\n    readonly ref: T;\n}\n\n/**\n * A description of an AST node is used when constructing scopes and looking up cross-reference targets.\n */\nexport interface AstNodeDescription {\n    /** The target node; should be present only for local references (linking to the same document). */\n    node?: AstNode;\n    /**\n     * The document segment that represents the range of the name of the AST node.\n     */\n    nameSegment?: DocumentSegment;\n    /**\n     * The document segment that represents the full range of the AST node.\n     */\n    selectionSegment?: DocumentSegment;\n    /** `$type` property value of the AST node */\n    type: string;\n    /** Name of the AST node; this is usually determined by the `NameProvider` service. */\n    name: string;\n    /** URI to the document containing the AST node */\n    documentUri: URI;\n    /** Navigation path inside the document */\n    path: string;\n}\n\nexport function isAstNodeDescription(obj: unknown): obj is AstNodeDescription {\n    return typeof obj === 'object' && obj !== null\n        && typeof (obj as AstNodeDescription).name === 'string'\n        && typeof (obj as AstNodeDescription).type === 'string'\n        && typeof (obj as AstNodeDescription).path === 'string';\n}\n\n/**\n * Information about a cross-reference. This is used when traversing references in an AST or to describe\n * unresolved references.\n */\nexport interface ReferenceInfo {\n    reference: Reference\n    container: AstNode\n    property: string\n    index?: number\n}\n\n/**\n * Used to collect information when the `Linker` service fails to resolve a cross-reference.\n */\nexport interface LinkingError extends ReferenceInfo {\n    message: string;\n    targetDescription?: AstNodeDescription;\n}\n\nexport function isLinkingError(obj: unknown): obj is LinkingError {\n    return typeof obj === 'object' && obj !== null\n        && isAstNode((obj as LinkingError).container)\n        && isReference((obj as LinkingError).reference)\n        && typeof (obj as LinkingError).message === 'string';\n}\n\n/**\n * Service used for generic access to the structure of the AST. This service is shared between\n * all involved languages, so it operates on the superset of types of these languages.\n */\nexport interface AstReflection {\n    getAllTypes(): string[]\n    getAllSubTypes(type: string): string[]\n    getReferenceType(refInfo: ReferenceInfo): string\n    getTypeMetaData(type: string): TypeMetaData\n    isInstance(node: unknown, type: string): boolean\n    isSubtype(subtype: string, supertype: string): boolean\n}\n\n/**\n * An abstract implementation of the {@link AstReflection} interface.\n * Serves to cache subtype computation results to improve performance throughout different parts of Langium.\n */\nexport abstract class AbstractAstReflection implements AstReflection {\n\n    protected subtypes: Record<string, Record<string, boolean | undefined>> = {};\n    protected allSubtypes: Record<string, string[] | undefined> = {};\n\n    abstract getAllTypes(): string[];\n    abstract getReferenceType(refInfo: ReferenceInfo): string;\n    abstract getTypeMetaData(type: string): TypeMetaData;\n    protected abstract computeIsSubtype(subtype: string, supertype: string): boolean;\n\n    isInstance(node: unknown, type: string): boolean {\n        return isAstNode(node) && this.isSubtype(node.$type, type);\n    }\n\n    isSubtype(subtype: string, supertype: string): boolean {\n        if (subtype === supertype) {\n            return true;\n        }\n        let nested = this.subtypes[subtype];\n        if (!nested) {\n            nested = this.subtypes[subtype] = {};\n        }\n        const existing = nested[supertype];\n        if (existing !== undefined) {\n            return existing;\n        } else {\n            const result = this.computeIsSubtype(subtype, supertype);\n            nested[supertype] = result;\n            return result;\n        }\n    }\n\n    getAllSubTypes(type: string): string[] {\n        const existing = this.allSubtypes[type];\n        if (existing) {\n            return existing;\n        } else {\n            const allTypes = this.getAllTypes();\n            const types: string[] = [];\n            for (const possibleSubType of allTypes) {\n                if (this.isSubtype(possibleSubType, type)) {\n                    types.push(possibleSubType);\n                }\n            }\n            this.allSubtypes[type] = types;\n            return types;\n        }\n    }\n}\n\n/**\n * Represents runtime meta data about a meta model type.\n */\nexport interface TypeMetaData {\n    /** The name of this meta model type. Corresponds to the `AstNode.$type` value. */\n    name: string\n    /** A list of properties. They can contain default values for their respective property in the AST. */\n    properties: TypeProperty[]\n}\n\n/**\n * Describes the meta data of a property of an AST node.\n *\n * The optional `defaultValue` indicates that the property is mandatory in the AST node.\n * For example, if an AST node contains an array, but no elements of this array have been parsed, we still expect an empty array instead of `undefined`.\n */\nexport interface TypeProperty {\n    name: string\n    defaultValue?: PropertyType\n}\n\n/**\n * Represents a default value for an AST property.\n */\nexport type PropertyType = number | string | boolean | PropertyType[];\n\n/**\n * A node in the Concrete Syntax Tree (CST).\n */\nexport interface CstNode extends DocumentSegment {\n    /** The container node in the CST */\n    readonly container?: CompositeCstNode;\n    /** @deprecated use `container` instead. */\n    readonly parent?: CompositeCstNode;\n    /** The actual text */\n    readonly text: string;\n    /** The root CST node */\n    readonly root: RootCstNode;\n    /** The grammar element from which this node was parsed */\n    readonly grammarSource: AbstractElement;\n    /** @deprecated use `grammarSource` instead. */\n    readonly feature: AbstractElement;\n    /** The AST node created from this CST node */\n    readonly astNode: AstNode;\n    /** @deprecated use `astNode` instead. */\n    readonly element: AstNode;\n    /** Whether the token is hidden, i.e. not explicitly part of the containing grammar rule */\n    readonly hidden: boolean;\n}\n\n/**\n * A composite CST node contains other nodes, but no directly associated token.\n */\nexport interface CompositeCstNode extends CstNode {\n    readonly content: CstNode[];\n    /** @deprecated use `content` instead. */\n    readonly children: CstNode[];\n}\n\nexport function isCompositeCstNode(node: unknown): node is CompositeCstNode {\n    return typeof node === 'object' && node !== null && Array.isArray((node as CompositeCstNode).content);\n}\n\n/**\n * A leaf CST node corresponds to a token in the input token stream.\n */\nexport interface LeafCstNode extends CstNode {\n    readonly tokenType: TokenType;\n}\n\nexport function isLeafCstNode(node: unknown): node is LeafCstNode {\n    return typeof node === 'object' && node !== null && typeof (node as LeafCstNode).tokenType === 'object';\n}\n\nexport interface RootCstNode extends CompositeCstNode {\n    readonly fullText: string\n}\n\nexport function isRootCstNode(node: unknown): node is RootCstNode {\n    return isCompositeCstNode(node) && typeof (node as RootCstNode).fullText === 'string';\n}\n\n/**\n * Returns a type to have only properties names (!) of a type T whose property value is of a certain type K.\n */\ntype ExtractKeysOfValueType<T, K> = { [I in keyof T]: T[I] extends K ? I : never }[keyof T];\n\n/**\n * Returns the property names (!) of an AstNode that are cross-references.\n * Meant to be used during cross-reference resolution in combination with `assertUnreachable(context.property)`.\n */\nexport type CrossReferencesOfAstNodeType<N extends AstNode> = (\n    ExtractKeysOfValueType<N, Reference|undefined>\n    | ExtractKeysOfValueType<N, Array<Reference|undefined>|undefined>\n// eslint-disable-next-line @typescript-eslint/ban-types\n) & {};\n\n/**\n * Represents the enumeration-like type, that lists all AstNode types of your grammar.\n */\nexport type AstTypeList<T> = Record<keyof T, AstNode>;\n\n/**\n * Returns all types that contain cross-references, A is meant to be the interface `XXXAstType` fromm your generated `ast.ts` file.\n * Meant to be used during cross-reference resolution in combination with `assertUnreachable(context.container)`.\n */\nexport type AstNodeTypesWithCrossReferences<A extends AstTypeList<A>> = {\n    [T in keyof A]: CrossReferencesOfAstNodeType<A[T]> extends never ? never : A[T]\n}[keyof A];\n\nexport type Mutable<T> = {\n    -readonly [P in keyof T]: T[P]\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 90, "column": 0}, "map": {"version":3,"file":"stream.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/stream.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/**\n * A stream is a read-only sequence of values. While the contents of an array can be accessed\n * both sequentially and randomly (via index), a stream allows only sequential access.\n *\n * The advantage of this is that a stream can be evaluated lazily, so it does not require\n * to store intermediate values. This can boost performance when a large sequence is\n * processed via filtering, mapping etc. and accessed at most once. However, lazy\n * evaluation means that all processing is repeated when you access the sequence multiple\n * times; in such a case, it may be better to store the resulting sequence into an array.\n */\nexport interface Stream<T> extends Iterable<T> {\n\n    /**\n     * Returns an iterator for this stream. This is the same as calling the `Symbol.iterator` function property.\n     */\n    iterator(): IterableIterator<T>;\n\n    /**\n     * Determines whether this stream contains no elements.\n     */\n    isEmpty(): boolean;\n\n    /**\n     * Determines the number of elements in this stream.\n     */\n    count(): number;\n\n    /**\n     * Collects all elements of this stream into an array.\n     */\n    toArray(): T[];\n\n    /**\n     * Collects all elements of this stream into a Set.\n     */\n    toSet(): Set<T>;\n\n    /**\n     * Collects all elements of this stream into a Map, applying the provided functions to determine keys and values.\n     *\n     * @param keyFn The function to derive map keys. If omitted, the stream elements are used as keys.\n     * @param valueFn The function to derive map values. If omitted, the stream elements are used as values.\n     */\n    toMap<K = T, V = T>(keyFn?: (e: T) => K, valueFn?: (e: T) => V): Map<K, V>;\n\n    /**\n     * Returns a string representation of a stream.\n     */\n    toString(): string;\n\n    /**\n     * Combines two streams by returning a new stream that yields all elements of this stream and the other stream.\n     *\n     * @param other Stream to be concatenated with this one.\n     */\n    concat<T2>(other: Iterable<T2>): Stream<T | T2>;\n\n    /**\n     * Adds all elements of the stream into a string, separated by the specified separator string.\n     *\n     * @param separator A string used to separate one element of the stream from the next in the resulting string.\n     *        If omitted, the steam elements are separated with a comma.\n     */\n    join(separator?: string): string\n\n    /**\n     * Returns the index of the first occurrence of a value in the stream, or -1 if it is not present.\n     *\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The stream index at which to begin the search. If fromIndex is omitted, the search\n     *        starts at index 0.\n     */\n    indexOf(searchElement: T, fromIndex?: number): number;\n\n    /**\n     * Determines whether all members of the stream satisfy the specified test.\n     *\n     * @param predicate This method calls the predicate function for each element in the stream until the\n     *        predicate returns a value which is coercible to the Boolean value `false`, or until the end\n     *        of the stream.\n     */\n    every<S extends T>(predicate: (value: T) => value is S): this is Stream<S>;\n    every(predicate: (value: T) => unknown): boolean;\n\n    /**\n     * Determines whether any member of the stream satisfies the specified test.\n     *\n     * @param predicate This method calls the predicate function for each element in the stream until the\n     *        predicate returns a value which is coercible to the Boolean value `true`, or until the end\n     *        of the stream.\n     */\n    some(predicate: (value: T) => unknown): boolean;\n\n    /**\n     * Performs the specified action for each element in the stream.\n     *\n     * @param callbackfn Function called once for each element in the stream.\n     */\n    forEach(callbackfn: (value: T, index: number) => void): void;\n\n    /**\n     * Returns a stream that yields the results of calling the specified callback function on each element\n     * of the stream. The function is called when the resulting stream elements are actually accessed, so\n     * accessing the resulting stream multiple times means the function is also called multiple times for\n     * each element of the stream.\n     *\n     * @param callbackfn Lazily evaluated function mapping stream elements.\n     */\n    map<U>(callbackfn: (value: T) => U): Stream<U>;\n\n    /**\n     * Returns the elements of the stream that meet the condition specified in a callback function.\n     * The function is called when the resulting stream elements are actually accessed, so accessing the\n     * resulting stream multiple times means the function is also called multiple times for each element\n     * of the stream.\n     *\n     * @param predicate Lazily evaluated function checking a condition on stream elements.\n     */\n    filter<S extends T>(predicate: (value: T) => value is S): Stream<S>;\n    filter(predicate: (value: T) => unknown): Stream<T>;\n\n    /**\n     * Returns the elements of the stream that are _non-nullable_, which means they are neither `undefined`\n     * nor `null`.\n     */\n    nonNullable(): Stream<NonNullable<T>>;\n\n    /**\n     * Calls the specified callback function for all elements in the stream. The return value of the\n     * callback function is the accumulated result, and is provided as an argument in the next call to\n     * the callback function.\n     *\n     * @param callbackfn This method calls the function once for each element in the stream, providing\n     *        the previous and current values of the reduction.\n     * @param initialValue If specified, `initialValue` is used as the initial value to start the\n     *        accumulation. The first call to the function provides this value as an argument instead\n     *        of a stream value.\n     */\n    reduce(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\n    reduce<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\n\n    /**\n     * Calls the specified callback function for all elements in the stream, in descending order.\n     * The return value of the callback function is the accumulated result, and is provided as an\n     * argument in the next call to the callback function.\n     *\n     * @param callbackfn This method calls the function once for each element in the stream, providing\n     *        the previous and current values of the reduction.\n     * @param initialValue If specified, `initialValue` is used as the initial value to start the\n     *        accumulation. The first call to the function provides this value as an argument instead\n     *        of an array value.\n     */\n    reduceRight(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\n    reduceRight<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\n\n    /**\n     * Returns the value of the first element in the stream that meets the condition, or `undefined`\n     * if there is no such element.\n     *\n     * @param predicate This method calls `predicate` once for each element of the stream, in ascending\n     *        order, until it finds one where `predicate` returns a value which is coercible to the\n     *        Boolean value `true`.\n     */\n    find<S extends T>(predicate: (value: T) => value is S): S | undefined;\n    find(predicate: (value: T) => unknown): T | undefined;\n\n    /**\n     * Returns the index of the first element in the stream that meets the condition, or `-1`\n     * if there is no such element.\n     *\n     * @param predicate This method calls `predicate` once for each element of the stream, in ascending\n     *        order, until it finds one where `predicate` returns a value which is coercible to the\n     *        Boolean value `true`.\n     */\n    findIndex(predicate: (value: T) => unknown): number;\n\n    /**\n     * Determines whether the stream includes a certain element, returning `true` or `false` as appropriate.\n     *\n     * @param searchElement The element to search for.\n     */\n    includes(searchElement: T): boolean;\n\n    /**\n     * Calls a defined callback function on each element of the stream and then flattens the result into\n     * a new stream. This is identical to a `map` followed by `flat` with depth 1.\n     *\n     * @param callbackfn Lazily evaluated function mapping stream elements.\n     */\n    flatMap<U>(callbackfn: (value: T) => U | Iterable<U>): Stream<U>;\n\n    /**\n     * Returns a new stream with all sub-stream or sub-array elements concatenated into it recursively up\n     * to the specified depth.\n     *\n     * @param depth The maximum recursion depth. Defaults to 1.\n     */\n    flat<D extends number = 1>(depth?: D): FlatStream<T, D>;\n\n    /**\n     * Returns the first element in the stream, or `undefined` if the stream is empty.\n     */\n    head(): T | undefined;\n\n    /**\n     * Returns a stream that skips the first `skipCount` elements from this stream.\n     *\n     * @param skipCount The number of elements to skip. If this is larger than the number of elements in\n     *        the stream, an empty stream is returned. Defaults to 1.\n     */\n    tail(skipCount?: number): Stream<T>;\n\n    /**\n     * Returns a stream consisting of the elements of this stream, truncated to be no longer than `maxSize`\n     * in length.\n     *\n     * @param maxSize The number of elements the stream should be limited to\n     */\n    limit(maxSize: number): Stream<T>;\n\n    /**\n     * Returns a stream containing only the distinct elements from this stream.\n     * Equality is determined with the same rules as a standard `Set`.\n     *\n     * @param by A function returning the key used to check equality with a previous stream element.\n     *        If omitted, the stream elements themselves are used for comparison.\n     */\n    distinct<Key = T>(by?: (element: T) => Key): Stream<T>;\n\n    /**\n     * Returns a stream that contains all elements that don't exist in the {@link other} iterable.\n     * Equality is determined with the same rules as a standard `Set`.\n     * @param other The elements that should be exluded from this stream.\n     * @param key A function returning the key used to check quality.\n     *        If omitted, the stream elements themselves are used for comparison.\n     */\n    exclude<Key = T>(other: Iterable<T>, key?: (element: T) => Key): Stream<T>;\n\n}\n\nexport type FlatStream<T, Depth extends number> = {\n    'done': Stream<T>,\n    'recur': T extends Iterable<infer Content>\n        ? FlatStream<Content, MinusOne<Depth>>\n        : Stream<T>\n}[Depth extends 0 ? 'done' : 'recur'];\n\nexport type MinusOne<N extends number> = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20][N];\n\n/**\n * The default implementation of `Stream` works with two input functions:\n *  - The first function creates the initial state of an iteration.\n *  - The second function gets the current state as argument and returns an `IteratorResult`.\n */\nexport class StreamImpl<S, T> implements Stream<T> {\n    protected readonly startFn: () => S;\n    protected readonly nextFn: (state: S) => IteratorResult<T>;\n\n    constructor(startFn: () => S, nextFn: (state: S) => IteratorResult<T, undefined>) {\n        this.startFn = startFn;\n        this.nextFn = nextFn;\n    }\n\n    iterator(): IterableIterator<T> {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return this.iterator();\n    }\n\n    isEmpty(): boolean {\n        const iterator = this.iterator();\n        return Boolean(iterator.next().done);\n    }\n\n    count(): number {\n        const iterator = this.iterator();\n        let count = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            count++;\n            next = iterator.next();\n        }\n        return count;\n    }\n\n    toArray(): T[] {\n        const result: T[] = [];\n        const iterator = this.iterator();\n        let next: IteratorResult<T>;\n        do {\n            next = iterator.next();\n            if (next.value !== undefined) {\n                result.push(next.value);\n            }\n        } while (!next.done);\n        return result;\n    }\n\n    toSet(): Set<T> {\n        return new Set(this);\n    }\n\n    toMap<K = T, V = T>(keyFn?: (e: T) => K, valueFn?: (e: T) => V): Map<K, V> {\n        const entryStream = this.map(element => <[K, V]>[\n            keyFn ? keyFn(element) : element,\n            valueFn ? valueFn(element) : element\n        ]);\n        return new Map(entryStream);\n    }\n\n    toString(): string {\n        return this.join();\n    }\n\n    concat<T2>(other: Iterable<T2>): Stream<T | T2> {\n        const iterator = other[Symbol.iterator]();\n        return new StreamImpl<{ first: S, firstDone: boolean }, T | T2>(\n            () => ({ first: this.startFn(), firstDone: false }),\n            state => {\n                let result: IteratorResult<T | T2>;\n                if (!state.firstDone) {\n                    do {\n                        result = this.nextFn(state.first);\n                        if (!result.done) {\n                            return result;\n                        }\n                    } while (!result.done);\n                    state.firstDone = true;\n                }\n                do {\n                    result = iterator.next();\n                    if (!result.done) {\n                        return result;\n                    }\n                } while (!result.done);\n                return DONE_RESULT;\n            }\n        );\n    }\n\n    join(separator = ','): string {\n        const iterator = this.iterator();\n        let value = '';\n        let result: IteratorResult<T>;\n        let addSeparator = false;\n        do {\n            result = iterator.next();\n            if (!result.done) {\n                if (addSeparator) {\n                    value += separator;\n                }\n                value += toString(result.value);\n            }\n            addSeparator = true;\n        } while (!result.done);\n        return value;\n    }\n\n    indexOf(searchElement: T, fromIndex = 0): number {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (index >= fromIndex && next.value === searchElement) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n\n    // In the following definition the '& this' part in the return type is important\n    // _and_ the order within 'Stream<U> & this' is crucial!\n    // Otherwise Typescript would infer the type of 'this' as 'StreamImpl<S, T> & Stream<U>'\n    // (or '<subClass of StreamImpl<S, T> & Stream<U>') and usages like\n    // ```\n    //  const stream = new StreamImpl(...);\n    //  ... stream.every(<typeGuard>) & stream....\n    // ```\n    // cannot benefit from '<typeGuard>', as Typescript would priorize the signatures\n    // of 'StreamImpl<S, T>' (i.e. those of 'Stream<T>') over those of 'Stream<U>'.\n    // With the order of 'Stream<U> & this' the signatures of 'Stream<U>' get precedence.\n    every<U extends T>(predicate: (value: T) => value is U): this is Stream<U> & this;\n    every(predicate: (value: T) => unknown): boolean;\n    every(predicate: (value: T) => unknown): boolean {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (!predicate(next.value)) {\n                return false;\n            }\n            next = iterator.next();\n        }\n        return true;\n    }\n\n    some(predicate: (value: T) => unknown): boolean {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n\n    forEach(callbackfn: (value: T, index: number) => void): void {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            callbackfn(next.value, index);\n            next = iterator.next();\n            index++;\n        }\n    }\n\n    map<U>(callbackfn: (value: T) => U): Stream<U> {\n        return new StreamImpl<S, U>(\n            this.startFn,\n            (state) => {\n                const { done, value } = this.nextFn(state);\n                if (done) {\n                    return DONE_RESULT;\n                } else {\n                    return { done: false, value: callbackfn(value) };\n                }\n            }\n        );\n    }\n\n    // for remarks on the return type definition refer to 'every<U extends T>(...)'\n    filter<U extends T>(predicate: (value: T) => value is U): Stream<U> & this;\n    filter(predicate: (value: T) => unknown): Stream<T> & this;\n    filter(predicate: (value: T) => unknown): Stream<T> {\n        return new StreamImpl<S, T>(\n            this.startFn,\n            state => {\n                let result: IteratorResult<T>;\n                do {\n                    result = this.nextFn(state);\n                    if (!result.done && predicate(result.value)) {\n                        return result;\n                    }\n                } while (!result.done);\n                return DONE_RESULT;\n            }\n        );\n    }\n\n    nonNullable(): Stream<NonNullable<T>> {\n        return this.filter(e => e !== undefined && e !== null) as Stream<NonNullable<T>>;\n    }\n\n    reduce(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\n    reduce<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\n    reduce<U>(callbackfn: (previousValue: U | T, currentValue: T) => U, initialValue?: U): U | T | undefined {\n        const iterator = this.iterator();\n        let previousValue: U | T | undefined = initialValue;\n        let next = iterator.next();\n        while (!next.done) {\n            if (previousValue === undefined) {\n                previousValue = next.value;\n            } else {\n                previousValue = callbackfn(previousValue, next.value);\n            }\n            next = iterator.next();\n        }\n        return previousValue;\n    }\n\n    reduceRight(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\n    reduceRight<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\n    reduceRight<U>(callbackfn: (previousValue: U | T, currentValue: T) => U, initialValue?: U): U | T | undefined {\n        return this.recursiveReduce(this.iterator(), callbackfn, initialValue);\n    }\n\n    protected recursiveReduce<U>(iterator: Iterator<T>, callbackfn: (previousValue: U | T, currentValue: T) => U, initialValue?: U): U | T | undefined {\n        const next = iterator.next();\n        if (next.done) {\n            return initialValue;\n        }\n        const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);\n        if (previousValue === undefined) {\n            return next.value;\n        }\n        return callbackfn(previousValue, next.value);\n    }\n\n    find<S extends T>(predicate: (value: T) => value is S): S | undefined;\n    find(predicate: (value: T) => unknown): T | undefined;\n    find(predicate: (value: T) => unknown): T | undefined {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return next.value;\n            }\n            next = iterator.next();\n        }\n        return undefined;\n    }\n\n    findIndex(predicate: (value: T) => unknown): number {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n\n    includes(searchElement: T): boolean {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (next.value === searchElement) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n\n    flatMap<U>(callbackfn: (value: T) => U | Iterable<U>): Stream<U> {\n        type FlatMapState = { this: S, iterator?: Iterator<U, undefined> }\n        return new StreamImpl<FlatMapState, U>(\n            () => ({ this: this.startFn() }),\n            (state) => {\n                do {\n                    if (state.iterator) {\n                        const next = state.iterator.next();\n                        if (next.done) {\n                            state.iterator = undefined;\n                        } else {\n                            return next;\n                        }\n                    }\n                    const { done, value } = this.nextFn(state.this);\n                    if (!done) {\n                        const mapped = callbackfn(value);\n                        if (isIterable(mapped)) {\n                            state.iterator = mapped[Symbol.iterator]();\n                        } else {\n                            return { done: false, value: mapped };\n                        }\n                    }\n                } while (state.iterator);\n                return DONE_RESULT;\n            }\n        );\n    }\n\n    flat<D extends number = 1>(depth?: D): FlatStream<T, D> {\n        if (depth === undefined) {\n            depth = 1 as D;\n        }\n        if (depth <= 0) {\n            return this as unknown as FlatStream<T, D>;\n        }\n        const stream = depth > 1 ? this.flat(depth - 1) as unknown as StreamImpl<S, T> : this;\n        type FlatMapState = { this: S, iterator?: Iterator<T, undefined> }\n        return new StreamImpl<FlatMapState, T>(\n            () => ({ this: stream.startFn() }),\n            (state) => {\n                do {\n                    if (state.iterator) {\n                        const next = state.iterator.next();\n                        if (next.done) {\n                            state.iterator = undefined;\n                        } else {\n                            return next;\n                        }\n                    }\n                    const { done, value } = stream.nextFn(state.this);\n                    if (!done) {\n                        if (isIterable(value)) {\n                            state.iterator = value[Symbol.iterator]() as Iterator<T>;\n                        } else {\n                            return { done: false, value: value };\n                        }\n                    }\n                } while (state.iterator);\n                return DONE_RESULT;\n            }\n        ) as unknown as FlatStream<T, D>;\n    }\n\n    head(): T | undefined {\n        const iterator = this.iterator();\n        const result = iterator.next();\n        if (result.done) {\n            return undefined;\n        }\n        return result.value;\n    }\n\n    tail(skipCount = 1): Stream<T> {\n        return new StreamImpl<S, T>(\n            () => {\n                const state = this.startFn();\n                for (let i = 0; i < skipCount; i++) {\n                    const next = this.nextFn(state);\n                    if (next.done) {\n                        return state;\n                    }\n                }\n                return state;\n            },\n            this.nextFn\n        );\n    }\n\n    limit(maxSize: number): Stream<T> {\n        return new StreamImpl<{ size: number, state: S }, T>(\n            () => ({ size: 0, state: this.startFn() }),\n            state => {\n                state.size++;\n                if (state.size > maxSize) {\n                    return DONE_RESULT;\n                }\n                return this.nextFn(state.state);\n            }\n        );\n    }\n\n    distinct<Key = T>(by?: (element: T) => Key): Stream<T> {\n        const set = new Set<T | Key>();\n        return this.filter(e => {\n            const value = by ? by(e) : e;\n            if (set.has(value)) {\n                return false;\n            } else {\n                set.add(value);\n                return true;\n            }\n        });\n    }\n\n    exclude<Key = T>(other: Iterable<T>, key?: (element: T) => Key): Stream<T> {\n        const otherKeySet = new Set<Key | T>();\n        for (const item of other) {\n            const value = key ? key(item) : item;\n            otherKeySet.add(value);\n        }\n        return this.filter(e => {\n            const ownKey = key ? key(e) : e;\n            return !otherKeySet.has(ownKey);\n        });\n    }\n}\n\nfunction toString(item: unknown): string {\n    if (typeof item === 'string') {\n        return item as string;\n    }\n    if (typeof item === 'undefined') {\n        return 'undefined';\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (typeof (item as any).toString === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (item as any).toString();\n    }\n    return Object.prototype.toString.call(item);\n}\n\nfunction isIterable<T>(obj: unknown): obj is Iterable<T> {\n    return !!obj && typeof (obj as Iterable<T>)[Symbol.iterator] === 'function';\n}\n\n/**\n * An empty stream of any type.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const EMPTY_STREAM: Stream<any> = new StreamImpl<undefined, any>(() => undefined, () => DONE_RESULT);\n\n/**\n * Use this `IteratorResult` when implementing a `StreamImpl` to indicate that there are no more elements in the stream.\n */\nexport const DONE_RESULT: IteratorReturnResult<undefined> = Object.freeze({ done: true, value: undefined });\n\n/**\n * Create a stream from one or more iterables or array-likes.\n */\nexport function stream<T>(...collections: Array<Iterable<T> | ArrayLike<T>>): Stream<T> {\n    if (collections.length === 1) {\n        const collection = collections[0];\n        if (collection instanceof StreamImpl) {\n            return collection as Stream<T>;\n        }\n        if (isIterable(collection)) {\n            return new StreamImpl<Iterator<T, undefined>, T>(\n                () => collection[Symbol.iterator](),\n                (iterator) => iterator.next()\n            );\n        }\n        if (typeof collection.length === 'number') {\n            return new StreamImpl<{ index: number }, T>(\n                () => ({ index: 0 }),\n                (state) => {\n                    if (state.index < collection.length) {\n                        return { done: false, value: collection[state.index++] };\n                    } else {\n                        return DONE_RESULT;\n                    }\n                }\n            );\n        }\n    }\n    if (collections.length > 1) {\n        type State = { collIndex: number, iterator?: Iterator<T, undefined>, array?: ArrayLike<T>, arrIndex: number };\n        return new StreamImpl<State, T>(\n            () => ({ collIndex: 0, arrIndex: 0 }),\n            (state) => {\n                do {\n                    if (state.iterator) {\n                        const next = state.iterator.next();\n                        if (!next.done) {\n                            return next;\n                        }\n                        state.iterator = undefined;\n                    }\n                    if (state.array) {\n                        if (state.arrIndex < state.array.length) {\n                            return { done: false, value: state.array[state.arrIndex++] };\n                        }\n                        state.array = undefined;\n                        state.arrIndex = 0;\n                    }\n                    if (state.collIndex < collections.length) {\n                        const collection = collections[state.collIndex++];\n                        if (isIterable(collection)) {\n                            state.iterator = collection[Symbol.iterator]();\n                        } else if (collection && typeof collection.length === 'number') {\n                            state.array = collection;\n                        }\n                    }\n                } while (state.iterator || state.array || state.collIndex < collections.length);\n                return DONE_RESULT;\n            }\n        );\n    }\n    return EMPTY_STREAM;\n}\n\n/**\n * A tree iterator adds the ability to prune the current iteration.\n */\nexport interface TreeIterator<T> extends IterableIterator<T> {\n    /**\n     * Skip the whole subtree below the last returned element. The iteration continues as if that\n     * element had no children.\n     */\n    prune(): void\n}\n\n/**\n * A tree stream is used to stream the elements of a tree, for example an AST or CST.\n */\nexport interface TreeStream<T> extends Stream<T> {\n    iterator(): TreeIterator<T>\n}\n\n/**\n * The default implementation of `TreeStream` takes a root element and a function that computes the\n * children of its argument. Whether the root node included in the stream is controlled with the\n * `includeRoot` option, which defaults to `false`.\n */\nexport class TreeStreamImpl<T>\n    extends StreamImpl<{ iterators: Array<Iterator<T>>, pruned: boolean }, T>\n    implements TreeStream<T> {\n\n    constructor(root: T, children: (node: T) => Iterable<T>, options?: { includeRoot?: boolean }) {\n        super(\n            () => ({\n                iterators: options?.includeRoot ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],\n                pruned: false\n            }),\n            state => {\n                if (state.pruned) {\n                    state.iterators.pop();\n                    state.pruned = false;\n                }\n                while (state.iterators.length > 0) {\n                    const iterator = state.iterators[state.iterators.length - 1];\n                    const next = iterator.next();\n                    if (next.done) {\n                        state.iterators.pop();\n                    } else {\n                        state.iterators.push(children(next.value)[Symbol.iterator]());\n                        return next;\n                    }\n                }\n                return DONE_RESULT;\n            }\n        );\n    }\n\n    override iterator(): TreeIterator<T> {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            prune: () => {\n                iterator.state.pruned = true;\n            },\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n}\n\n/**\n * A set of utility functions that reduce a stream to a single value.\n */\nexport namespace Reduction {\n\n    /**\n     * Compute the sum of a number stream.\n     */\n    export function sum(stream: Stream<number>): number {\n        return stream.reduce((a, b) => a + b, 0);\n    }\n\n    /**\n     * Compute the product of a number stream.\n     */\n    export function product(stream: Stream<number>): number {\n        return stream.reduce((a, b) => a * b, 0);\n    }\n\n    /**\n     * Compute the minimum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    export function min(stream: Stream<number>): number | undefined {\n        return stream.reduce((a, b) => Math.min(a, b));\n    }\n\n    /**\n     * Compute the maximum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    export function max(stream: Stream<number>): number | undefined {\n        return stream.reduce((a, b) => Math.max(a, b));\n    }\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 610, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 616, "column": 0}, "map": {"version":3,"file":"cst-utils.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/cst-utils.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { IToken } from '@chevrotain/types';\nimport type { Range } from 'vscode-languageserver-types';\nimport type { CstNode, CompositeCstNode, LeafCstNode } from '../syntax-tree.js';\nimport type { DocumentSegment } from '../workspace/documents.js';\nimport type { Stream, TreeStream } from './stream.js';\nimport { isCompositeCstNode, isLeafCstNode, isRootCstNode } from '../syntax-tree.js';\nimport { TreeStreamImpl } from './stream.js';\n\n/**\n * Create a stream of all CST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nexport function streamCst(node: CstNode): TreeStream<CstNode> {\n    return new TreeStreamImpl(node, element => {\n        if (isCompositeCstNode(element)) {\n            return element.content;\n        } else {\n            return [];\n        }\n    }, { includeRoot: true });\n}\n\n/**\n * Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.\n */\nexport function flattenCst(node: CstNode): Stream<LeafCstNode> {\n    return streamCst(node).filter(isLeafCstNode);\n}\n\n/**\n * Determines whether the specified cst node is a child of the specified parent node.\n */\nexport function isChildNode(child: CstNode, parent: CstNode): boolean {\n    while (child.container) {\n        child = child.container;\n        if (child === parent) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function tokenToRange(token: IToken): Range {\n    // Chevrotain uses 1-based indices everywhere\n    // So we subtract 1 from every value to align with the LSP\n    return {\n        start: {\n            character: token.startColumn! - 1,\n            line: token.startLine! - 1\n        },\n        end: {\n            character: token.endColumn!, // endColumn uses the correct index\n            line: token.endLine! - 1\n        }\n    };\n}\n\nexport function toDocumentSegment(node: CstNode): DocumentSegment;\nexport function toDocumentSegment(node?: CstNode): DocumentSegment | undefined;\nexport function toDocumentSegment(node?: CstNode): DocumentSegment | undefined {\n    if (!node) {\n        return undefined;\n    }\n    const { offset, end, range } = node;\n    return {\n        range,\n        offset,\n        end,\n        length: end - offset\n    };\n}\n\nexport enum RangeComparison {\n    Before = 0,\n    After = 1,\n    OverlapFront = 2,\n    OverlapBack = 3,\n    Inside = 4\n}\n\nexport function compareRange(range: Range, to: Range): RangeComparison {\n    if (range.end.line < to.start.line || (range.end.line === to.start.line && range.end.character < range.start.character)) {\n        return RangeComparison.Before;\n    } else if (range.start.line > to.end.line || (range.start.line === to.end.line && range.start.character > to.end.character)) {\n        return RangeComparison.After;\n    }\n    const startInside = range.start.line > to.start.line || (range.start.line === to.start.line && range.start.character >= to.start.character);\n    const endInside = range.end.line < to.end.line || (range.end.line === to.end.line && range.end.character <= to.end.character);\n    if (startInside && endInside) {\n        return RangeComparison.Inside;\n    } else if (startInside) {\n        return RangeComparison.OverlapBack;\n    } else {\n        return RangeComparison.OverlapFront;\n    }\n}\n\nexport function inRange(range: Range, to: Range): boolean {\n    const comparison = compareRange(range, to);\n    return comparison > RangeComparison.After;\n}\n\n// The \\p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets\n// Together with \\w it matches any kind of character which can commonly appear in IDs\nexport const DefaultNameRegexp = /^[\\w\\p{L}]$/u;\n\n/**\n * Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,\n * it will instead return the leaf node at the `offset - 1` position.\n *\n * For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.\n */\nexport function findDeclarationNodeAtOffset(cstNode: CstNode | undefined, offset: number, nameRegexp = DefaultNameRegexp): LeafCstNode | undefined {\n    if (cstNode) {\n        if (offset > 0) {\n            const localOffset = offset - cstNode.offset;\n            const textAtOffset = cstNode.text.charAt(localOffset);\n            if (!nameRegexp.test(textAtOffset)) {\n                offset--;\n            }\n        }\n        return findLeafNodeAtOffset(cstNode, offset);\n    }\n    return undefined;\n}\n\nexport function findCommentNode(cstNode: CstNode | undefined, commentNames: string[]): CstNode | undefined {\n    if (cstNode) {\n        const previous = getPreviousNode(cstNode, true);\n        if (previous && isCommentNode(previous, commentNames)) {\n            return previous;\n        }\n        if (isRootCstNode(cstNode)) {\n            // Go from the first non-hidden node through all nodes in reverse order\n            // We do this to find the comment node which directly precedes the root node\n            const endIndex = cstNode.content.findIndex(e => !e.hidden);\n            for (let i = endIndex - 1; i >= 0; i--) {\n                const child = cstNode.content[i];\n                if (isCommentNode(child, commentNames)) {\n                    return child;\n                }\n            }\n        }\n    }\n    return undefined;\n}\n\nexport function isCommentNode(cstNode: CstNode, commentNames: string[]): boolean {\n    return isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\n}\n\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * Note that the given offset will be within the range of the returned leaf node.\n *\n * If the offset does not point to a CST node (but just white space), this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node at the specified offset.\n */\nexport function findLeafNodeAtOffset(node: CstNode, offset: number): LeafCstNode | undefined {\n    if (isLeafCstNode(node)) {\n        return node;\n    } else if (isCompositeCstNode(node)) {\n        const searchResult = binarySearch(node, offset, false);\n        if (searchResult) {\n            return findLeafNodeAtOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\n\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * If no CST node exists at the specified position, it will return the leaf node before it.\n *\n * If there is no leaf node before the specified offset, this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node closest to the specified offset.\n */\nexport function findLeafNodeBeforeOffset(node: CstNode, offset: number): LeafCstNode | undefined {\n    if (isLeafCstNode(node)) {\n        return node;\n    } else if (isCompositeCstNode(node)) {\n        const searchResult = binarySearch(node, offset, true);\n        if (searchResult) {\n            return findLeafNodeBeforeOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\n\nfunction binarySearch(node: CompositeCstNode, offset: number, closest: boolean): CstNode | undefined {\n    let left = 0;\n    let right = node.content.length - 1;\n    let closestNode: CstNode | undefined = undefined;\n\n    while (left <= right) {\n        const middle = Math.floor((left + right) / 2);\n        const middleNode = node.content[middle];\n\n        if (middleNode.offset <= offset && middleNode.end > offset) {\n            // Found an exact match\n            return middleNode;\n        }\n\n        if (middleNode.end <= offset) {\n            // Update the closest node (less than offset) and move to the right half\n            closestNode = closest ? middleNode : undefined;\n            left = middle + 1;\n        } else {\n            // Move to the left half\n            right = middle - 1;\n        }\n    }\n\n    return closestNode;\n}\n\nexport function getPreviousNode(node: CstNode, hidden = true): CstNode | undefined {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        while (index > 0) {\n            index--;\n            const previous = parent.content[index];\n            if (hidden || !previous.hidden) {\n                return previous;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\n\nexport function getNextNode(node: CstNode, hidden = true): CstNode | undefined {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        const last = parent.content.length - 1;\n        while (index < last) {\n            index++;\n            const next = parent.content[index];\n            if (hidden || !next.hidden) {\n                return next;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\n\nexport function getStartlineNode(node: CstNode): CstNode {\n    if (node.range.start.character === 0) {\n        return node;\n    }\n    const line = node.range.start.line;\n    let last = node;\n    let index: number | undefined;\n    while (node.container) {\n        const parent = node.container;\n        const selfIndex = index ?? parent.content.indexOf(node);\n        if (selfIndex === 0) {\n            node = parent;\n            index = undefined;\n        } else {\n            index = selfIndex - 1;\n            node = parent.content[index];\n        }\n        if (node.range.start.line !== line) {\n            break;\n        }\n        last = node;\n    }\n    return last;\n}\n\nexport function getInteriorNodes(start: CstNode, end: CstNode): CstNode[] {\n    const commonParent = getCommonParent(start, end);\n    if (!commonParent) {\n        return [];\n    }\n    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\n}\n\nfunction getCommonParent(a: CstNode, b: CstNode): CommonParent | undefined {\n    const aParents = getParentChain(a);\n    const bParents = getParentChain(b);\n    let current: CommonParent | undefined;\n    for (let i = 0; i < aParents.length && i < bParents.length; i++) {\n        const aParent = aParents[i];\n        const bParent = bParents[i];\n        if (aParent.parent === bParent.parent) {\n            current = {\n                parent: aParent.parent,\n                a: aParent.index,\n                b: bParent.index\n            };\n        } else {\n            break;\n        }\n    }\n    return current;\n}\n\ninterface CommonParent {\n    parent: CompositeCstNode\n    a: number\n    b: number\n}\n\nfunction getParentChain(node: CstNode): ParentLink[] {\n    const chain: ParentLink[] = [];\n    while (node.container) {\n        const parent = node.container;\n        const index = parent.content.indexOf(node);\n        chain.push({\n            parent,\n            index\n        });\n        node = parent;\n    }\n    return chain.reverse();\n}\n\ninterface ParentLink {\n    parent: CompositeCstNode\n    index: number\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;;;;;;;;;;;;;;;;;AAOhF,OAAO,EAAE,kBAAkB,EAAE,aAAa,EAAE,aAAa,EAAE,MAAM,mBAAmB,CAAC;AACrF,OAAO,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;;;AAMvC,SAAU,SAAS,CAAC,IAAa;IACnC,OAAO,iLAAI,iBAAc,CAAC,IAAI,GAAE,OAAO,CAAC,EAAE;QACtC,oLAAI,qBAAA,AAAkB,EAAC,OAAO,CAAC,EAAE;YAC7B,OAAO,OAAO,CAAC,OAAO,CAAC;SAC1B,MAAM;YACH,OAAO,EAAE,CAAC;SACb;IACL,CAAC,EAAE;QAAE,WAAW,EAAE,IAAI;IAAA,CAAE,CAAC,CAAC;AAC9B,CAAC;AAKK,SAAU,UAAU,CAAC,IAAa;IACpC,OAAO,SAAS,CAAC,IAAI,CAAC,CAAC,MAAM,6KAAC,gBAAa,CAAC,CAAC;AACjD,CAAC;AAKK,SAAU,WAAW,CAAC,KAAc,EAAE,MAAe;IACvD,MAAO,KAAK,CAAC,SAAS,CAAE;QACpB,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC;QACxB,IAAI,KAAK,KAAK,MAAM,EAAE;YAClB,OAAO,IAAI,CAAC;SACf;KACJ;IACD,OAAO,KAAK,CAAC;AACjB,CAAC;AAEK,SAAU,YAAY,CAAC,KAAa;IACtC,6CAA6C;IAC7C,0DAA0D;IAC1D,OAAO;QACH,KAAK,EAAE;YACH,SAAS,EAAE,KAAK,CAAC,WAAY,GAAG,CAAC;YACjC,IAAI,EAAE,KAAK,CAAC,SAAU,GAAG,CAAC;SAC7B;QACD,GAAG,EAAE;YACD,SAAS,EAAE,KAAK,CAAC,SAAU;YAC3B,IAAI,EAAE,KAAK,CAAC,OAAQ,GAAG,CAAC;SAC3B;KACJ,CAAC;AACN,CAAC;AAIK,SAAU,iBAAiB,CAAC,IAAc;IAC5C,IAAI,CAAC,IAAI,EAAE;QACP,OAAO,SAAS,CAAC;KACpB;IACD,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;IACpC,OAAO;QACH,KAAK;QACL,MAAM;QACN,GAAG;QACH,MAAM,EAAE,GAAG,GAAG,MAAM;KACvB,CAAC;AACN,CAAC;AAED,IAAY,eAMX;AAND,CAAA,SAAY,eAAe;IACvB,eAAA,CAAA,eAAA,CAAA,SAAA,GAAA,EAAA,GAAA,QAAU,CAAA;IACV,eAAA,CAAA,eAAA,CAAA,QAAA,GAAA,EAAA,GAAA,OAAS,CAAA;IACT,eAAA,CAAA,eAAA,CAAA,eAAA,GAAA,EAAA,GAAA,cAAgB,CAAA;IAChB,eAAA,CAAA,eAAA,CAAA,cAAA,GAAA,EAAA,GAAA,aAAe,CAAA;IACf,eAAA,CAAA,eAAA,CAAA,SAAA,GAAA,EAAA,GAAA,QAAU,CAAA;AACd,CAAC,EANW,eAAe,IAAA,CAAf,eAAe,GAAA,CAAA,CAAA,GAM1B;AAEK,SAAU,YAAY,CAAC,KAAY,EAAE,EAAS;IAChD,IAAI,KAAK,CAAC,GAAG,CAAC,IAAI,GAAG,EAAE,CAAC,KAAK,CAAC,IAAI,IAAI,AAAC,KAAK,CAAC,GAAG,CAAC,IAAI,KAAK,EAAE,CAAC,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,GAAG,CAAC,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAE;QACrH,OAAO,eAAe,CAAC,MAAM,CAAC;KACjC,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,GAAG,EAAE,CAAC,GAAG,CAAC,IAAI,IAAI,AAAC,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,EAAE,CAAC,GAAG,CAAC,IAAI,IAAI,KAAK,CAAC,KAAK,CAAC,SAAS,GAAG,EAAE,CAAC,GAAG,CAAC,SAAS,CAAC,CAAE;QACzH,OAAO,eAAe,CAAC,KAAK,CAAC;KAChC;IACD,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,GAAG,EAAE,CAAC,KAAK,CAAC,IAAI,IAAI,AAAC,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,EAAE,CAAC,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,KAAK,CAAC,SAAS,IAAI,EAAE,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IAC5I,MAAM,SAAS,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,GAAG,EAAE,CAAC,GAAG,CAAC,IAAI,IAAI,AAAC,KAAK,CAAC,GAAG,CAAC,IAAI,KAAK,EAAE,CAAC,GAAG,CAAC,IAAI,IAAI,KAAK,CAAC,GAAG,CAAC,SAAS,IAAI,EAAE,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;IAC9H,IAAI,WAAW,IAAI,SAAS,EAAE;QAC1B,OAAO,eAAe,CAAC,MAAM,CAAC;KACjC,MAAM,IAAI,WAAW,EAAE;QACpB,OAAO,eAAe,CAAC,WAAW,CAAC;KACtC,MAAM;QACH,OAAO,eAAe,CAAC,YAAY,CAAC;KACvC;AACL,CAAC;AAEK,SAAU,OAAO,CAAC,KAAY,EAAE,EAAS;IAC3C,MAAM,UAAU,GAAG,YAAY,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;IAC3C,OAAO,UAAU,GAAG,eAAe,CAAC,KAAK,CAAC;AAC9C,CAAC;AAIM,MAAM,iBAAiB,GAAG,cAAc,CAAC;AAQ1C,SAAU,2BAA2B,CAAC,OAA4B,EAAE,MAAc,EAAE,UAAU,GAAG,iBAAiB;IACpH,IAAI,OAAO,EAAE;QACT,IAAI,MAAM,GAAG,CAAC,EAAE;YACZ,MAAM,WAAW,GAAG,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;YAC5C,MAAM,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;YACtD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE;gBAChC,MAAM,EAAE,CAAC;aACZ;SACJ;QACD,OAAO,oBAAoB,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;KAChD;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAEK,SAAU,eAAe,CAAC,OAA4B,EAAE,YAAsB;IAChF,IAAI,OAAO,EAAE;QACT,MAAM,QAAQ,GAAG,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAChD,IAAI,QAAQ,IAAI,aAAa,CAAC,QAAQ,EAAE,YAAY,CAAC,EAAE;YACnD,OAAO,QAAQ,CAAC;SACnB;QACD,QAAI,4LAAA,AAAa,EAAC,OAAO,CAAC,EAAE;YACxB,uEAAuE;YACvE,4EAA4E;YAC5E,MAAM,QAAQ,GAAG,OAAO,CAAC,OAAO,CAAC,SAAS,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;YAC3D,IAAK,IAAI,CAAC,GAAG,QAAQ,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAE;gBACpC,MAAM,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBACjC,IAAI,aAAa,CAAC,KAAK,EAAE,YAAY,CAAC,EAAE;oBACpC,OAAO,KAAK,CAAC;iBAChB;aACJ;SACJ;KACJ;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAEK,SAAU,aAAa,CAAC,OAAgB,EAAE,YAAsB;IAClE,uLAAO,gBAAA,AAAa,EAAC,OAAO,CAAC,IAAI,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;AACnF,CAAC;AAYK,SAAU,oBAAoB,CAAC,IAAa,EAAE,MAAc;IAC9D,KAAI,+LAAA,AAAa,EAAC,IAAI,CAAC,EAAE;QACrB,OAAO,IAAI,CAAC;KACf,MAAM,oLAAI,qBAAA,AAAkB,EAAC,IAAI,CAAC,EAAE;QACjC,MAAM,YAAY,GAAG,YAAY,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;QACvD,IAAI,YAAY,EAAE;YACd,OAAO,oBAAoB,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;SACrD;KACJ;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAYK,SAAU,wBAAwB,CAAC,IAAa,EAAE,MAAc;IAClE,oLAAI,gBAAA,AAAa,EAAC,IAAI,CAAC,EAAE;QACrB,OAAO,IAAI,CAAC;KACf,MAAM,KAAI,oMAAA,AAAkB,EAAC,IAAI,CAAC,EAAE;QACjC,MAAM,YAAY,GAAG,YAAY,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;QACtD,IAAI,YAAY,EAAE;YACd,OAAO,wBAAwB,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;SACzD;KACJ;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAED,SAAS,YAAY,CAAC,IAAsB,EAAE,MAAc,EAAE,OAAgB;IAC1E,IAAI,IAAI,GAAG,CAAC,CAAC;IACb,IAAI,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;IACpC,IAAI,WAAW,GAAwB,SAAS,CAAC;IAEjD,MAAO,IAAI,IAAI,KAAK,CAAE;QAClB,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;QAC9C,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAExC,IAAI,UAAU,CAAC,MAAM,IAAI,MAAM,IAAI,UAAU,CAAC,GAAG,GAAG,MAAM,EAAE;YACxD,uBAAuB;YACvB,OAAO,UAAU,CAAC;SACrB;QAED,IAAI,UAAU,CAAC,GAAG,IAAI,MAAM,EAAE;YAC1B,wEAAwE;YACxE,WAAW,GAAG,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC;YAC/C,IAAI,GAAG,MAAM,GAAG,CAAC,CAAC;SACrB,MAAM;YACH,wBAAwB;YACxB,KAAK,GAAG,MAAM,GAAG,CAAC,CAAC;SACtB;KACJ;IAED,OAAO,WAAW,CAAC;AACvB,CAAC;AAEK,SAAU,eAAe,CAAC,IAAa,EAAE,MAAM,GAAG,IAAI;IACxD,MAAO,IAAI,CAAC,SAAS,CAAE;QACnB,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC;QAC9B,IAAI,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACzC,MAAO,KAAK,GAAG,CAAC,CAAE;YACd,KAAK,EAAE,CAAC;YACR,MAAM,QAAQ,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YACvC,IAAI,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;gBAC5B,OAAO,QAAQ,CAAC;aACnB;SACJ;QACD,IAAI,GAAG,MAAM,CAAC;KACjB;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAEK,SAAU,WAAW,CAAC,IAAa,EAAE,MAAM,GAAG,IAAI;IACpD,MAAO,IAAI,CAAC,SAAS,CAAE;QACnB,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC;QAC9B,IAAI,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACzC,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;QACvC,MAAO,KAAK,GAAG,IAAI,CAAE;YACjB,KAAK,EAAE,CAAC;YACR,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YACnC,IAAI,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;gBACxB,OAAO,IAAI,CAAC;aACf;SACJ;QACD,IAAI,GAAG,MAAM,CAAC;KACjB;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAEK,SAAU,gBAAgB,CAAC,IAAa;IAC1C,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,KAAK,CAAC,EAAE;QAClC,OAAO,IAAI,CAAC;KACf;IACD,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC;IACnC,IAAI,IAAI,GAAG,IAAI,CAAC;IAChB,IAAI,KAAyB,CAAC;IAC9B,MAAO,IAAI,CAAC,SAAS,CAAE;QACnB,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC;QAC9B,MAAM,SAAS,GAAG,KAAK,KAAA,QAAL,KAAK,KAAA,KAAA,IAAL,KAAK,GAAI,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACxD,IAAI,SAAS,KAAK,CAAC,EAAE;YACjB,IAAI,GAAG,MAAM,CAAC;YACd,KAAK,GAAG,SAAS,CAAC;SACrB,MAAM;YACH,KAAK,GAAG,SAAS,GAAG,CAAC,CAAC;YACtB,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SAChC;QACD,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,EAAE;YAChC,MAAM;SACT;QACD,IAAI,GAAG,IAAI,CAAC;KACf;IACD,OAAO,IAAI,CAAC;AAChB,CAAC;AAEK,SAAU,gBAAgB,CAAC,KAAc,EAAE,GAAY;IACzD,MAAM,YAAY,GAAG,eAAe,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACjD,IAAI,CAAC,YAAY,EAAE;QACf,OAAO,EAAE,CAAC;KACb;IACD,OAAO,YAAY,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC;AACjF,CAAC;AAED,SAAS,eAAe,CAAC,CAAU,EAAE,CAAU;IAC3C,MAAM,QAAQ,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;IACnC,MAAM,QAAQ,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;IACnC,IAAI,OAAiC,CAAC;IACtC,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;QAC7D,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC5B,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC5B,IAAI,OAAO,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM,EAAE;YACnC,OAAO,GAAG;gBACN,MAAM,EAAE,OAAO,CAAC,MAAM;gBACtB,CAAC,EAAE,OAAO,CAAC,KAAK;gBAChB,CAAC,EAAE,OAAO,CAAC,KAAK;aACnB,CAAC;SACL,MAAM;YACH,MAAM;SACT;KACJ;IACD,OAAO,OAAO,CAAC;AACnB,CAAC;AAQD,SAAS,cAAc,CAAC,IAAa;IACjC,MAAM,KAAK,GAAiB,EAAE,CAAC;IAC/B,MAAO,IAAI,CAAC,SAAS,CAAE;QACnB,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC;QAC9B,MAAM,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAC3C,KAAK,CAAC,IAAI,CAAC;YACP,MAAM;YACN,KAAK;SACR,CAAC,CAAC;QACH,IAAI,GAAG,MAAM,CAAC;KACjB;IACD,OAAO,KAAK,CAAC,OAAO,EAAE,CAAC;AAC3B,CAAC","ignoreList":[0]}},
    {"offset": {"line": 896, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 902, "column": 0}, "map": {"version":3,"file":"errors.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/errors.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { CstNode } from '../syntax-tree.js';\n\nexport class ErrorWithLocation extends Error {\n    constructor(node: CstNode | undefined, message: string) {\n        super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);\n    }\n}\n\nexport function assertUnreachable(_: never): never {\n    throw new Error('Error! The input value was not handled.');\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AAI1E,MAAO,iBAAkB,SAAQ,KAAK;IACxC,YAAY,IAAyB,EAAE,OAAe,CAAA;QAClD,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,OAAO,CAAA,IAAA,EAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAA,CAAA,EAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;IACnG,CAAC;CACJ;AAEK,SAAU,iBAAiB,CAAC,CAAQ;IACtC,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;AAC/D,CAAC","ignoreList":[0]}},
    {"offset": {"line": 918, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 924, "column": 0}, "map": {"version":3,"file":"ast.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/languages/generated/ast.ts"],"sourcesContent":["/******************************************************************************\n * This file was generated by langium-cli 3.0.0.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\n\n/* eslint-disable */\nimport type { AstNode, Reference, ReferenceInfo, TypeMetaData } from '../../syntax-tree.js';\nimport { AbstractAstReflection } from '../../syntax-tree.js';\n\nexport const LangiumGrammarTerminals = {\n    ID: /\\^?[_a-zA-Z][\\w_]*/,\n    STRING: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/,\n    NUMBER: /NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity)/,\n    RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\n    WS: /\\s+/,\n    ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\n    SL_COMMENT: /\\/\\/[^\\n\\r]*/,\n};\n\nexport type AbstractRule = ParserRule | TerminalRule;\n\nexport const AbstractRule = 'AbstractRule';\n\nexport function isAbstractRule(item: unknown): item is AbstractRule {\n    return reflection.isInstance(item, AbstractRule);\n}\n\nexport type AbstractType = InferredType | Interface | ParserRule | Type;\n\nexport const AbstractType = 'AbstractType';\n\nexport function isAbstractType(item: unknown): item is AbstractType {\n    return reflection.isInstance(item, AbstractType);\n}\n\nexport type Condition = BooleanLiteral | Conjunction | Disjunction | Negation | ParameterReference;\n\nexport const Condition = 'Condition';\n\nexport function isCondition(item: unknown): item is Condition {\n    return reflection.isInstance(item, Condition);\n}\n\nexport type FeatureName = 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'interface' | 'returns' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;\n\nexport function isFeatureName(item: unknown): item is FeatureName {\n    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\\^?[_a-zA-Z][\\w_]*/.test(item)));\n}\n\nexport type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';\n\nexport function isPrimitiveType(item: unknown): item is PrimitiveType {\n    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';\n}\n\nexport type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;\n\nexport const TypeDefinition = 'TypeDefinition';\n\nexport function isTypeDefinition(item: unknown): item is TypeDefinition {\n    return reflection.isInstance(item, TypeDefinition);\n}\n\nexport type ValueLiteral = ArrayLiteral | BooleanLiteral | NumberLiteral | StringLiteral;\n\nexport const ValueLiteral = 'ValueLiteral';\n\nexport function isValueLiteral(item: unknown): item is ValueLiteral {\n    return reflection.isInstance(item, ValueLiteral);\n}\n\nexport interface AbstractElement extends AstNode {\n    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';\n    cardinality?: '*' | '+' | '?';\n    lookahead?: '?!' | '?<!' | '?<=' | '?=';\n}\n\nexport const AbstractElement = 'AbstractElement';\n\nexport function isAbstractElement(item: unknown): item is AbstractElement {\n    return reflection.isInstance(item, AbstractElement);\n}\n\nexport interface ArrayLiteral extends AstNode {\n    readonly $container: ArrayLiteral | TypeAttribute;\n    readonly $type: 'ArrayLiteral';\n    elements: Array<ValueLiteral>;\n}\n\nexport const ArrayLiteral = 'ArrayLiteral';\n\nexport function isArrayLiteral(item: unknown): item is ArrayLiteral {\n    return reflection.isInstance(item, ArrayLiteral);\n}\n\nexport interface ArrayType extends AstNode {\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\n    readonly $type: 'ArrayType';\n    elementType: TypeDefinition;\n}\n\nexport const ArrayType = 'ArrayType';\n\nexport function isArrayType(item: unknown): item is ArrayType {\n    return reflection.isInstance(item, ArrayType);\n}\n\nexport interface BooleanLiteral extends AstNode {\n    readonly $container: ArrayLiteral | Conjunction | Disjunction | Group | NamedArgument | Negation | TypeAttribute;\n    readonly $type: 'BooleanLiteral';\n    true: boolean;\n}\n\nexport const BooleanLiteral = 'BooleanLiteral';\n\nexport function isBooleanLiteral(item: unknown): item is BooleanLiteral {\n    return reflection.isInstance(item, BooleanLiteral);\n}\n\nexport interface Conjunction extends AstNode {\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\n    readonly $type: 'Conjunction';\n    left: Condition;\n    right: Condition;\n}\n\nexport const Conjunction = 'Conjunction';\n\nexport function isConjunction(item: unknown): item is Conjunction {\n    return reflection.isInstance(item, Conjunction);\n}\n\nexport interface Disjunction extends AstNode {\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\n    readonly $type: 'Disjunction';\n    left: Condition;\n    right: Condition;\n}\n\nexport const Disjunction = 'Disjunction';\n\nexport function isDisjunction(item: unknown): item is Disjunction {\n    return reflection.isInstance(item, Disjunction);\n}\n\nexport interface Grammar extends AstNode {\n    readonly $type: 'Grammar';\n    definesHiddenTokens: boolean;\n    hiddenTokens: Array<Reference<AbstractRule>>;\n    imports: Array<GrammarImport>;\n    interfaces: Array<Interface>;\n    isDeclared: boolean;\n    name?: string;\n    rules: Array<AbstractRule>;\n    types: Array<Type>;\n    usedGrammars: Array<Reference<Grammar>>;\n}\n\nexport const Grammar = 'Grammar';\n\nexport function isGrammar(item: unknown): item is Grammar {\n    return reflection.isInstance(item, Grammar);\n}\n\nexport interface GrammarImport extends AstNode {\n    readonly $container: Grammar;\n    readonly $type: 'GrammarImport';\n    path: string;\n}\n\nexport const GrammarImport = 'GrammarImport';\n\nexport function isGrammarImport(item: unknown): item is GrammarImport {\n    return reflection.isInstance(item, GrammarImport);\n}\n\nexport interface InferredType extends AstNode {\n    readonly $container: Action | ParserRule;\n    readonly $type: 'InferredType';\n    name: string;\n}\n\nexport const InferredType = 'InferredType';\n\nexport function isInferredType(item: unknown): item is InferredType {\n    return reflection.isInstance(item, InferredType);\n}\n\nexport interface Interface extends AstNode {\n    readonly $container: Grammar;\n    readonly $type: 'Interface';\n    attributes: Array<TypeAttribute>;\n    name: string;\n    superTypes: Array<Reference<AbstractType>>;\n}\n\nexport const Interface = 'Interface';\n\nexport function isInterface(item: unknown): item is Interface {\n    return reflection.isInstance(item, Interface);\n}\n\nexport interface NamedArgument extends AstNode {\n    readonly $container: RuleCall;\n    readonly $type: 'NamedArgument';\n    calledByName: boolean;\n    parameter?: Reference<Parameter>;\n    value: Condition;\n}\n\nexport const NamedArgument = 'NamedArgument';\n\nexport function isNamedArgument(item: unknown): item is NamedArgument {\n    return reflection.isInstance(item, NamedArgument);\n}\n\nexport interface Negation extends AstNode {\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\n    readonly $type: 'Negation';\n    value: Condition;\n}\n\nexport const Negation = 'Negation';\n\nexport function isNegation(item: unknown): item is Negation {\n    return reflection.isInstance(item, Negation);\n}\n\nexport interface NumberLiteral extends AstNode {\n    readonly $container: ArrayLiteral | TypeAttribute;\n    readonly $type: 'NumberLiteral';\n    value: number;\n}\n\nexport const NumberLiteral = 'NumberLiteral';\n\nexport function isNumberLiteral(item: unknown): item is NumberLiteral {\n    return reflection.isInstance(item, NumberLiteral);\n}\n\nexport interface Parameter extends AstNode {\n    readonly $container: ParserRule;\n    readonly $type: 'Parameter';\n    name: string;\n}\n\nexport const Parameter = 'Parameter';\n\nexport function isParameter(item: unknown): item is Parameter {\n    return reflection.isInstance(item, Parameter);\n}\n\nexport interface ParameterReference extends AstNode {\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\n    readonly $type: 'ParameterReference';\n    parameter: Reference<Parameter>;\n}\n\nexport const ParameterReference = 'ParameterReference';\n\nexport function isParameterReference(item: unknown): item is ParameterReference {\n    return reflection.isInstance(item, ParameterReference);\n}\n\nexport interface ParserRule extends AstNode {\n    readonly $container: Grammar;\n    readonly $type: 'ParserRule';\n    dataType?: PrimitiveType;\n    definesHiddenTokens: boolean;\n    definition: AbstractElement;\n    entry: boolean;\n    fragment: boolean;\n    hiddenTokens: Array<Reference<AbstractRule>>;\n    inferredType?: InferredType;\n    name: string;\n    parameters: Array<Parameter>;\n    returnType?: Reference<AbstractType>;\n    wildcard: boolean;\n}\n\nexport const ParserRule = 'ParserRule';\n\nexport function isParserRule(item: unknown): item is ParserRule {\n    return reflection.isInstance(item, ParserRule);\n}\n\nexport interface ReferenceType extends AstNode {\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\n    readonly $type: 'ReferenceType';\n    referenceType: TypeDefinition;\n}\n\nexport const ReferenceType = 'ReferenceType';\n\nexport function isReferenceType(item: unknown): item is ReferenceType {\n    return reflection.isInstance(item, ReferenceType);\n}\n\nexport interface ReturnType extends AstNode {\n    readonly $container: TerminalRule;\n    readonly $type: 'ReturnType';\n    name: PrimitiveType | string;\n}\n\nexport const ReturnType = 'ReturnType';\n\nexport function isReturnType(item: unknown): item is ReturnType {\n    return reflection.isInstance(item, ReturnType);\n}\n\nexport interface SimpleType extends AstNode {\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\n    readonly $type: 'SimpleType';\n    primitiveType?: PrimitiveType;\n    stringType?: string;\n    typeRef?: Reference<AbstractType>;\n}\n\nexport const SimpleType = 'SimpleType';\n\nexport function isSimpleType(item: unknown): item is SimpleType {\n    return reflection.isInstance(item, SimpleType);\n}\n\nexport interface StringLiteral extends AstNode {\n    readonly $container: ArrayLiteral | TypeAttribute;\n    readonly $type: 'StringLiteral';\n    value: string;\n}\n\nexport const StringLiteral = 'StringLiteral';\n\nexport function isStringLiteral(item: unknown): item is StringLiteral {\n    return reflection.isInstance(item, StringLiteral);\n}\n\nexport interface TerminalRule extends AstNode {\n    readonly $container: Grammar;\n    readonly $type: 'TerminalRule';\n    definition: AbstractElement;\n    fragment: boolean;\n    hidden: boolean;\n    name: string;\n    type?: ReturnType;\n}\n\nexport const TerminalRule = 'TerminalRule';\n\nexport function isTerminalRule(item: unknown): item is TerminalRule {\n    return reflection.isInstance(item, TerminalRule);\n}\n\nexport interface Type extends AstNode {\n    readonly $container: Grammar;\n    readonly $type: 'Type';\n    name: string;\n    type: TypeDefinition;\n}\n\nexport const Type = 'Type';\n\nexport function isType(item: unknown): item is Type {\n    return reflection.isInstance(item, Type);\n}\n\nexport interface TypeAttribute extends AstNode {\n    readonly $container: Interface;\n    readonly $type: 'TypeAttribute';\n    defaultValue?: ValueLiteral;\n    isOptional: boolean;\n    name: FeatureName;\n    type: TypeDefinition;\n}\n\nexport const TypeAttribute = 'TypeAttribute';\n\nexport function isTypeAttribute(item: unknown): item is TypeAttribute {\n    return reflection.isInstance(item, TypeAttribute);\n}\n\nexport interface UnionType extends AstNode {\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\n    readonly $type: 'UnionType';\n    types: Array<TypeDefinition>;\n}\n\nexport const UnionType = 'UnionType';\n\nexport function isUnionType(item: unknown): item is UnionType {\n    return reflection.isInstance(item, UnionType);\n}\n\nexport interface Action extends AbstractElement {\n    readonly $type: 'Action';\n    feature?: FeatureName;\n    inferredType?: InferredType;\n    operator?: '+=' | '=';\n    type?: Reference<AbstractType>;\n}\n\nexport const Action = 'Action';\n\nexport function isAction(item: unknown): item is Action {\n    return reflection.isInstance(item, Action);\n}\n\nexport interface Alternatives extends AbstractElement {\n    readonly $type: 'Alternatives';\n    elements: Array<AbstractElement>;\n}\n\nexport const Alternatives = 'Alternatives';\n\nexport function isAlternatives(item: unknown): item is Alternatives {\n    return reflection.isInstance(item, Alternatives);\n}\n\nexport interface Assignment extends AbstractElement {\n    readonly $type: 'Assignment';\n    feature: FeatureName;\n    operator: '+=' | '=' | '?=';\n    terminal: AbstractElement;\n}\n\nexport const Assignment = 'Assignment';\n\nexport function isAssignment(item: unknown): item is Assignment {\n    return reflection.isInstance(item, Assignment);\n}\n\nexport interface CharacterRange extends AbstractElement {\n    readonly $type: 'CharacterRange';\n    left: Keyword;\n    right?: Keyword;\n}\n\nexport const CharacterRange = 'CharacterRange';\n\nexport function isCharacterRange(item: unknown): item is CharacterRange {\n    return reflection.isInstance(item, CharacterRange);\n}\n\nexport interface CrossReference extends AbstractElement {\n    readonly $type: 'CrossReference';\n    deprecatedSyntax: boolean;\n    terminal?: AbstractElement;\n    type: Reference<AbstractType>;\n}\n\nexport const CrossReference = 'CrossReference';\n\nexport function isCrossReference(item: unknown): item is CrossReference {\n    return reflection.isInstance(item, CrossReference);\n}\n\nexport interface EndOfFile extends AbstractElement {\n    readonly $type: 'EndOfFile';\n}\n\nexport const EndOfFile = 'EndOfFile';\n\nexport function isEndOfFile(item: unknown): item is EndOfFile {\n    return reflection.isInstance(item, EndOfFile);\n}\n\nexport interface Group extends AbstractElement {\n    readonly $type: 'Group';\n    elements: Array<AbstractElement>;\n    guardCondition?: Condition;\n}\n\nexport const Group = 'Group';\n\nexport function isGroup(item: unknown): item is Group {\n    return reflection.isInstance(item, Group);\n}\n\nexport interface Keyword extends AbstractElement {\n    readonly $container: CharacterRange;\n    readonly $type: 'Keyword';\n    value: string;\n}\n\nexport const Keyword = 'Keyword';\n\nexport function isKeyword(item: unknown): item is Keyword {\n    return reflection.isInstance(item, Keyword);\n}\n\nexport interface NegatedToken extends AbstractElement {\n    readonly $type: 'NegatedToken';\n    terminal: AbstractElement;\n}\n\nexport const NegatedToken = 'NegatedToken';\n\nexport function isNegatedToken(item: unknown): item is NegatedToken {\n    return reflection.isInstance(item, NegatedToken);\n}\n\nexport interface RegexToken extends AbstractElement {\n    readonly $type: 'RegexToken';\n    regex: string;\n}\n\nexport const RegexToken = 'RegexToken';\n\nexport function isRegexToken(item: unknown): item is RegexToken {\n    return reflection.isInstance(item, RegexToken);\n}\n\nexport interface RuleCall extends AbstractElement {\n    readonly $type: 'RuleCall';\n    arguments: Array<NamedArgument>;\n    rule: Reference<AbstractRule>;\n}\n\nexport const RuleCall = 'RuleCall';\n\nexport function isRuleCall(item: unknown): item is RuleCall {\n    return reflection.isInstance(item, RuleCall);\n}\n\nexport interface TerminalAlternatives extends AbstractElement {\n    readonly $type: 'TerminalAlternatives';\n    elements: Array<AbstractElement>;\n}\n\nexport const TerminalAlternatives = 'TerminalAlternatives';\n\nexport function isTerminalAlternatives(item: unknown): item is TerminalAlternatives {\n    return reflection.isInstance(item, TerminalAlternatives);\n}\n\nexport interface TerminalGroup extends AbstractElement {\n    readonly $type: 'TerminalGroup';\n    elements: Array<AbstractElement>;\n}\n\nexport const TerminalGroup = 'TerminalGroup';\n\nexport function isTerminalGroup(item: unknown): item is TerminalGroup {\n    return reflection.isInstance(item, TerminalGroup);\n}\n\nexport interface TerminalRuleCall extends AbstractElement {\n    readonly $type: 'TerminalRuleCall';\n    rule: Reference<TerminalRule>;\n}\n\nexport const TerminalRuleCall = 'TerminalRuleCall';\n\nexport function isTerminalRuleCall(item: unknown): item is TerminalRuleCall {\n    return reflection.isInstance(item, TerminalRuleCall);\n}\n\nexport interface UnorderedGroup extends AbstractElement {\n    readonly $type: 'UnorderedGroup';\n    elements: Array<AbstractElement>;\n}\n\nexport const UnorderedGroup = 'UnorderedGroup';\n\nexport function isUnorderedGroup(item: unknown): item is UnorderedGroup {\n    return reflection.isInstance(item, UnorderedGroup);\n}\n\nexport interface UntilToken extends AbstractElement {\n    readonly $type: 'UntilToken';\n    terminal: AbstractElement;\n}\n\nexport const UntilToken = 'UntilToken';\n\nexport function isUntilToken(item: unknown): item is UntilToken {\n    return reflection.isInstance(item, UntilToken);\n}\n\nexport interface Wildcard extends AbstractElement {\n    readonly $type: 'Wildcard';\n}\n\nexport const Wildcard = 'Wildcard';\n\nexport function isWildcard(item: unknown): item is Wildcard {\n    return reflection.isInstance(item, Wildcard);\n}\n\nexport type LangiumGrammarAstType = {\n    AbstractElement: AbstractElement\n    AbstractRule: AbstractRule\n    AbstractType: AbstractType\n    Action: Action\n    Alternatives: Alternatives\n    ArrayLiteral: ArrayLiteral\n    ArrayType: ArrayType\n    Assignment: Assignment\n    BooleanLiteral: BooleanLiteral\n    CharacterRange: CharacterRange\n    Condition: Condition\n    Conjunction: Conjunction\n    CrossReference: CrossReference\n    Disjunction: Disjunction\n    EndOfFile: EndOfFile\n    Grammar: Grammar\n    GrammarImport: GrammarImport\n    Group: Group\n    InferredType: InferredType\n    Interface: Interface\n    Keyword: Keyword\n    NamedArgument: NamedArgument\n    NegatedToken: NegatedToken\n    Negation: Negation\n    NumberLiteral: NumberLiteral\n    Parameter: Parameter\n    ParameterReference: ParameterReference\n    ParserRule: ParserRule\n    ReferenceType: ReferenceType\n    RegexToken: RegexToken\n    ReturnType: ReturnType\n    RuleCall: RuleCall\n    SimpleType: SimpleType\n    StringLiteral: StringLiteral\n    TerminalAlternatives: TerminalAlternatives\n    TerminalGroup: TerminalGroup\n    TerminalRule: TerminalRule\n    TerminalRuleCall: TerminalRuleCall\n    Type: Type\n    TypeAttribute: TypeAttribute\n    TypeDefinition: TypeDefinition\n    UnionType: UnionType\n    UnorderedGroup: UnorderedGroup\n    UntilToken: UntilToken\n    ValueLiteral: ValueLiteral\n    Wildcard: Wildcard\n}\n\nexport class LangiumGrammarAstReflection extends AbstractAstReflection {\n\n    getAllTypes(): string[] {\n        return ['AbstractElement', 'AbstractRule', 'AbstractType', 'Action', 'Alternatives', 'ArrayLiteral', 'ArrayType', 'Assignment', 'BooleanLiteral', 'CharacterRange', 'Condition', 'Conjunction', 'CrossReference', 'Disjunction', 'EndOfFile', 'Grammar', 'GrammarImport', 'Group', 'InferredType', 'Interface', 'Keyword', 'NamedArgument', 'NegatedToken', 'Negation', 'NumberLiteral', 'Parameter', 'ParameterReference', 'ParserRule', 'ReferenceType', 'RegexToken', 'ReturnType', 'RuleCall', 'SimpleType', 'StringLiteral', 'TerminalAlternatives', 'TerminalGroup', 'TerminalRule', 'TerminalRuleCall', 'Type', 'TypeAttribute', 'TypeDefinition', 'UnionType', 'UnorderedGroup', 'UntilToken', 'ValueLiteral', 'Wildcard'];\n    }\n\n    protected override computeIsSubtype(subtype: string, supertype: string): boolean {\n        switch (subtype) {\n            case Action:\n            case Alternatives:\n            case Assignment:\n            case CharacterRange:\n            case CrossReference:\n            case EndOfFile:\n            case Group:\n            case Keyword:\n            case NegatedToken:\n            case RegexToken:\n            case RuleCall:\n            case TerminalAlternatives:\n            case TerminalGroup:\n            case TerminalRuleCall:\n            case UnorderedGroup:\n            case UntilToken:\n            case Wildcard: {\n                return this.isSubtype(AbstractElement, supertype);\n            }\n            case ArrayLiteral:\n            case NumberLiteral:\n            case StringLiteral: {\n                return this.isSubtype(ValueLiteral, supertype);\n            }\n            case ArrayType:\n            case ReferenceType:\n            case SimpleType:\n            case UnionType: {\n                return this.isSubtype(TypeDefinition, supertype);\n            }\n            case BooleanLiteral: {\n                return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);\n            }\n            case Conjunction:\n            case Disjunction:\n            case Negation:\n            case ParameterReference: {\n                return this.isSubtype(Condition, supertype);\n            }\n            case InferredType:\n            case Interface:\n            case Type: {\n                return this.isSubtype(AbstractType, supertype);\n            }\n            case ParserRule: {\n                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\n            }\n            case TerminalRule: {\n                return this.isSubtype(AbstractRule, supertype);\n            }\n            default: {\n                return false;\n            }\n        }\n    }\n\n    getReferenceType(refInfo: ReferenceInfo): string {\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n        switch (referenceId) {\n            case 'Action:type':\n            case 'CrossReference:type':\n            case 'Interface:superTypes':\n            case 'ParserRule:returnType':\n            case 'SimpleType:typeRef': {\n                return AbstractType;\n            }\n            case 'Grammar:hiddenTokens':\n            case 'ParserRule:hiddenTokens':\n            case 'RuleCall:rule': {\n                return AbstractRule;\n            }\n            case 'Grammar:usedGrammars': {\n                return Grammar;\n            }\n            case 'NamedArgument:parameter':\n            case 'ParameterReference:parameter': {\n                return Parameter;\n            }\n            case 'TerminalRuleCall:rule': {\n                return TerminalRule;\n            }\n            default: {\n                throw new Error(`${referenceId} is not a valid reference id.`);\n            }\n        }\n    }\n\n    getTypeMetaData(type: string): TypeMetaData {\n        switch (type) {\n            case 'AbstractElement': {\n                return {\n                    name: 'AbstractElement',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'ArrayLiteral': {\n                return {\n                    name: 'ArrayLiteral',\n                    properties: [\n                        { name: 'elements', defaultValue: [] }\n                    ]\n                };\n            }\n            case 'ArrayType': {\n                return {\n                    name: 'ArrayType',\n                    properties: [\n                        { name: 'elementType' }\n                    ]\n                };\n            }\n            case 'BooleanLiteral': {\n                return {\n                    name: 'BooleanLiteral',\n                    properties: [\n                        { name: 'true', defaultValue: false }\n                    ]\n                };\n            }\n            case 'Conjunction': {\n                return {\n                    name: 'Conjunction',\n                    properties: [\n                        { name: 'left' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case 'Disjunction': {\n                return {\n                    name: 'Disjunction',\n                    properties: [\n                        { name: 'left' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case 'Grammar': {\n                return {\n                    name: 'Grammar',\n                    properties: [\n                        { name: 'definesHiddenTokens', defaultValue: false },\n                        { name: 'hiddenTokens', defaultValue: [] },\n                        { name: 'imports', defaultValue: [] },\n                        { name: 'interfaces', defaultValue: [] },\n                        { name: 'isDeclared', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'rules', defaultValue: [] },\n                        { name: 'types', defaultValue: [] },\n                        { name: 'usedGrammars', defaultValue: [] }\n                    ]\n                };\n            }\n            case 'GrammarImport': {\n                return {\n                    name: 'GrammarImport',\n                    properties: [\n                        { name: 'path' }\n                    ]\n                };\n            }\n            case 'InferredType': {\n                return {\n                    name: 'InferredType',\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case 'Interface': {\n                return {\n                    name: 'Interface',\n                    properties: [\n                        { name: 'attributes', defaultValue: [] },\n                        { name: 'name' },\n                        { name: 'superTypes', defaultValue: [] }\n                    ]\n                };\n            }\n            case 'NamedArgument': {\n                return {\n                    name: 'NamedArgument',\n                    properties: [\n                        { name: 'calledByName', defaultValue: false },\n                        { name: 'parameter' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case 'Negation': {\n                return {\n                    name: 'Negation',\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case 'NumberLiteral': {\n                return {\n                    name: 'NumberLiteral',\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case 'Parameter': {\n                return {\n                    name: 'Parameter',\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case 'ParameterReference': {\n                return {\n                    name: 'ParameterReference',\n                    properties: [\n                        { name: 'parameter' }\n                    ]\n                };\n            }\n            case 'ParserRule': {\n                return {\n                    name: 'ParserRule',\n                    properties: [\n                        { name: 'dataType' },\n                        { name: 'definesHiddenTokens', defaultValue: false },\n                        { name: 'definition' },\n                        { name: 'entry', defaultValue: false },\n                        { name: 'fragment', defaultValue: false },\n                        { name: 'hiddenTokens', defaultValue: [] },\n                        { name: 'inferredType' },\n                        { name: 'name' },\n                        { name: 'parameters', defaultValue: [] },\n                        { name: 'returnType' },\n                        { name: 'wildcard', defaultValue: false }\n                    ]\n                };\n            }\n            case 'ReferenceType': {\n                return {\n                    name: 'ReferenceType',\n                    properties: [\n                        { name: 'referenceType' }\n                    ]\n                };\n            }\n            case 'ReturnType': {\n                return {\n                    name: 'ReturnType',\n                    properties: [\n                        { name: 'name' }\n                    ]\n                };\n            }\n            case 'SimpleType': {\n                return {\n                    name: 'SimpleType',\n                    properties: [\n                        { name: 'primitiveType' },\n                        { name: 'stringType' },\n                        { name: 'typeRef' }\n                    ]\n                };\n            }\n            case 'StringLiteral': {\n                return {\n                    name: 'StringLiteral',\n                    properties: [\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case 'TerminalRule': {\n                return {\n                    name: 'TerminalRule',\n                    properties: [\n                        { name: 'definition' },\n                        { name: 'fragment', defaultValue: false },\n                        { name: 'hidden', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case 'Type': {\n                return {\n                    name: 'Type',\n                    properties: [\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case 'TypeAttribute': {\n                return {\n                    name: 'TypeAttribute',\n                    properties: [\n                        { name: 'defaultValue' },\n                        { name: 'isOptional', defaultValue: false },\n                        { name: 'name' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case 'UnionType': {\n                return {\n                    name: 'UnionType',\n                    properties: [\n                        { name: 'types', defaultValue: [] }\n                    ]\n                };\n            }\n            case 'Action': {\n                return {\n                    name: 'Action',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'feature' },\n                        { name: 'inferredType' },\n                        { name: 'lookahead' },\n                        { name: 'operator' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case 'Alternatives': {\n                return {\n                    name: 'Alternatives',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'Assignment': {\n                return {\n                    name: 'Assignment',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'feature' },\n                        { name: 'lookahead' },\n                        { name: 'operator' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case 'CharacterRange': {\n                return {\n                    name: 'CharacterRange',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'left' },\n                        { name: 'lookahead' },\n                        { name: 'right' }\n                    ]\n                };\n            }\n            case 'CrossReference': {\n                return {\n                    name: 'CrossReference',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'deprecatedSyntax', defaultValue: false },\n                        { name: 'lookahead' },\n                        { name: 'terminal' },\n                        { name: 'type' }\n                    ]\n                };\n            }\n            case 'EndOfFile': {\n                return {\n                    name: 'EndOfFile',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'Group': {\n                return {\n                    name: 'Group',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'guardCondition' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'Keyword': {\n                return {\n                    name: 'Keyword',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            case 'NegatedToken': {\n                return {\n                    name: 'NegatedToken',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case 'RegexToken': {\n                return {\n                    name: 'RegexToken',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'regex' }\n                    ]\n                };\n            }\n            case 'RuleCall': {\n                return {\n                    name: 'RuleCall',\n                    properties: [\n                        { name: 'arguments', defaultValue: [] },\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'rule' }\n                    ]\n                };\n            }\n            case 'TerminalAlternatives': {\n                return {\n                    name: 'TerminalAlternatives',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'TerminalGroup': {\n                return {\n                    name: 'TerminalGroup',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'TerminalRuleCall': {\n                return {\n                    name: 'TerminalRuleCall',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'rule' }\n                    ]\n                };\n            }\n            case 'UnorderedGroup': {\n                return {\n                    name: 'UnorderedGroup',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'elements', defaultValue: [] },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            case 'UntilToken': {\n                return {\n                    name: 'UntilToken',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' },\n                        { name: 'terminal' }\n                    ]\n                };\n            }\n            case 'Wildcard': {\n                return {\n                    name: 'Wildcard',\n                    properties: [\n                        { name: 'cardinality' },\n                        { name: 'lookahead' }\n                    ]\n                };\n            }\n            default: {\n                return {\n                    name: type,\n                    properties: []\n                };\n            }\n        }\n    }\n}\n\nexport const reflection = new LangiumGrammarAstReflection();\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2105, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2111, "column": 0}, "map": {"version":3,"file":"ast-utils.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/ast-utils.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { Range } from 'vscode-languageserver-types';\nimport type { AstNode, AstReflection, CstNode, GenericAstNode, Mutable, PropertyType, Reference, ReferenceInfo } from '../syntax-tree.js';\nimport type { Stream, TreeStream } from './stream.js';\nimport type { LangiumDocument } from '../workspace/documents.js';\nimport { isAstNode, isReference } from '../syntax-tree.js';\nimport { DONE_RESULT, stream, StreamImpl, TreeStreamImpl } from './stream.js';\nimport { inRange } from './cst-utils.js';\n\n/**\n * Link the `$container` and other related properties of every AST node that is directly contained\n * in the given `node`.\n */\nexport function linkContentToContainer(node: AstNode): void {\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith('$')) {\n            if (Array.isArray(value)) {\n                value.forEach((item, index) => {\n                    if (isAstNode(item)) {\n                        (item as Mutable<AstNode>).$container = node;\n                        (item as Mutable<AstNode>).$containerProperty = name;\n                        (item as Mutable<AstNode>).$containerIndex = index;\n                    }\n                });\n            } else if (isAstNode(value)) {\n                (value as Mutable<AstNode>).$container = node;\n                (value as Mutable<AstNode>).$containerProperty = name;\n            }\n        }\n    }\n}\n\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and return the first\n * node that matches the type predicate. If the start node itself matches, it is returned.\n * If no container matches, `undefined` is returned.\n */\nexport function getContainerOfType<T extends AstNode>(node: AstNode | undefined, typePredicate: (n: AstNode) => n is T): T | undefined {\n    let item = node;\n    while (item) {\n        if (typePredicate(item)) {\n            return item;\n        }\n        item = item.$container;\n    }\n    return undefined;\n}\n\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and check for existence\n * of a container that matches the given predicate. The start node is included in the checks.\n */\nexport function hasContainerOfType(node: AstNode | undefined, predicate: (n: AstNode) => boolean): boolean {\n    let item = node;\n    while (item) {\n        if (predicate(item)) {\n            return true;\n        }\n        item = item.$container;\n    }\n    return false;\n}\n\n/**\n * Retrieve the document in which the given AST node is contained. A reference to the document is\n * usually held by the root node of the AST.\n *\n * @throws an error if the node is not contained in a document.\n */\nexport function getDocument<T extends AstNode = AstNode>(node: AstNode): LangiumDocument<T> {\n    const rootNode = findRootNode(node);\n    const result = rootNode.$document;\n    if (!result) {\n        throw new Error('AST node has no document.');\n    }\n    return result as LangiumDocument<T>;\n}\n\n/**\n * Returns the root node of the given AST node by following the `$container` references.\n */\nexport function findRootNode(node: AstNode): AstNode {\n    while (node.$container) {\n        node = node.$container;\n    }\n    return node;\n}\n\nexport interface AstStreamOptions {\n    /**\n     * Optional target range that the nodes in the stream need to intersect\n     */\n    range?: Range\n}\n\n/**\n * Create a stream of all AST nodes that are directly contained in the given node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nexport function streamContents(node: AstNode, options?: AstStreamOptions): Stream<AstNode> {\n    if (!node) {\n        throw new Error('Node must be an AstNode.');\n    }\n    const range = options?.range;\n    type State = { keys: string[], keyIndex: number, arrayIndex: number };\n    return new StreamImpl<State, AstNode>(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith('$')) {\n                const value = (node as GenericAstNode)[property];\n                if (isAstNode(value)) {\n                    state.keyIndex++;\n                    if (isAstNodeInRange(value, range)) {\n                        return { done: false, value };\n                    }\n                } else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if (isAstNode(element) && isAstNodeInRange(element, range)) {\n                            return { done: false, value: element };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return DONE_RESULT;\n    });\n}\n\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node.\n * This does not include the root node itself.\n */\nexport function streamAllContents(root: AstNode, options?: AstStreamOptions): TreeStream<AstNode> {\n    if (!root) {\n        throw new Error('Root node must be an AstNode.');\n    }\n    return new TreeStreamImpl(root, node => streamContents(node, options));\n}\n\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nexport function streamAst(root: AstNode, options?: AstStreamOptions): TreeStream<AstNode> {\n    if (!root) {\n        throw new Error('Root node must be an AstNode.');\n    } else if (options?.range && !isAstNodeInRange(root, options.range)) {\n        // Return an empty stream if the root node isn't in range\n        return new TreeStreamImpl(root, () => []);\n    }\n    return new TreeStreamImpl(root, node => streamContents(node, options), { includeRoot: true });\n}\n\nfunction isAstNodeInRange(astNode: AstNode, range?: Range): boolean {\n    if (!range) {\n        return true;\n    }\n    const nodeRange = astNode.$cstNode?.range;\n    if (!nodeRange) {\n        return false;\n    }\n    return inRange(nodeRange, range);\n}\n\n/**\n * Create a stream of all cross-references that are held by the given AST node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nexport function streamReferences(node: AstNode): Stream<ReferenceInfo> {\n    type State = { keys: string[], keyIndex: number, arrayIndex: number };\n    return new StreamImpl<State, ReferenceInfo>(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith('$')) {\n                const value = (node as GenericAstNode)[property];\n                if (isReference(value)) {\n                    state.keyIndex++;\n                    return { done: false, value: { reference: value, container: node, property } };\n                } else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if (isReference(element)) {\n                            return { done: false, value: { reference: element, container: node, property, index } };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return DONE_RESULT;\n    });\n}\n\n/**\n * Returns a Stream of references to the target node from the AstNode tree\n *\n * @param targetNode AstNode we are looking for\n * @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value\n */\nexport function findLocalReferences(targetNode: AstNode, lookup = getDocument(targetNode).parseResult.value): Stream<Reference> {\n    const refs: Reference[] = [];\n    streamAst(lookup).forEach(node => {\n        streamReferences(node).forEach(refInfo => {\n            if (refInfo.reference.ref === targetNode) {\n                refs.push(refInfo.reference);\n            }\n        });\n    });\n    return stream(refs);\n}\n\n/**\n * Assigns all mandatory AST properties to the specified node.\n *\n * @param reflection Reflection object used to gather mandatory properties for the node.\n * @param node Specified node is modified in place and properties are directly assigned.\n */\nexport function assignMandatoryProperties(reflection: AstReflection, node: AstNode): void {\n    const typeMetaData = reflection.getTypeMetaData(node.$type);\n    const genericNode = node as GenericAstNode;\n    for (const property of typeMetaData.properties) {\n        // Only set the value if the property is not already set and if it has a default value\n        if (property.defaultValue !== undefined && genericNode[property.name] === undefined) {\n            genericNode[property.name] = copyDefaultValue(property.defaultValue);\n        }\n    }\n}\n\nfunction copyDefaultValue(propertyType: PropertyType): PropertyType {\n    if (Array.isArray(propertyType)) {\n        return [...propertyType.map(copyDefaultValue)];\n    } else {\n        return propertyType;\n    }\n}\n\n/**\n * Creates a deep copy of the specified AST node.\n * The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.\n *\n * References are copied without resolved cross reference. The specified function is used to rebuild them.\n */\nexport function copyAstNode<T extends AstNode = AstNode>(node: T, buildReference: (node: AstNode, property: string, refNode: CstNode | undefined, refText: string) => Reference<AstNode>): T {\n    const copy: GenericAstNode = { $type: node.$type };\n\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith('$')) {\n            if (isAstNode(value)) {\n                copy[name] = copyAstNode(value, buildReference);\n            } else if (isReference(value)) {\n                copy[name] = buildReference(\n                    copy,\n                    name,\n                    value.$refNode,\n                    value.$refText\n                );\n            } else if (Array.isArray(value)) {\n                const copiedArray: unknown[] = [];\n                for (const element of value) {\n                    if (isAstNode(element)) {\n                        copiedArray.push(copyAstNode(element, buildReference));\n                    } else if (isReference(element)) {\n                        copiedArray.push(\n                            buildReference(\n                                copy,\n                                name,\n                                element.$refNode,\n                                element.$refText\n                            )\n                        );\n                    } else {\n                        copiedArray.push(element);\n                    }\n                }\n                copy[name] = copiedArray;\n            } else {\n                copy[name] = value;\n            }\n        }\n    }\n\n    linkContentToContainer(copy);\n    return copy as unknown as T;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2360, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2366, "column": 0}, "map": {"version":3,"file":"regexp-utils.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/regexp-utils.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { Set, Group, Character, IRegExpAST } from '@chevrotain/regexp-to-ast';\nimport { RegExpParser, BaseRegExpVisitor } from '@chevrotain/regexp-to-ast';\n\nexport const NEWLINE_REGEXP = /\\r?\\n/gm;\n\nconst regexpParser = new RegExpParser();\n\n/**\n * This class is in charge of heuristically identifying start/end tokens of terminals.\n *\n * The way this works is by doing the following:\n * 1. Traverse the regular expression in the \"start state\"\n * 2. Add any encountered sets/single characters to the \"start regexp\"\n * 3. Once we encounter any variable-length content (i.e. with quantifiers such as +/?/*), we enter the \"end state\"\n * 4. In the end state, any sets/single characters are added to an \"end stack\".\n * 5. If we re-encounter any variable-length content we reset the end stack\n * 6. We continue visiting the regex until the end, reseting the end stack and rebuilding it as necessary\n *\n * After traversing a regular expression the `startRegexp/endRegexp` properties allow access to the stored start/end of the terminal\n */\nclass TerminalRegExpVisitor extends BaseRegExpVisitor {\n\n    private isStarting = true;\n    startRegexp: string;\n    private endRegexpStack: string[] = [];\n    multiline = false;\n    regex: string;\n\n    get endRegex(): string {\n        return this.endRegexpStack.join('');\n    }\n\n    reset(regex: string): void {\n        this.multiline = false;\n        this.regex = regex;\n        this.startRegexp = '';\n        this.isStarting = true;\n        this.endRegexpStack = [];\n    }\n\n    override visitGroup(node: Group) {\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n    }\n\n    override visitCharacter(node: Character): void {\n        const char = String.fromCharCode(node.value);\n        if (!this.multiline && char === '\\n') {\n            this.multiline = true;\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        } else {\n            const escapedChar = escapeRegExp(char);\n            this.endRegexpStack.push(escapedChar);\n            if (this.isStarting) {\n                this.startRegexp += escapedChar;\n            }\n        }\n    }\n\n    override visitSet(node: Set): void {\n        if (!this.multiline) {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            const regex = new RegExp(set);\n            this.multiline = Boolean('\\n'.match(regex));\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        } else {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            this.endRegexpStack.push(set);\n            if (this.isStarting) {\n                this.startRegexp += set;\n            }\n        }\n    }\n\n    override visitChildren(node: IRegExpAST): void {\n        if (node.type === 'Group') {\n            // Ignore children of groups with quantifier (+/*/?)\n            // These groups are unrelated to start/end tokens of terminals\n            const group = node as Group;\n            if (group.quantifier) {\n                return;\n            }\n        }\n        super.visitChildren(node);\n    }\n}\n\nconst visitor = new TerminalRegExpVisitor();\n\nexport function getTerminalParts(regexp: RegExp | string): Array<{ start: string, end: string }> {\n    try {\n        if (typeof regexp !== 'string') {\n            regexp = regexp.source;\n        }\n        regexp = `/${regexp}/`;\n        const pattern = regexpParser.pattern(regexp);\n        const parts: Array<{ start: string, end: string }> = [];\n        for (const alternative of pattern.value.value) {\n            visitor.reset(regexp);\n            visitor.visit(alternative);\n            parts.push({\n                start: visitor.startRegexp,\n                end: visitor.endRegex\n            });\n        }\n        return parts;\n    } catch {\n        return [];\n    }\n}\n\nexport function isMultilineComment(regexp: RegExp | string): boolean {\n    try {\n        if (typeof regexp === 'string') {\n            regexp = new RegExp(regexp);\n        }\n        regexp = regexp.toString();\n        visitor.reset(regexp);\n        // Parsing the pattern might fail (since it's user code)\n        visitor.visit(regexpParser.pattern(regexp));\n        return visitor.multiline;\n    } catch {\n        return false;\n    }\n}\n\nexport function isWhitespace(value: RegExp | string): boolean {\n    const regexp = typeof value === 'string' ? new RegExp(value) : value;\n    return regexp.test(' ');\n}\n\nexport function escapeRegExp(value: string): string {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nexport function getCaseInsensitivePattern(keyword: string): string {\n    return Array.prototype.map.call(keyword, letter =>\n        /\\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)\n    ).join('');\n}\n\n/**\n * Determines whether the given input has a partial match with the specified regex.\n * @param regex The regex to partially match against\n * @param input The input string\n * @returns Whether any match exists.\n */\nexport function partialMatches(regex: RegExp | string, input: string): boolean {\n    const partial = partialRegExp(regex);\n    const match = input.match(partial);\n    return !!match && match[0].length > 0;\n}\n\n/**\n * Builds a partial regex from the input regex. A partial regex is able to match incomplete input strings. E.g.\n * a partial regex constructed from `/ab/` is able to match the string `a` without needing a following `b` character. However it won't match `b` alone.\n * @param regex The input regex to be converted.\n * @returns A partial regex constructed from the input regex.\n */\nexport function partialRegExp(regex: RegExp | string): RegExp {\n    if (typeof regex === 'string') {\n        regex = new RegExp(regex);\n    }\n    const re = regex, source = regex.source;\n    let i = 0;\n\n    function process() {\n        let result = '',\n            tmp;\n\n        function appendRaw(nbChars: number) {\n            result += source.substr(i, nbChars);\n            i += nbChars;\n        }\n\n        function appendOptional(nbChars: number) {\n            result += '(?:' + source.substr(i, nbChars) + '|$)';\n            i += nbChars;\n        }\n\n        while (i < source.length) {\n            switch (source[i]) {\n                case '\\\\':\n                    switch (source[i + 1]) {\n                        case 'c':\n                            appendOptional(3);\n                            break;\n                        case 'x':\n                            appendOptional(4);\n                            break;\n                        case 'u':\n                            if (re.unicode) {\n                                if (source[i + 2] === '{') {\n                                    appendOptional(source.indexOf('}', i) - i + 1);\n                                } else {\n                                    appendOptional(6);\n                                }\n                            } else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case 'p':\n                        case 'P':\n                            if (re.unicode) {\n                                appendOptional(source.indexOf('}', i) - i + 1);\n                            } else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case 'k':\n                            appendOptional(source.indexOf('>', i) - i + 1);\n                            break;\n                        default:\n                            appendOptional(2);\n                            break;\n                    }\n                    break;\n\n                case '[':\n                    tmp = /\\[(?:\\\\.|.)*?\\]/g;\n                    tmp.lastIndex = i;\n                    tmp = tmp.exec(source) || [];\n                    appendOptional(tmp[0].length);\n                    break;\n\n                case '|':\n                case '^':\n                case '$':\n                case '*':\n                case '+':\n                case '?':\n                    appendRaw(1);\n                    break;\n                case '{':\n                    tmp = /\\{\\d+,?\\d*\\}/g;\n                    tmp.lastIndex = i;\n                    tmp = tmp.exec(source);\n                    if (tmp) {\n                        appendRaw(tmp[0].length);\n                    } else {\n                        appendOptional(1);\n                    }\n                    break;\n                case '(':\n                    if (source[i + 1] === '?') {\n                        switch (source[i + 2]) {\n                            case ':':\n                                result += '(?:';\n                                i += 3;\n                                result += process() + '|$)';\n                                break;\n                            case '=':\n                                result += '(?=';\n                                i += 3;\n                                result += process() + ')';\n                                break;\n                            case '!':\n                                tmp = i;\n                                i += 3;\n                                process();\n                                result += source.substr(tmp, i - tmp);\n                                break;\n                            case '<':\n                                switch (source[i + 3]) {\n                                    case '=':\n                                    case '!':\n                                        tmp = i;\n                                        i += 4;\n                                        process();\n                                        result += source.substr(tmp, i - tmp);\n                                        break;\n                                    default:\n                                        appendRaw(source.indexOf('>', i) - i + 1);\n                                        result += process() + '|$)';\n                                        break;\n                                }\n                                break;\n                        }\n                    } else {\n                        appendRaw(1);\n                        result += process() + '|$)';\n                    }\n                    break;\n                case ')':\n                    ++i;\n                    return result;\n                default:\n                    appendOptional(1);\n                    break;\n            }\n        }\n\n        return result;\n    }\n\n    return new RegExp(process(), regex.flags);\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;;;;;;;;;AAGhF,OAAO,EAAE,YAAY,EAAE,iBAAiB,EAAE,MAAM,2BAA2B,CAAC;;AAErE,MAAM,cAAc,GAAG,SAAS,CAAC;AAExC,MAAM,YAAY,GAAG,qNAAI,eAAY,EAAE,CAAC;AAExC;;;;;;;;;;;;GAYG,CACH,MAAM,qBAAsB,mOAAQ,oBAAiB;IAArD,aAAA;;QAEY,IAAA,CAAA,UAAU,GAAG,IAAI,CAAC;QAElB,IAAA,CAAA,cAAc,GAAa,EAAE,CAAC;QACtC,IAAA,CAAA,SAAS,GAAG,KAAK,CAAC;IAoEtB,CAAC;IAjEG,IAAI,QAAQ,GAAA;QACR,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACxC,CAAC;IAED,KAAK,CAAC,KAAa,EAAA;QACf,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;QACvB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;QACtB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;IAC7B,CAAC;IAEQ,UAAU,CAAC,IAAW,EAAA;QAC3B,IAAI,IAAI,CAAC,UAAU,EAAE;YACjB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;YACxB,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;SAC5B;IACL,CAAC;IAEQ,cAAc,CAAC,IAAe,EAAA;QACnC,MAAM,IAAI,GAAG,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC7C,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,KAAK,IAAI,EAAE;YAClC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;SACzB;QACD,IAAI,IAAI,CAAC,UAAU,EAAE;YACjB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;YACxB,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;SAC5B,MAAM;YACH,MAAM,WAAW,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;YACvC,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YACtC,IAAI,IAAI,CAAC,UAAU,EAAE;gBACjB,IAAI,CAAC,WAAW,IAAI,WAAW,CAAC;aACnC;SACJ;IACL,CAAC;IAEQ,QAAQ,CAAC,IAAS,EAAA;QACvB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACjB,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAC/D,MAAM,KAAK,GAAG,IAAI,MAAM,CAAC,GAAG,CAAC,CAAC;YAC9B,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;SAC/C;QACD,IAAI,IAAI,CAAC,UAAU,EAAE;YACjB,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;YACxB,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;SAC5B,MAAM;YACH,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAC/D,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAC9B,IAAI,IAAI,CAAC,UAAU,EAAE;gBACjB,IAAI,CAAC,WAAW,IAAI,GAAG,CAAC;aAC3B;SACJ;IACL,CAAC;IAEQ,aAAa,CAAC,IAAgB,EAAA;QACnC,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;YACvB,oDAAoD;YACpD,8DAA8D;YAC9D,MAAM,KAAK,GAAG,IAAa,CAAC;YAC5B,IAAI,KAAK,CAAC,UAAU,EAAE;gBAClB,OAAO;aACV;SACJ;QACD,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAC9B,CAAC;CACJ;AAED,MAAM,OAAO,GAAG,IAAI,qBAAqB,EAAE,CAAC;AAEtC,SAAU,gBAAgB,CAAC,MAAuB;IACpD,IAAI;QACA,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;YAC5B,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;SAC1B;QACD,MAAM,GAAG,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA,CAAG,CAAC;QACvB,MAAM,OAAO,GAAG,YAAY,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAC7C,MAAM,KAAK,GAA0C,EAAE,CAAC;QACxD,KAAK,MAAM,WAAW,IAAI,OAAO,CAAC,KAAK,CAAC,KAAK,CAAE;YAC3C,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YACtB,OAAO,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YAC3B,KAAK,CAAC,IAAI,CAAC;gBACP,KAAK,EAAE,OAAO,CAAC,WAAW;gBAC1B,GAAG,EAAE,OAAO,CAAC,QAAQ;aACxB,CAAC,CAAC;SACN;QACD,OAAO,KAAK,CAAC;KAChB,CAAC,OAAA,IAAM;QACJ,OAAO,EAAE,CAAC;KACb;AACL,CAAC;AAEK,SAAU,kBAAkB,CAAC,MAAuB;IACtD,IAAI;QACA,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;YAC5B,MAAM,GAAG,IAAI,MAAM,CAAC,MAAM,CAAC,CAAC;SAC/B;QACD,MAAM,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;QAC3B,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QACtB,wDAAwD;QACxD,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;QAC5C,OAAO,OAAO,CAAC,SAAS,CAAC;KAC5B,CAAC,OAAA,IAAM;QACJ,OAAO,KAAK,CAAC;KAChB;AACL,CAAC;AAEK,SAAU,YAAY,CAAC,KAAsB;IAC/C,MAAM,MAAM,GAAG,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;IACrE,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC5B,CAAC;AAEK,SAAU,YAAY,CAAC,KAAa;IACtC,OAAO,KAAK,CAAC,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC,CAAC;AACxD,CAAC;AAEK,SAAU,yBAAyB,CAAC,OAAe;IACrD,OAAO,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,GAAE,MAAM,CAAC,EAAE,AAC9C,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAA,CAAA,EAAI,MAAM,CAAC,WAAW,EAAE,GAAG,MAAM,CAAC,WAAW,EAAE,CAAA,CAAA,CAAG,CAAC,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,CAChG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AACf,CAAC;AAQK,SAAU,cAAc,CAAC,KAAsB,EAAE,KAAa;IAChE,MAAM,OAAO,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC;IACrC,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;IACnC,OAAO,CAAC,CAAC,KAAK,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;AAC1C,CAAC;AAQK,SAAU,aAAa,CAAC,KAAsB;IAChD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC3B,KAAK,GAAG,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC;KAC7B;IACD,MAAM,EAAE,GAAG,KAAK,EAAE,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;IACxC,IAAI,CAAC,GAAG,CAAC,CAAC;IAEV,SAAS,OAAO;QACZ,IAAI,MAAM,GAAG,EAAE,EACX,GAAG,CAAC;QAER,SAAS,SAAS,CAAC,OAAe;YAC9B,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;YACpC,CAAC,IAAI,OAAO,CAAC;QACjB,CAAC;QAED,SAAS,cAAc,CAAC,OAAe;YACnC,MAAM,IAAI,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,OAAO,CAAC,GAAG,KAAK,CAAC;YACpD,CAAC,IAAI,OAAO,CAAC;QACjB,CAAC;QAED,MAAO,CAAC,GAAG,MAAM,CAAC,MAAM,CAAE;YACtB,OAAQ,MAAM,CAAC,CAAC,CAAC,EAAE;gBACf,KAAK,IAAI;oBACL,OAAQ,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;wBACnB,KAAK,GAAG;4BACJ,cAAc,CAAC,CAAC,CAAC,CAAC;4BAClB,MAAM;wBACV,KAAK,GAAG;4BACJ,cAAc,CAAC,CAAC,CAAC,CAAC;4BAClB,MAAM;wBACV,KAAK,GAAG;4BACJ,IAAI,EAAE,CAAC,OAAO,EAAE;gCACZ,IAAI,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;oCACvB,cAAc,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;iCAClD,MAAM;oCACH,cAAc,CAAC,CAAC,CAAC,CAAC;iCACrB;6BACJ,MAAM;gCACH,cAAc,CAAC,CAAC,CAAC,CAAC;6BACrB;4BACD,MAAM;wBACV,KAAK,GAAG,CAAC;wBACT,KAAK,GAAG;4BACJ,IAAI,EAAE,CAAC,OAAO,EAAE;gCACZ,cAAc,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;6BAClD,MAAM;gCACH,cAAc,CAAC,CAAC,CAAC,CAAC;6BACrB;4BACD,MAAM;wBACV,KAAK,GAAG;4BACJ,cAAc,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;4BAC/C,MAAM;wBACV;4BACI,cAAc,CAAC,CAAC,CAAC,CAAC;4BAClB,MAAM;qBACb;oBACD,MAAM;gBAEV,KAAK,GAAG;oBACJ,GAAG,GAAG,kBAAkB,CAAC;oBACzB,GAAG,CAAC,SAAS,GAAG,CAAC,CAAC;oBAClB,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;oBAC7B,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;oBAC9B,MAAM;gBAEV,KAAK,GAAG,CAAC;gBACT,KAAK,GAAG,CAAC;gBACT,KAAK,GAAG,CAAC;gBACT,KAAK,GAAG,CAAC;gBACT,KAAK,GAAG,CAAC;gBACT,KAAK,GAAG;oBACJ,SAAS,CAAC,CAAC,CAAC,CAAC;oBACb,MAAM;gBACV,KAAK,GAAG;oBACJ,GAAG,GAAG,eAAe,CAAC;oBACtB,GAAG,CAAC,SAAS,GAAG,CAAC,CAAC;oBAClB,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBACvB,IAAI,GAAG,EAAE;wBACL,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;qBAC5B,MAAM;wBACH,cAAc,CAAC,CAAC,CAAC,CAAC;qBACrB;oBACD,MAAM;gBACV,KAAK,GAAG;oBACJ,IAAI,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;wBACvB,OAAQ,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;4BACnB,KAAK,GAAG;gCACJ,MAAM,IAAI,KAAK,CAAC;gCAChB,CAAC,IAAI,CAAC,CAAC;gCACP,MAAM,IAAI,OAAO,EAAE,GAAG,KAAK,CAAC;gCAC5B,MAAM;4BACV,KAAK,GAAG;gCACJ,MAAM,IAAI,KAAK,CAAC;gCAChB,CAAC,IAAI,CAAC,CAAC;gCACP,MAAM,IAAI,OAAO,EAAE,GAAG,GAAG,CAAC;gCAC1B,MAAM;4BACV,KAAK,GAAG;gCACJ,GAAG,GAAG,CAAC,CAAC;gCACR,CAAC,IAAI,CAAC,CAAC;gCACP,OAAO,EAAE,CAAC;gCACV,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC;gCACtC,MAAM;4BACV,KAAK,GAAG;gCACJ,OAAQ,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;oCACnB,KAAK,GAAG,CAAC;oCACT,KAAK,GAAG;wCACJ,GAAG,GAAG,CAAC,CAAC;wCACR,CAAC,IAAI,CAAC,CAAC;wCACP,OAAO,EAAE,CAAC;wCACV,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC;wCACtC,MAAM;oCACV;wCACI,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;wCAC1C,MAAM,IAAI,OAAO,EAAE,GAAG,KAAK,CAAC;wCAC5B,MAAM;iCACb;gCACD,MAAM;yBACb;qBACJ,MAAM;wBACH,SAAS,CAAC,CAAC,CAAC,CAAC;wBACb,MAAM,IAAI,OAAO,EAAE,GAAG,KAAK,CAAC;qBAC/B;oBACD,MAAM;gBACV,KAAK,GAAG;oBACJ,EAAE,CAAC,CAAC;oBACJ,OAAO,MAAM,CAAC;gBAClB;oBACI,cAAc,CAAC,CAAC,CAAC,CAAC;oBAClB,MAAM;aACb;SACJ;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAED,OAAO,IAAI,MAAM,CAAC,OAAO,EAAE,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;AAC9C,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2646, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2652, "column": 0}, "map": {"version":3,"file":"grammar-utils.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/grammar-utils.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport { assertUnreachable } from '../utils/errors.js';\nimport * as ast from '../languages/generated/ast.js';\nimport type { AstNode, CstNode } from '../syntax-tree.js';\nimport { isCompositeCstNode } from '../syntax-tree.js';\nimport { getContainerOfType, streamAllContents } from './ast-utils.js';\nimport { streamCst } from './cst-utils.js';\nimport { escapeRegExp } from './regexp-utils.js';\n\n/**\n * Returns the entry rule of the given grammar, if any. If the grammar file does not contain an entry rule,\n * the result is `undefined`.\n */\nexport function getEntryRule(grammar: ast.Grammar): ast.ParserRule | undefined {\n    return grammar.rules.find(e => ast.isParserRule(e) && e.entry) as ast.ParserRule;\n}\n\n/**\n * Returns all hidden terminal rules of the given grammar, if any.\n */\nexport function getHiddenRules(grammar: ast.Grammar) {\n    return grammar.rules.filter((e): e is ast.TerminalRule => ast.isTerminalRule(e) && e.hidden);\n}\n\n/**\n * Returns all rules that can be reached from the topmost rules of the specified grammar (entry and hidden terminal rules).\n *\n * @param grammar The grammar that contains all rules\n * @param allTerminals Whether or not to include terminals that are referenced only by other terminals\n * @returns A list of referenced parser and terminal rules. If the grammar contains no entry rule,\n *      this function returns all rules of the specified grammar.\n */\nexport function getAllReachableRules(grammar: ast.Grammar, allTerminals: boolean): Set<ast.AbstractRule> {\n    const ruleNames = new Set<string>();\n    const entryRule = getEntryRule(grammar);\n    if (!entryRule) {\n        return new Set(grammar.rules);\n    }\n\n    const topMostRules = [entryRule as ast.AbstractRule].concat(getHiddenRules(grammar));\n    for (const rule of topMostRules) {\n        ruleDfs(rule, ruleNames, allTerminals);\n    }\n\n    const rules = new Set<ast.AbstractRule>();\n    for (const rule of grammar.rules) {\n        if (ruleNames.has(rule.name) || (ast.isTerminalRule(rule) && rule.hidden)) {\n            rules.add(rule);\n        }\n    }\n    return rules;\n}\n\nfunction ruleDfs(rule: ast.AbstractRule, visitedSet: Set<string>, allTerminals: boolean): void {\n    visitedSet.add(rule.name);\n    streamAllContents(rule).forEach(node => {\n        if (ast.isRuleCall(node) || (allTerminals && ast.isTerminalRuleCall(node))) {\n            const refRule = node.rule.ref;\n            if (refRule && !visitedSet.has(refRule.name)) {\n                ruleDfs(refRule, visitedSet, allTerminals);\n            }\n        }\n    });\n}\n\n/**\n * Determines the grammar expression used to parse a cross-reference (usually a reference to a terminal rule).\n * A cross-reference can declare this expression explicitly in the form `[Type : Terminal]`, but if `Terminal`\n * is omitted, this function attempts to infer it from the name of the referenced `Type` (using `findNameAssignment`).\n *\n * Returns the grammar expression used to parse the given cross-reference, or `undefined` if it is not declared\n * and cannot be inferred.\n */\nexport function getCrossReferenceTerminal(crossRef: ast.CrossReference): ast.AbstractElement | undefined {\n    if (crossRef.terminal) {\n        return crossRef.terminal;\n    } else if (crossRef.type.ref) {\n        const nameAssigment = findNameAssignment(crossRef.type.ref);\n        return nameAssigment?.terminal;\n    }\n    return undefined;\n}\n\n/**\n * Determines whether the given terminal rule represents a comment. This is true if the rule is marked\n * as `hidden` and it does not match white space. This means every hidden token (i.e. excluded from the AST)\n * that contains visible characters is considered a comment.\n */\nexport function isCommentTerminal(terminalRule: ast.TerminalRule): boolean {\n    return terminalRule.hidden && !terminalRegex(terminalRule).test(' ');\n}\n\n/**\n * Find all CST nodes within the given node that contribute to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is an empty array.\n * @param property A property name of the constructed AST node. If this is undefined, the result is an empty array.\n */\nexport function findNodesForProperty(node: CstNode | undefined, property: string | undefined): CstNode[] {\n    if (!node || !property) {\n        return [];\n    }\n    return findNodesForPropertyInternal(node, property, node.astNode, true);\n}\n\n/**\n * Find a single CST node within the given node that contributes to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is `undefined`.\n * @param property A property name of the constructed AST node. If this is undefined, the result is `undefined`.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of assignments to the property, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nexport function findNodeForProperty(node: CstNode | undefined, property: string | undefined, index?: number): CstNode | undefined {\n    if (!node || !property) {\n        return undefined;\n    }\n    const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    } else {\n        index = 0;\n    }\n    return nodes[index];\n}\n\nfunction findNodesForPropertyInternal(node: CstNode, property: string, element: AstNode | undefined, first: boolean): CstNode[] {\n    if (!first) {\n        const nodeFeature = getContainerOfType(node.grammarSource, ast.isAssignment);\n        if (nodeFeature && nodeFeature.feature === property) {\n            return [node];\n        }\n    }\n    if (isCompositeCstNode(node) && node.astNode === element) {\n        return node.content.flatMap(e => findNodesForPropertyInternal(e, property, element, false));\n    }\n    return [];\n}\n\n/**\n * Find all CST nodes within the given node that correspond to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is an empty array.\n * @param keyword A keyword as specified in the grammar.\n */\nexport function findNodesForKeyword(node: CstNode | undefined, keyword: string): CstNode[] {\n    if (!node) {\n        return [];\n    }\n    return findNodesForKeywordInternal(node, keyword, node?.astNode);\n}\n\n/**\n * Find a single CST node within the given node that corresponds to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is `undefined`.\n * @param keyword A keyword as specified in the grammar.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of keyword occurrences, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nexport function findNodeForKeyword(node: CstNode | undefined, keyword: string, index?: number): CstNode | undefined {\n    if (!node) {\n        return undefined;\n    }\n    const nodes = findNodesForKeywordInternal(node, keyword, node?.astNode);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    } else {\n        index = 0;\n    }\n    return nodes[index];\n}\n\nexport function findNodesForKeywordInternal(node: CstNode, keyword: string, element: AstNode | undefined): CstNode[] {\n    if (node.astNode !== element) {\n        return [];\n    }\n    if (ast.isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {\n        return [node];\n    }\n    const treeIterator = streamCst(node).iterator();\n    let result: IteratorResult<CstNode>;\n    const keywordNodes: CstNode[] = [];\n    do {\n        result = treeIterator.next();\n        if (!result.done) {\n            const childNode = result.value;\n            if (childNode.astNode === element) {\n                if (ast.isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {\n                    keywordNodes.push(childNode);\n                }\n            } else {\n                treeIterator.prune();\n            }\n        }\n    } while (!result.done);\n    return keywordNodes;\n}\n\n/**\n * If the given CST node was parsed in the context of a property assignment, the respective `Assignment` grammar\n * node is returned. If no assignment is found, the result is `undefined`.\n *\n * @param cstNode A CST node for which to find a property assignment.\n */\nexport function findAssignment(cstNode: CstNode): ast.Assignment | undefined {\n    const astNode = cstNode.astNode;\n    // Only search until the ast node of the parent cst node is no longer the original ast node\n    // This would make us jump to a preceding rule call, which contains only unrelated assignments\n    while (astNode === cstNode.container?.astNode) {\n        const assignment = getContainerOfType(cstNode.grammarSource, ast.isAssignment);\n        if (assignment) {\n            return assignment;\n        }\n        cstNode = cstNode.container;\n    }\n    return undefined;\n}\n\n/**\n * Find an assignment to the `name` property for the given grammar type. This requires the `type` to be inferred\n * from a parser rule, and that rule must contain an assignment to the `name` property. In all other cases,\n * this function returns `undefined`.\n */\nexport function findNameAssignment(type: ast.AbstractType): ast.Assignment | undefined {\n    let startNode: AstNode = type;\n    if (ast.isInferredType(startNode)) {\n        // for inferred types, the location to start searching for the name-assignment is different\n        if (ast.isAction(startNode.$container)) {\n            // a type which is explicitly inferred by an action: investigate the sibbling of the Action node, i.e. start searching at the Action's parent\n            startNode = startNode.$container.$container!;\n        } else if (ast.isParserRule(startNode.$container)) {\n            // investigate the parser rule with the explicitly inferred type\n            startNode = startNode.$container;\n        } else {\n            assertUnreachable(startNode.$container);\n        }\n    }\n    return findNameAssignmentInternal(type, startNode, new Map());\n}\n\nfunction findNameAssignmentInternal(type: ast.AbstractType, startNode: AstNode, cache: Map<ast.AbstractType, ast.Assignment | undefined>): ast.Assignment | undefined {\n    // the cache is only required to prevent infinite loops\n    function go(node: AstNode, refType: ast.AbstractType): ast.Assignment | undefined {\n        let childAssignment: ast.Assignment | undefined = undefined;\n        const parentAssignment = getContainerOfType(node, ast.isAssignment);\n        // No parent assignment implies unassigned rule call\n        if (!parentAssignment) {\n            childAssignment = findNameAssignmentInternal(refType, refType, cache);\n        }\n        cache.set(type, childAssignment);\n        return childAssignment;\n    }\n\n    if (cache.has(type)) {\n        return cache.get(type);\n    }\n    cache.set(type, undefined);\n    for (const node of streamAllContents(startNode)) {\n        if (ast.isAssignment(node) && node.feature.toLowerCase() === 'name') {\n            cache.set(type, node);\n            return node;\n        } else if (ast.isRuleCall(node) && ast.isParserRule(node.rule.ref)) {\n            return go(node, node.rule.ref);\n        } else if (ast.isSimpleType(node) && node.typeRef?.ref) {\n            return go(node, node.typeRef.ref);\n        }\n    }\n    return undefined;\n}\n\nexport function getActionAtElement(element: ast.AbstractElement): ast.Action | undefined {\n    const parent = element.$container;\n    if (ast.isGroup(parent)) {\n        const elements = parent.elements;\n        const index = elements.indexOf(element);\n        for (let i = index - 1; i >= 0; i--) {\n            const item = elements[i];\n            if (ast.isAction(item)) {\n                return item;\n            } else {\n                const action = streamAllContents(elements[i]).find(ast.isAction);\n                if (action) {\n                    return action;\n                }\n            }\n        }\n    }\n    if (ast.isAbstractElement(parent)) {\n        return getActionAtElement(parent);\n    } else {\n        return undefined;\n    }\n}\n\nexport type Cardinality = '?' | '*' | '+' | undefined;\nexport type Operator = '=' | '+=' | '?=' | undefined;\n\nexport function isOptionalCardinality(cardinality?: Cardinality, element?: ast.AbstractElement): boolean {\n    return cardinality === '?' || cardinality === '*' || (ast.isGroup(element) && Boolean(element.guardCondition));\n}\n\nexport function isArrayCardinality(cardinality?: Cardinality): boolean {\n    return cardinality === '*' || cardinality === '+';\n}\n\nexport function isArrayOperator(operator?: Operator): boolean {\n    return operator === '+=';\n}\n\n/**\n * Determines whether the given parser rule is a _data type rule_, meaning that it has a\n * primitive return type like `number`, `boolean`, etc.\n */\nexport function isDataTypeRule(rule: ast.ParserRule): boolean {\n    return isDataTypeRuleInternal(rule, new Set());\n}\n\nfunction isDataTypeRuleInternal(rule: ast.ParserRule, visited: Set<ast.ParserRule>): boolean {\n    if (visited.has(rule)) {\n        return true;\n    } else {\n        visited.add(rule);\n    }\n    for (const node of streamAllContents(rule)) {\n        if (ast.isRuleCall(node)) {\n            if (!node.rule.ref) {\n                // RuleCall to unresolved rule. Don't assume `rule` is a DataType rule.\n                return false;\n            }\n            if (ast.isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {\n                return false;\n            }\n        } else if (ast.isAssignment(node)) {\n            return false;\n        } else if (ast.isAction(node)) {\n            return false;\n        }\n    }\n    return Boolean(rule.definition);\n}\n\nexport function isDataType(type: ast.Type): boolean {\n    return isDataTypeInternal(type.type, new Set());\n}\n\nfunction isDataTypeInternal(type: ast.TypeDefinition, visited: Set<ast.TypeDefinition>): boolean {\n    if (visited.has(type)) {\n        return true;\n    } else {\n        visited.add(type);\n    }\n    if (ast.isArrayType(type)) {\n        return false;\n    } else if (ast.isReferenceType(type)) {\n        return false;\n    } else if (ast.isUnionType(type)) {\n        return type.types.every(e => isDataTypeInternal(e, visited));\n    } else if (ast.isSimpleType(type)) {\n        if (type.primitiveType !== undefined) {\n            return true;\n        } else if (type.stringType !== undefined) {\n            return true;\n        } else if (type.typeRef !== undefined) {\n            const ref = type.typeRef.ref;\n            if (ast.isType(ref)) {\n                return isDataTypeInternal(ref.type, visited);\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n}\n\nexport function getExplicitRuleType(rule: ast.ParserRule): string | undefined {\n    if (rule.inferredType) {\n        return rule.inferredType.name;\n    } else if (rule.dataType) {\n        return rule.dataType;\n    } else if (rule.returnType) {\n        const refType = rule.returnType.ref;\n        if(refType) {\n            // check if we need to check Action as return type\n            if (ast.isParserRule(refType)) {\n                return refType.name;\n            }  else if(ast.isInterface(refType) || ast.isType(refType)) {\n                return refType.name;\n            }\n        }\n    }\n    return undefined;\n}\n\nexport function getTypeName(type: ast.AbstractType | ast.Action): string {\n    if (ast.isParserRule(type)) {\n        return isDataTypeRule(type) ? type.name : getExplicitRuleType(type) ?? type.name;\n    } else if (ast.isInterface(type) || ast.isType(type) || ast.isReturnType(type)) {\n        return type.name;\n    } else if (ast.isAction(type)) {\n        const actionType = getActionType(type);\n        if (actionType) {\n            return actionType;\n        }\n    } else if (ast.isInferredType(type)) {\n        return type.name;\n    }\n    throw new Error('Cannot get name of Unknown Type');\n}\n\nexport function getActionType(action: ast.Action): string | undefined {\n    if (action.inferredType) {\n        return action.inferredType.name;\n    } else if (action.type?.ref) {\n        return getTypeName(action.type.ref);\n    }\n    return undefined; // not inferring and not referencing a valid type\n}\n\nexport function getRuleType(rule: ast.AbstractRule): string {\n    if (ast.isTerminalRule(rule)) {\n        return rule.type?.name ?? 'string';\n    } else {\n        return isDataTypeRule(rule) ? rule.name : getExplicitRuleType(rule) ?? rule.name;\n    }\n}\n\nexport function terminalRegex(terminalRule: ast.TerminalRule): RegExp {\n    const flags: Flags = {\n        s: false,\n        i: false,\n        u: false\n    };\n    const source = abstractElementToRegex(terminalRule.definition, flags);\n    const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join('');\n    return new RegExp(source, flagText);\n}\n\n// Using [\\s\\S]* allows to match everything, compared to . which doesn't match line terminators\nconst WILDCARD = /[\\s\\S]/.source;\n\ntype Flags = {\n    s: boolean;\n    i: boolean;\n    u: boolean;\n}\n\nfunction abstractElementToRegex(element: ast.AbstractElement, flags?: Flags): string {\n    if (ast.isTerminalAlternatives(element)) {\n        return terminalAlternativesToRegex(element);\n    } else if (ast.isTerminalGroup(element)) {\n        return terminalGroupToRegex(element);\n    } else if (ast.isCharacterRange(element)) {\n        return characterRangeToRegex(element);\n    } else if (ast.isTerminalRuleCall(element)) {\n        const rule = element.rule.ref;\n        if (!rule) {\n            throw new Error('Missing rule reference.');\n        }\n        return withCardinality(abstractElementToRegex(rule.definition), {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    } else if (ast.isNegatedToken(element)) {\n        return negateTokenToRegex(element);\n    } else if (ast.isUntilToken(element)) {\n        return untilTokenToRegex(element);\n    } else if (ast.isRegexToken(element)) {\n        const lastSlash = element.regex.lastIndexOf('/');\n        const source = element.regex.substring(1, lastSlash);\n        const regexFlags = element.regex.substring(lastSlash + 1);\n        if (flags) {\n            flags.i = regexFlags.includes('i');\n            flags.s = regexFlags.includes('s');\n            flags.u = regexFlags.includes('u');\n        }\n        return withCardinality(source, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead,\n            wrap: false\n        });\n    } else if (ast.isWildcard(element)) {\n        return withCardinality(WILDCARD, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    } else {\n        throw new Error(`Invalid terminal element: ${element?.$type}`);\n    }\n}\n\nfunction terminalAlternativesToRegex(alternatives: ast.TerminalAlternatives): string {\n    return withCardinality(alternatives.elements.map(e => abstractElementToRegex(e)).join('|'), {\n        cardinality: alternatives.cardinality,\n        lookahead: alternatives.lookahead\n    });\n}\n\nfunction terminalGroupToRegex(group: ast.TerminalGroup): string {\n    return withCardinality(group.elements.map(e => abstractElementToRegex(e)).join(''), {\n        cardinality: group.cardinality,\n        lookahead: group.lookahead\n    });\n}\n\nfunction untilTokenToRegex(until: ast.UntilToken): string {\n    return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {\n        cardinality: until.cardinality,\n        lookahead: until.lookahead\n    });\n}\n\nfunction negateTokenToRegex(negate: ast.NegatedToken): string {\n    return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {\n        cardinality: negate.cardinality,\n        lookahead: negate.lookahead\n    });\n}\n\nfunction characterRangeToRegex(range: ast.CharacterRange): string {\n    if (range.right) {\n        return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {\n            cardinality: range.cardinality,\n            lookahead: range.lookahead,\n            wrap: false\n        });\n    }\n    return withCardinality(keywordToRegex(range.left), {\n        cardinality: range.cardinality,\n        lookahead: range.lookahead,\n        wrap: false\n    });\n}\n\nfunction keywordToRegex(keyword: ast.Keyword): string {\n    return escapeRegExp(keyword.value);\n}\n\nfunction withCardinality(regex: string, options: {\n    cardinality?: string\n    wrap?: boolean\n    lookahead?: string\n}): string {\n    if (options.wrap !== false || options.lookahead) {\n        regex = `(${options.lookahead ?? ''}${regex})`;\n    }\n    if (options.cardinality) {\n        return `${regex}${options.cardinality}`;\n    }\n    return regex;\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;;;;;;;;;;;;;;;;;;;;;;AAEhF,OAAO,EAAE,iBAAiB,EAAE,MAAM,oBAAoB,CAAC;AACvD,OAAO,KAAK,GAAG,MAAM,+BAA+B,CAAC;AAErD,OAAO,EAAE,kBAAkB,EAAE,MAAM,mBAAmB,CAAC;AACvD,OAAO,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,MAAM,gBAAgB,CAAC;AACvE,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAC3C,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;;;;;;;AAM3C,SAAU,YAAY,CAAC,OAAoB;IAC7C,OAAO,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,wLAAC,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,CAAmB,CAAC;AACrF,CAAC;AAKK,SAAU,cAAc,CAAC,OAAoB;IAC/C,OAAO,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAyB,CAAG,CAAD,EAAI,wLAAC,cAAc,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC;AACjG,CAAC;AAUK,SAAU,oBAAoB,CAAC,OAAoB,EAAE,YAAqB;IAC5E,MAAM,SAAS,GAAG,IAAI,GAAG,EAAU,CAAC;IACpC,MAAM,SAAS,GAAG,YAAY,CAAC,OAAO,CAAC,CAAC;IACxC,IAAI,CAAC,SAAS,EAAE;QACZ,OAAO,IAAI,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;KACjC;IAED,MAAM,YAAY,GAAG;QAAC,SAA6B;KAAC,CAAC,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC;IACrF,KAAK,MAAM,IAAI,IAAI,YAAY,CAAE;QAC7B,OAAO,CAAC,IAAI,EAAE,SAAS,EAAE,YAAY,CAAC,CAAC;KAC1C;IAED,MAAM,KAAK,GAAG,IAAI,GAAG,EAAoB,CAAC;IAC1C,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,KAAK,CAAE;QAC9B,IAAI,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,AAAC,GAAG,wLAAC,cAAc,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,CAAE;YACvE,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;SACnB;KACJ;IACD,OAAO,KAAK,CAAC;AACjB,CAAC;AAED,SAAS,OAAO,CAAC,IAAsB,EAAE,UAAuB,EAAE,YAAqB;IACnF,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;2LAC1B,oBAAA,AAAiB,EAAC,IAAI,CAAC,CAAC,OAAO,EAAC,IAAI,CAAC,EAAE;QACnC,IAAI,GAAG,wLAAC,UAAU,CAAC,IAAI,CAAC,IAAI,AAAC,YAAY,IAAI,GAAG,wLAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAE;YACxE,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;YAC9B,IAAI,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBAC1C,OAAO,CAAC,OAAO,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;aAC9C;SACJ;IACL,CAAC,CAAC,CAAC;AACP,CAAC;AAUK,SAAU,yBAAyB,CAAC,QAA4B;IAClE,IAAI,QAAQ,CAAC,QAAQ,EAAE;QACnB,OAAO,QAAQ,CAAC,QAAQ,CAAC;KAC5B,MAAM,IAAI,QAAQ,CAAC,IAAI,CAAC,GAAG,EAAE;QAC1B,MAAM,aAAa,GAAG,kBAAkB,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC5D,OAAO,aAAa,KAAA,QAAb,aAAa,KAAA,KAAA,IAAA,KAAA,IAAb,aAAa,CAAE,QAAQ,CAAC;KAClC;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAOK,SAAU,iBAAiB,CAAC,YAA8B;IAC5D,OAAO,YAAY,CAAC,MAAM,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACzE,CAAC;AAQK,SAAU,oBAAoB,CAAC,IAAyB,EAAE,QAA4B;IACxF,IAAI,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE;QACpB,OAAO,EAAE,CAAC;KACb;IACD,OAAO,4BAA4B,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AAC5E,CAAC;AAWK,SAAU,mBAAmB,CAAC,IAAyB,EAAE,QAA4B,EAAE,KAAc;IACvG,IAAI,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE;QACpB,OAAO,SAAS,CAAC;KACpB;IACD,MAAM,KAAK,GAAG,4BAA4B,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAC/E,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QACpB,OAAO,SAAS,CAAC;KACpB;IACD,IAAI,KAAK,KAAK,SAAS,EAAE;QACrB,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;KAC1D,MAAM;QACH,KAAK,GAAG,CAAC,CAAC;KACb;IACD,OAAO,KAAK,CAAC,KAAK,CAAC,CAAC;AACxB,CAAC;AAED,SAAS,4BAA4B,CAAC,IAAa,EAAE,QAAgB,EAAE,OAA4B,EAAE,KAAc;IAC/G,IAAI,CAAC,KAAK,EAAE;QACR,MAAM,WAAW,0LAAG,qBAAA,AAAkB,EAAC,IAAI,CAAC,aAAa,EAAE,GAAG,wLAAC,YAAY,CAAC,CAAC;QAC7E,IAAI,WAAW,IAAI,WAAW,CAAC,OAAO,KAAK,QAAQ,EAAE;YACjD,OAAO;gBAAC,IAAI;aAAC,CAAC;SACjB;KACJ;IACD,KAAI,oMAAA,AAAkB,EAAC,IAAI,CAAC,IAAI,IAAI,CAAC,OAAO,KAAK,OAAO,EAAE;QACtD,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,EAAC,CAAC,CAAC,EAAE,AAAC,4BAA4B,CAAC,CAAC,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;KAC/F;IACD,OAAO,EAAE,CAAC;AACd,CAAC;AAQK,SAAU,mBAAmB,CAAC,IAAyB,EAAE,OAAe;IAC1E,IAAI,CAAC,IAAI,EAAE;QACP,OAAO,EAAE,CAAC;KACb;IACD,OAAO,2BAA2B,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,KAAA,QAAJ,IAAI,KAAA,KAAA,IAAA,KAAA,IAAJ,IAAI,CAAE,OAAO,CAAC,CAAC;AACrE,CAAC;AAWK,SAAU,kBAAkB,CAAC,IAAyB,EAAE,OAAe,EAAE,KAAc;IACzF,IAAI,CAAC,IAAI,EAAE;QACP,OAAO,SAAS,CAAC;KACpB;IACD,MAAM,KAAK,GAAG,2BAA2B,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,KAAA,QAAJ,IAAI,KAAA,KAAA,IAAA,KAAA,IAAJ,IAAI,CAAE,OAAO,CAAC,CAAC;IACxE,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QACpB,OAAO,SAAS,CAAC;KACpB;IACD,IAAI,KAAK,KAAK,SAAS,EAAE;QACrB,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;KAC1D,MAAM;QACH,KAAK,GAAG,CAAC,CAAC;KACb;IACD,OAAO,KAAK,CAAC,KAAK,CAAC,CAAC;AACxB,CAAC;AAEK,SAAU,2BAA2B,CAAC,IAAa,EAAE,OAAe,EAAE,OAA4B;IACpG,IAAI,IAAI,CAAC,OAAO,KAAK,OAAO,EAAE;QAC1B,OAAO,EAAE,CAAC;KACb;IACD,IAAI,GAAG,wLAAC,SAAS,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,KAAK,KAAK,OAAO,EAAE;QAC3E,OAAO;YAAC,IAAI;SAAC,CAAC;KACjB;IACD,MAAM,YAAY,0LAAG,YAAA,AAAS,EAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,CAAC;IAChD,IAAI,MAA+B,CAAC;IACpC,MAAM,YAAY,GAAc,EAAE,CAAC;IACnC,GAAG;QACC,MAAM,GAAG,YAAY,CAAC,IAAI,EAAE,CAAC;QAC7B,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;YACd,MAAM,SAAS,GAAG,MAAM,CAAC,KAAK,CAAC;YAC/B,IAAI,SAAS,CAAC,OAAO,KAAK,OAAO,EAAE;gBAC/B,IAAI,GAAG,wLAAC,SAAS,CAAC,SAAS,CAAC,aAAa,CAAC,IAAI,SAAS,CAAC,aAAa,CAAC,KAAK,KAAK,OAAO,EAAE;oBACrF,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;iBAChC;aACJ,MAAM;gBACH,YAAY,CAAC,KAAK,EAAE,CAAC;aACxB;SACJ;KACJ,OAAQ,CAAC,MAAM,CAAC,IAAI,CAAE;IACvB,OAAO,YAAY,CAAC;AACxB,CAAC;AAQK,SAAU,cAAc,CAAC,OAAgB;;IAC3C,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAChC,2FAA2F;IAC3F,8FAA8F;IAC9F,MAAO,OAAO,KAAA,CAAK,CAAA,KAAA,OAAO,CAAC,SAAS,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,OAAO,CAAA,CAAE;QAC3C,MAAM,UAAU,0LAAG,qBAAA,AAAkB,EAAC,OAAO,CAAC,aAAa,EAAE,GAAG,wLAAC,YAAY,CAAC,CAAC;QAC/E,IAAI,UAAU,EAAE;YACZ,OAAO,UAAU,CAAC;SACrB;QACD,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC;KAC/B;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAOK,SAAU,kBAAkB,CAAC,IAAsB;IACrD,IAAI,SAAS,GAAY,IAAI,CAAC;IAC9B,IAAI,GAAG,wLAAC,cAAc,CAAC,SAAS,CAAC,EAAE;QAC/B,2FAA2F;QAC3F,IAAI,GAAG,wLAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE;YACpC,6IAA6I;YAC7I,SAAS,GAAG,SAAS,CAAC,UAAU,CAAC,UAAW,CAAC;SAChD,MAAM,IAAI,GAAG,wLAAC,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE;YAC/C,gEAAgE;YAChE,SAAS,GAAG,SAAS,CAAC,UAAU,CAAC;SACpC,MAAM;6LACH,oBAAA,AAAiB,EAAC,SAAS,CAAC,UAAU,CAAC,CAAC;SAC3C;KACJ;IACD,OAAO,0BAA0B,CAAC,IAAI,EAAE,SAAS,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;AAClE,CAAC;AAED,SAAS,0BAA0B,CAAC,IAAsB,EAAE,SAAkB,EAAE,KAAwD;;IACpI,uDAAuD;IACvD,SAAS,EAAE,CAAC,IAAa,EAAE,OAAyB;QAChD,IAAI,eAAe,GAA+B,SAAS,CAAC;QAC5D,MAAM,gBAAgB,0LAAG,qBAAA,AAAkB,EAAC,IAAI,EAAE,GAAG,wLAAC,YAAY,CAAC,CAAC;QACpE,oDAAoD;QACpD,IAAI,CAAC,gBAAgB,EAAE;YACnB,eAAe,GAAG,0BAA0B,CAAC,OAAO,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;SACzE;QACD,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;QACjC,OAAO,eAAe,CAAC;IAC3B,CAAC;IAED,IAAI,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;QACjB,OAAO,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;KAC1B;IACD,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IAC3B,KAAK,MAAM,IAAI,IAAI,2MAAA,AAAiB,EAAC,SAAS,CAAC,CAAE;QAC7C,IAAI,GAAG,wLAAC,YAAY,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,KAAK,MAAM,EAAE;YACjE,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YACtB,OAAO,IAAI,CAAC;SACf,MAAM,IAAI,GAAG,wLAAC,UAAU,CAAC,IAAI,CAAC,IAAI,GAAG,wLAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YAChE,OAAO,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SAClC,MAAM,IAAI,GAAG,wLAAC,YAAY,CAAC,IAAI,CAAC,IAAA,CAAI,CAAA,KAAA,IAAI,CAAC,OAAO,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,GAAG,CAAA,EAAE;YACpD,OAAO,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;SACrC;KACJ;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAEK,SAAU,kBAAkB,CAAC,OAA4B;IAC3D,MAAM,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC;IAClC,IAAI,GAAG,wLAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QACrB,MAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;QACjC,MAAM,KAAK,GAAG,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QACxC,IAAK,IAAI,CAAC,GAAG,KAAK,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAE;YACjC,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YACzB,IAAI,GAAG,wLAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBACpB,OAAO,IAAI,CAAC;aACf,MAAM;gBACH,MAAM,MAAM,0LAAG,oBAAA,AAAiB,EAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,wLAAC,QAAQ,CAAC,CAAC;gBACjE,IAAI,MAAM,EAAE;oBACR,OAAO,MAAM,CAAC;iBACjB;aACJ;SACJ;KACJ;IACD,IAAI,GAAG,wLAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE;QAC/B,OAAO,kBAAkB,CAAC,MAAM,CAAC,CAAC;KACrC,MAAM;QACH,OAAO,SAAS,CAAC;KACpB;AACL,CAAC;AAKK,SAAU,qBAAqB,CAAC,WAAyB,EAAE,OAA6B;IAC1F,OAAO,WAAW,KAAK,GAAG,IAAI,WAAW,KAAK,GAAG,IAAI,AAAC,GAAG,wLAAC,OAAO,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC;AACnH,CAAC;AAEK,SAAU,kBAAkB,CAAC,WAAyB;IACxD,OAAO,WAAW,KAAK,GAAG,IAAI,WAAW,KAAK,GAAG,CAAC;AACtD,CAAC;AAEK,SAAU,eAAe,CAAC,QAAmB;IAC/C,OAAO,QAAQ,KAAK,IAAI,CAAC;AAC7B,CAAC;AAMK,SAAU,cAAc,CAAC,IAAoB;IAC/C,OAAO,sBAAsB,CAAC,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;AACnD,CAAC;AAED,SAAS,sBAAsB,CAAC,IAAoB,EAAE,OAA4B;IAC9E,IAAI,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;QACnB,OAAO,IAAI,CAAC;KACf,MAAM;QACH,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;KACrB;IACD,KAAK,MAAM,IAAI,KAAI,0MAAA,AAAiB,EAAC,IAAI,CAAC,CAAE;QACxC,IAAI,GAAG,wLAAC,UAAU,CAAC,IAAI,CAAC,EAAE;YACtB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE;gBAChB,uEAAuE;gBACvE,OAAO,KAAK,CAAC;aAChB;YACD,IAAI,GAAG,wLAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,OAAO,CAAC,EAAE;gBACpF,OAAO,KAAK,CAAC;aAChB;SACJ,MAAM,IAAI,GAAG,wLAAC,YAAY,CAAC,IAAI,CAAC,EAAE;YAC/B,OAAO,KAAK,CAAC;SAChB,MAAM,IAAI,GAAG,wLAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;YAC3B,OAAO,KAAK,CAAC;SAChB;KACJ;IACD,OAAO,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AACpC,CAAC;AAEK,SAAU,UAAU,CAAC,IAAc;IACrC,OAAO,kBAAkB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;AACpD,CAAC;AAED,SAAS,kBAAkB,CAAC,IAAwB,EAAE,OAAgC;IAClF,IAAI,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;QACnB,OAAO,IAAI,CAAC;KACf,MAAM;QACH,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;KACrB;IACD,IAAI,GAAG,wLAAC,WAAW,CAAC,IAAI,CAAC,EAAE;QACvB,OAAO,KAAK,CAAC;KAChB,MAAM,IAAI,GAAG,wLAAC,eAAe,CAAC,IAAI,CAAC,EAAE;QAClC,OAAO,KAAK,CAAC;KAChB,MAAM,IAAI,GAAG,wLAAC,WAAW,CAAC,IAAI,CAAC,EAAE;QAC9B,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,EAAC,CAAC,CAAC,EAAE,AAAC,kBAAkB,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;KAChE,MAAM,IAAI,GAAG,wLAAC,YAAY,CAAC,IAAI,CAAC,EAAE;QAC/B,IAAI,IAAI,CAAC,aAAa,KAAK,SAAS,EAAE;YAClC,OAAO,IAAI,CAAC;SACf,MAAM,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAAE;YACtC,OAAO,IAAI,CAAC;SACf,MAAM,IAAI,IAAI,CAAC,OAAO,KAAK,SAAS,EAAE;YACnC,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;YAC7B,IAAI,GAAG,wLAAC,MAAM,CAAC,GAAG,CAAC,EAAE;gBACjB,OAAO,kBAAkB,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;aAChD,MAAM;gBACH,OAAO,KAAK,CAAC;aAChB;SACJ,MAAM;YACH,OAAO,KAAK,CAAC;SAChB;KACJ,MAAM;QACH,OAAO,KAAK,CAAC;KAChB;AACL,CAAC;AAEK,SAAU,mBAAmB,CAAC,IAAoB;IACpD,IAAI,IAAI,CAAC,YAAY,EAAE;QACnB,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;KACjC,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;QACtB,OAAO,IAAI,CAAC,QAAQ,CAAC;KACxB,MAAM,IAAI,IAAI,CAAC,UAAU,EAAE;QACxB,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;QACpC,IAAG,OAAO,EAAE;YACR,kDAAkD;YAClD,IAAI,GAAG,wLAAC,YAAY,CAAC,OAAO,CAAC,EAAE;gBAC3B,OAAO,OAAO,CAAC,IAAI,CAAC;aACvB,MAAO,IAAG,GAAG,wLAAC,WAAW,CAAC,OAAO,CAAC,IAAI,GAAG,wLAAC,MAAM,CAAC,OAAO,CAAC,EAAE;gBACxD,OAAO,OAAO,CAAC,IAAI,CAAC;aACvB;SACJ;KACJ;IACD,OAAO,SAAS,CAAC;AACrB,CAAC;AAEK,SAAU,WAAW,CAAC,IAAmC;;IAC3D,IAAI,GAAG,wLAAC,YAAY,CAAC,IAAI,CAAC,EAAE;QACxB,OAAO,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA,KAAA,mBAAmB,CAAC,IAAI,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,CAAC,IAAI,CAAC;KACpF,MAAM,IAAI,GAAG,wLAAC,WAAW,CAAC,IAAI,CAAC,IAAI,GAAG,wLAAC,MAAM,CAAC,IAAI,CAAC,IAAI,GAAG,wLAAC,YAAY,CAAC,IAAI,CAAC,EAAE;QAC5E,OAAO,IAAI,CAAC,IAAI,CAAC;KACpB,MAAM,IAAI,GAAG,wLAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;QAC3B,MAAM,UAAU,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;QACvC,IAAI,UAAU,EAAE;YACZ,OAAO,UAAU,CAAC;SACrB;KACJ,MAAM,IAAI,GAAG,wLAAC,cAAc,CAAC,IAAI,CAAC,EAAE;QACjC,OAAO,IAAI,CAAC,IAAI,CAAC;KACpB;IACD,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;AACvD,CAAC;AAEK,SAAU,aAAa,CAAC,MAAkB;;IAC5C,IAAI,MAAM,CAAC,YAAY,EAAE;QACrB,OAAO,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC;KACnC,MAAM,IAAI,CAAA,KAAA,MAAM,CAAC,IAAI,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,GAAG,EAAE;QACzB,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;KACvC;IACD,OAAO,SAAS,CAAC,CAAC,iDAAiD;AACvE,CAAC;AAEK,SAAU,WAAW,CAAC,IAAsB;;IAC9C,IAAI,GAAG,wLAAC,cAAc,CAAC,IAAI,CAAC,EAAE;QAC1B,OAAO,CAAA,KAAA,CAAA,KAAA,IAAI,CAAC,IAAI,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,IAAI,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,QAAQ,CAAC;KACtC,MAAM;QACH,OAAO,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA,KAAA,mBAAmB,CAAC,IAAI,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,CAAC,IAAI,CAAC;KACpF;AACL,CAAC;AAEK,SAAU,aAAa,CAAC,YAA8B;IACxD,MAAM,KAAK,GAAU;QACjB,CAAC,EAAE,KAAK;QACR,CAAC,EAAE,KAAK;QACR,CAAC,EAAE,KAAK;KACX,CAAC;IACF,MAAM,MAAM,GAAG,sBAAsB,CAAC,YAAY,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IACtE,MAAM,QAAQ,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,CAAG,CAAD,IAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAG,CAAD,GAAK,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnG,OAAO,IAAI,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;AACxC,CAAC;AAED,+FAA+F;AAC/F,MAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC;AAQjC,SAAS,sBAAsB,CAAC,OAA4B,EAAE,KAAa;IACvE,IAAI,GAAG,wLAAC,sBAAsB,CAAC,OAAO,CAAC,EAAE;QACrC,OAAO,2BAA2B,CAAC,OAAO,CAAC,CAAC;KAC/C,MAAM,IAAI,GAAG,wLAAC,eAAe,CAAC,OAAO,CAAC,EAAE;QACrC,OAAO,oBAAoB,CAAC,OAAO,CAAC,CAAC;KACxC,MAAM,IAAI,GAAG,wLAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE;QACtC,OAAO,qBAAqB,CAAC,OAAO,CAAC,CAAC;KACzC,MAAM,IAAI,GAAG,wLAAC,kBAAkB,CAAC,OAAO,CAAC,EAAE;QACxC,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC;QAC9B,IAAI,CAAC,IAAI,EAAE;YACP,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;SAC9C;QACD,OAAO,eAAe,CAAC,sBAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YAC5D,WAAW,EAAE,OAAO,CAAC,WAAW;YAChC,SAAS,EAAE,OAAO,CAAC,SAAS;SAC/B,CAAC,CAAC;KACN,MAAM,IAAI,GAAG,wLAAC,cAAc,CAAC,OAAO,CAAC,EAAE;QACpC,OAAO,kBAAkB,CAAC,OAAO,CAAC,CAAC;KACtC,MAAM,IAAI,GAAG,wLAAC,YAAY,CAAC,OAAO,CAAC,EAAE;QAClC,OAAO,iBAAiB,CAAC,OAAO,CAAC,CAAC;KACrC,MAAM,IAAI,GAAG,wLAAC,YAAY,CAAC,OAAO,CAAC,EAAE;QAClC,MAAM,SAAS,GAAG,OAAO,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;QACjD,MAAM,MAAM,GAAG,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;QACrD,MAAM,UAAU,GAAG,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;QAC1D,IAAI,KAAK,EAAE;YACP,KAAK,CAAC,CAAC,GAAG,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;YACnC,KAAK,CAAC,CAAC,GAAG,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;YACnC,KAAK,CAAC,CAAC,GAAG,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;SACtC;QACD,OAAO,eAAe,CAAC,MAAM,EAAE;YAC3B,WAAW,EAAE,OAAO,CAAC,WAAW;YAChC,SAAS,EAAE,OAAO,CAAC,SAAS;YAC5B,IAAI,EAAE,KAAK;SACd,CAAC,CAAC;KACN,MAAM,IAAI,GAAG,wLAAC,UAAU,CAAC,OAAO,CAAC,EAAE;QAChC,OAAO,eAAe,CAAC,QAAQ,EAAE;YAC7B,WAAW,EAAE,OAAO,CAAC,WAAW;YAChC,SAAS,EAAE,OAAO,CAAC,SAAS;SAC/B,CAAC,CAAC;KACN,MAAM;QACH,MAAM,IAAI,KAAK,CAAC,CAAA,0BAAA,EAA6B,OAAO,KAAA,QAAP,OAAO,KAAA,KAAA,IAAA,KAAA,IAAP,OAAO,CAAE,KAAK,EAAE,CAAC,CAAC;KAClE;AACL,CAAC;AAED,SAAS,2BAA2B,CAAC,YAAsC;IACvE,OAAO,eAAe,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG,EAAC,CAAC,CAAC,EAAE,AAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;QACxF,WAAW,EAAE,YAAY,CAAC,WAAW;QACrC,SAAS,EAAE,YAAY,CAAC,SAAS;KACpC,CAAC,CAAC;AACP,CAAC;AAED,SAAS,oBAAoB,CAAC,KAAwB;IAClD,OAAO,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAC,CAAC,CAAC,EAAG,AAAD,sBAAuB,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE;QAChF,WAAW,EAAE,KAAK,CAAC,WAAW;QAC9B,SAAS,EAAE,KAAK,CAAC,SAAS;KAC7B,CAAC,CAAC;AACP,CAAC;AAED,SAAS,iBAAiB,CAAC,KAAqB;IAC5C,OAAO,eAAe,CAAC,GAAG,QAAQ,CAAA,EAAA,EAAK,sBAAsB,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,EAAE;QAC7E,WAAW,EAAE,KAAK,CAAC,WAAW;QAC9B,SAAS,EAAE,KAAK,CAAC,SAAS;KAC7B,CAAC,CAAC;AACP,CAAC;AAED,SAAS,kBAAkB,CAAC,MAAwB;IAChD,OAAO,eAAe,CAAC,CAAA,GAAA,EAAM,sBAAsB,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA,CAAA,EAAI,QAAQ,CAAA,EAAA,CAAI,EAAE;QAClF,WAAW,EAAE,MAAM,CAAC,WAAW;QAC/B,SAAS,EAAE,MAAM,CAAC,SAAS;KAC9B,CAAC,CAAC;AACP,CAAC;AAED,SAAS,qBAAqB,CAAC,KAAyB;IACpD,IAAI,KAAK,CAAC,KAAK,EAAE;QACb,OAAO,eAAe,CAAC,CAAA,CAAA,EAAI,cAAc,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA,CAAA,EAAI,cAAc,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA,CAAA,CAAG,EAAE;YACrF,WAAW,EAAE,KAAK,CAAC,WAAW;YAC9B,SAAS,EAAE,KAAK,CAAC,SAAS;YAC1B,IAAI,EAAE,KAAK;SACd,CAAC,CAAC;KACN;IACD,OAAO,eAAe,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;QAC/C,WAAW,EAAE,KAAK,CAAC,WAAW;QAC9B,SAAS,EAAE,KAAK,CAAC,SAAS;QAC1B,IAAI,EAAE,KAAK;KACd,CAAC,CAAC;AACP,CAAC;AAED,SAAS,cAAc,CAAC,OAAoB;IACxC,iMAAO,eAAA,AAAY,EAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AACvC,CAAC;AAED,SAAS,eAAe,CAAC,KAAa,EAAE,OAIvC;;IACG,IAAI,OAAO,CAAC,IAAI,KAAK,KAAK,IAAI,OAAO,CAAC,SAAS,EAAE;QAC7C,KAAK,GAAG,CAAA,CAAA,EAAI,CAAA,KAAA,OAAO,CAAC,SAAS,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE,GAAG,KAAK,CAAA,CAAA,CAAG,CAAC;KAClD;IACD,IAAI,OAAO,CAAC,WAAW,EAAE;QACrB,OAAO,GAAG,KAAK,GAAG,OAAO,CAAC,WAAW,EAAE,CAAC;KAC3C;IACD,OAAO,KAAK,CAAC;AACjB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 3133, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3139, "column": 0}, "map": {"version":3,"file":"grammar-config.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/languages/grammar-config.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { LangiumCoreServices } from '../services.js';\nimport { DefaultNameRegexp } from '../utils/cst-utils.js';\nimport { isCommentTerminal, terminalRegex } from '../utils/grammar-utils.js';\nimport { isMultilineComment } from '../utils/regexp-utils.js';\nimport { isTerminalRule } from './generated/ast.js';\n\nexport interface GrammarConfig {\n    /**\n     * Lists all rule names which are classified as multiline comment rules\n     */\n    multilineCommentRules: string[]\n    /**\n     * A regular expression which matches characters of names\n     */\n    nameRegexp: RegExp\n}\n\n/**\n * Create the default grammar configuration (used by `createDefaultModule`). This can be overridden in a\n * language-specific module.\n */\nexport function createGrammarConfig(services: LangiumCoreServices): GrammarConfig {\n    const rules: string[] = [];\n    const grammar = services.Grammar;\n    for (const rule of grammar.rules) {\n        if (isTerminalRule(rule) && isCommentTerminal(rule) && isMultilineComment(terminalRegex(rule))) {\n            rules.push(rule.name);\n        }\n    }\n    return {\n        multilineCommentRules: rules,\n        nameRegexp: DefaultNameRegexp\n    };\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;AAGhF,OAAO,EAAE,iBAAiB,EAAE,MAAM,uBAAuB,CAAC;AAC1D,OAAO,EAAE,iBAAiB,EAAE,aAAa,EAAE,MAAM,2BAA2B,CAAC;AAC7E,OAAO,EAAE,kBAAkB,EAAE,MAAM,0BAA0B,CAAC;AAC9D,OAAO,EAAE,cAAc,EAAE,MAAM,oBAAoB,CAAC;;;;;AAiB9C,SAAU,mBAAmB,CAAC,QAA6B;IAC7D,MAAM,KAAK,GAAa,EAAE,CAAC;IAC3B,MAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;IACjC,KAAK,MAAM,IAAI,IAAI,OAAO,CAAC,KAAK,CAAE;QAC9B,mMAAI,iBAAA,AAAc,EAAC,IAAI,CAAC,+LAAI,oBAAA,AAAiB,EAAC,IAAI,CAAC,KAAI,8MAAA,AAAkB,6LAAC,gBAAA,AAAa,EAAC,IAAI,CAAC,CAAC,EAAE;YAC5F,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACzB;KACJ;IACD,OAAO;QACH,qBAAqB,EAAE,KAAK;QAC5B,UAAU,qLAAE,oBAAiB;KAChC,CAAC;AACN,CAAC","ignoreList":[0]}},
    {"offset": {"line": 3167, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3173, "column": 0}, "map": {"version":3,"file":"cst-node-builder.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/parser/cst-node-builder.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { IToken, TokenType } from 'chevrotain';\nimport type { Range } from 'vscode-languageserver-types';\nimport type { AbstractElement } from '../languages/generated/ast.js';\nimport type { AstNode, CompositeCstNode, CstNode, LeafCstNode, RootCstNode } from '../syntax-tree.js';\nimport { Position } from 'vscode-languageserver-types';\nimport { isCompositeCstNode } from '../syntax-tree.js';\nimport { tokenToRange } from '../utils/cst-utils.js';\n\nexport class CstNodeBuilder {\n\n    private rootNode!: RootCstNodeImpl;\n    private nodeStack: CompositeCstNodeImpl[] = [];\n\n    private get current(): CompositeCstNodeImpl {\n        return this.nodeStack[this.nodeStack.length - 1];\n    }\n\n    buildRootNode(input: string): RootCstNode {\n        this.rootNode = new RootCstNodeImpl(input);\n        this.rootNode.root = this.rootNode;\n        this.nodeStack = [this.rootNode];\n        return this.rootNode;\n    }\n\n    buildCompositeNode(feature: AbstractElement): CompositeCstNode {\n        const compositeNode = new CompositeCstNodeImpl();\n        compositeNode.grammarSource = feature;\n        compositeNode.root = this.rootNode;\n        this.current.content.push(compositeNode);\n        this.nodeStack.push(compositeNode);\n        return compositeNode;\n    }\n\n    buildLeafNode(token: IToken, feature: AbstractElement): LeafCstNode {\n        const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, false);\n        leafNode.grammarSource = feature;\n        leafNode.root = this.rootNode;\n        this.current.content.push(leafNode);\n        return leafNode;\n    }\n\n    removeNode(node: CstNode): void {\n        const parent = node.container;\n        if (parent) {\n            const index = parent.content.indexOf(node);\n            if (index >= 0) {\n                parent.content.splice(index, 1);\n            }\n        }\n    }\n\n    construct(item: { $type: string | symbol | undefined, $cstNode: CstNode }): void {\n        const current: CstNode = this.current;\n        // The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)\n        // Only if the $type is a string, we actually assign the element\n        if (typeof item.$type === 'string') {\n            this.current.astNode = <AstNode>item;\n        }\n        item.$cstNode = current;\n        const node = this.nodeStack.pop();\n        // Empty composite nodes are not valid\n        // Simply remove the node from the tree\n        if (node?.content.length === 0) {\n            this.removeNode(node);\n        }\n    }\n\n    addHiddenTokens(hiddenTokens: IToken[]): void {\n        for (const token of hiddenTokens) {\n            const hiddenNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);\n            hiddenNode.root = this.rootNode;\n            this.addHiddenToken(this.rootNode, hiddenNode);\n        }\n    }\n\n    private addHiddenToken(node: CompositeCstNode, token: LeafCstNode): void {\n        const { offset: tokenStart, end: tokenEnd } = token;\n\n        for (let i = 0; i < node.content.length; i++) {\n            const child = node.content[i];\n            const { offset: childStart, end: childEnd } = child;\n            if (isCompositeCstNode(child) && tokenStart > childStart && tokenEnd < childEnd) {\n                this.addHiddenToken(child, token);\n                return;\n            } else if (tokenEnd <= childStart) {\n                node.content.splice(i, 0, token);\n                return;\n            }\n        }\n\n        // We know that we haven't found a suited position for the token\n        // So we simply add it to the end of the current node\n        node.content.push(token);\n    }\n}\n\nexport abstract class AbstractCstNode implements CstNode {\n    abstract get offset(): number;\n    abstract get length(): number;\n    abstract get end(): number;\n    abstract get range(): Range;\n\n    container?: CompositeCstNode;\n    grammarSource: AbstractElement;\n    root: RootCstNode;\n    private _astNode?: AstNode;\n\n    /** @deprecated use `container` instead. */\n    get parent(): CompositeCstNode | undefined {\n        return this.container;\n    }\n\n    /** @deprecated use `grammarSource` instead. */\n    get feature(): AbstractElement {\n        return this.grammarSource;\n    }\n\n    get hidden(): boolean {\n        return false;\n    }\n\n    get astNode(): AstNode {\n        const node = typeof this._astNode?.$type === 'string' ? this._astNode : this.container?.astNode;\n        if (!node) {\n            throw new Error('This node has no associated AST element');\n        }\n        return node;\n    }\n\n    set astNode(value: AstNode) {\n        this._astNode = value;\n    }\n\n    /** @deprecated use `astNode` instead. */\n    get element(): AstNode {\n        return this.astNode;\n    }\n\n    get text(): string {\n        return this.root.fullText.substring(this.offset, this.end);\n    }\n}\n\nexport class LeafCstNodeImpl extends AbstractCstNode implements LeafCstNode {\n    get offset(): number {\n        return this._offset;\n    }\n\n    get length(): number {\n        return this._length;\n    }\n\n    get end(): number {\n        return this._offset + this._length;\n    }\n\n    override get hidden(): boolean {\n        return this._hidden;\n    }\n\n    get tokenType(): TokenType {\n        return this._tokenType;\n    }\n\n    get range(): Range {\n        return this._range;\n    }\n\n    private _hidden: boolean;\n    private _offset: number;\n    private _length: number;\n    private _range: Range;\n    private _tokenType: TokenType;\n\n    constructor(offset: number, length: number, range: Range, tokenType: TokenType, hidden = false) {\n        super();\n        this._hidden = hidden;\n        this._offset = offset;\n        this._tokenType = tokenType;\n        this._length = length;\n        this._range = range;\n    }\n}\n\nexport class CompositeCstNodeImpl extends AbstractCstNode implements CompositeCstNode {\n    readonly content: CstNode[] = new CstNodeContainer(this);\n    private _rangeCache?: Range;\n\n    /** @deprecated use `content` instead. */\n    get children(): CstNode[] {\n        return this.content;\n    }\n\n    get offset(): number {\n        return this.firstNonHiddenNode?.offset ?? 0;\n    }\n\n    get length(): number {\n        return this.end - this.offset;\n    }\n\n    get end(): number {\n        return this.lastNonHiddenNode?.end ?? 0;\n    }\n\n    get range(): Range {\n        const firstNode = this.firstNonHiddenNode;\n        const lastNode = this.lastNonHiddenNode;\n        if (firstNode && lastNode) {\n            if (this._rangeCache === undefined) {\n                const { range: firstRange } = firstNode;\n                const { range: lastRange } = lastNode;\n                this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };\n            }\n            return this._rangeCache;\n        } else {\n            return { start: Position.create(0, 0), end: Position.create(0, 0) };\n        }\n    }\n\n    private get firstNonHiddenNode(): CstNode | undefined {\n        for (const child of this.content) {\n            if (!child.hidden) {\n                return child;\n            }\n        }\n        return this.content[0];\n    }\n\n    private get lastNonHiddenNode(): CstNode | undefined {\n        for (let i = this.content.length - 1; i >= 0; i--) {\n            const child = this.content[i];\n            if (!child.hidden) {\n                return child;\n            }\n        }\n        return this.content[this.content.length - 1];\n    }\n}\n\nclass CstNodeContainer extends Array<CstNode> {\n    readonly parent: CompositeCstNode;\n\n    constructor(parent: CompositeCstNode) {\n        super();\n        this.parent = parent;\n        Object.setPrototypeOf(this, CstNodeContainer.prototype);\n    }\n\n    override push(...items: CstNode[]): number {\n        this.addParents(items);\n        return super.push(...items);\n    }\n\n    override unshift(...items: CstNode[]): number {\n        this.addParents(items);\n        return super.unshift(...items);\n    }\n\n    override splice(start: number, count: number, ...items: CstNode[]): CstNode[] {\n        this.addParents(items);\n        return super.splice(start, count, ...items);\n    }\n\n    private addParents(items: CstNode[]): void {\n        for (const item of items) {\n            (<AbstractCstNode>item).container = this.parent;\n        }\n    }\n}\n\nexport class RootCstNodeImpl extends CompositeCstNodeImpl implements RootCstNode {\n    private _text = '';\n\n    override get text(): string {\n        return this._text.substring(this.offset, this.end);\n    }\n\n    get fullText(): string {\n        return this._text;\n    }\n\n    constructor(input?: string) {\n        super();\n        this._text = input ?? '';\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3419, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3425, "column": 0}, "map": {"version":3,"file":"langium-parser.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/parser/langium-parser.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { DSLMethodOpts, ILexingError, IOrAlt, IParserErrorMessageProvider, IRecognitionException, IToken, TokenType, TokenVocabulary } from 'chevrotain';\nimport type { AbstractElement, Action, Assignment, ParserRule } from '../languages/generated/ast.js';\nimport type { Linker } from '../references/linker.js';\nimport type { LangiumCoreServices } from '../services.js';\nimport type { AstNode, AstReflection, CompositeCstNode, CstNode } from '../syntax-tree.js';\nimport type { Lexer } from './lexer.js';\nimport type { IParserConfig } from './parser-config.js';\nimport type { ValueConverter } from './value-converter.js';\nimport { defaultParserErrorProvider, EmbeddedActionsParser, LLkLookaheadStrategy } from 'chevrotain';\nimport { LLStarLookaheadStrategy } from 'chevrotain-allstar';\nimport { isAssignment, isCrossReference, isKeyword } from '../languages/generated/ast.js';\nimport { getTypeName, isDataTypeRule } from '../utils/grammar-utils.js';\nimport { assignMandatoryProperties, getContainerOfType, linkContentToContainer } from '../utils/ast-utils.js';\nimport { CstNodeBuilder } from './cst-node-builder.js';\n\nexport type ParseResult<T = AstNode> = {\n    value: T,\n    parserErrors: IRecognitionException[],\n    lexerErrors: ILexingError[]\n}\n\nexport const DatatypeSymbol = Symbol('Datatype');\n\ninterface DataTypeNode {\n    $cstNode: CompositeCstNode\n    /** Instead of a string, this node is uniquely identified by the `Datatype` symbol */\n    $type: symbol\n    /** Used as a storage for all parsed terminals, keywords and sub-datatype rules */\n    value: string\n}\n\nfunction isDataTypeNode(node: { $type: string | symbol | undefined }): node is DataTypeNode {\n    return node.$type === DatatypeSymbol;\n}\n\ntype RuleResult = (args: Args) => any;\n\ntype Args = Record<string, boolean>;\n\ntype RuleImpl = (args: Args) => any;\n\ninterface AssignmentElement {\n    assignment?: Assignment\n    isCrossRef: boolean\n}\n\nexport interface BaseParser {\n    rule(rule: ParserRule, impl: RuleImpl): RuleResult;\n    alternatives(idx: number, choices: Array<IOrAlt<any>>): void;\n    optional(idx: number, callback: DSLMethodOpts<unknown>): void;\n    many(idx: number, callback: DSLMethodOpts<unknown>): void;\n    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;\n    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;\n    subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void;\n    action($type: string, action: Action): void;\n    construct(): unknown;\n    isRecording(): boolean;\n    get unorderedGroups(): Map<string, boolean[]>;\n    getRuleStack(): number[];\n}\n\nconst ruleSuffix = '\\u200B';\nconst withRuleSuffix = (name: string): string => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;\n\nexport abstract class AbstractLangiumParser implements BaseParser {\n\n    protected readonly lexer: Lexer;\n    protected readonly wrapper: ChevrotainWrapper;\n    protected _unorderedGroups: Map<string, boolean[]> = new Map<string, boolean[]>();\n\n    constructor(services: LangiumCoreServices) {\n        this.lexer = services.parser.Lexer;\n        const tokens = this.lexer.definition;\n        this.wrapper = new ChevrotainWrapper(tokens, {\n            ...services.parser.ParserConfig,\n            errorMessageProvider: services.parser.ParserErrorMessageProvider\n        });\n    }\n\n    alternatives(idx: number, choices: Array<IOrAlt<any>>): void {\n        this.wrapper.wrapOr(idx, choices);\n    }\n\n    optional(idx: number, callback: DSLMethodOpts<unknown>): void {\n        this.wrapper.wrapOption(idx, callback);\n    }\n\n    many(idx: number, callback: DSLMethodOpts<unknown>): void {\n        this.wrapper.wrapMany(idx, callback);\n    }\n\n    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void {\n        this.wrapper.wrapAtLeastOne(idx, callback);\n    }\n\n    abstract rule(rule: ParserRule, impl: RuleImpl): RuleResult;\n    abstract consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;\n    abstract subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void;\n    abstract action($type: string, action: Action): void;\n    abstract construct(): unknown;\n\n    isRecording(): boolean {\n        return this.wrapper.IS_RECORDING;\n    }\n\n    get unorderedGroups(): Map<string, boolean[]> {\n        return this._unorderedGroups;\n    }\n\n    getRuleStack(): number[] {\n        return (this.wrapper as any).RULE_STACK;\n    }\n\n    finalize(): void {\n        this.wrapper.wrapSelfAnalysis();\n    }\n}\n\nexport class LangiumParser extends AbstractLangiumParser {\n    private readonly linker: Linker;\n    private readonly converter: ValueConverter;\n    private readonly astReflection: AstReflection;\n    private readonly nodeBuilder = new CstNodeBuilder();\n    private stack: any[] = [];\n    private mainRule!: RuleResult;\n    private assignmentMap = new Map<AbstractElement, AssignmentElement | undefined>();\n\n    private get current(): any {\n        return this.stack[this.stack.length - 1];\n    }\n\n    constructor(services: LangiumCoreServices) {\n        super(services);\n        this.linker = services.references.Linker;\n        this.converter = services.parser.ValueConverter;\n        this.astReflection = services.shared.AstReflection;\n    }\n\n    rule(rule: ParserRule, impl: RuleImpl): RuleResult {\n        const type = rule.fragment ? undefined : isDataTypeRule(rule) ? DatatypeSymbol : getTypeName(rule);\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));\n        if (rule.entry) {\n            this.mainRule = ruleMethod;\n        }\n        return ruleMethod;\n    }\n\n    parse<T extends AstNode = AstNode>(input: string): ParseResult<T> {\n        this.nodeBuilder.buildRootNode(input);\n        const lexerResult = this.lexer.tokenize(input);\n        this.wrapper.input = lexerResult.tokens;\n        const result = this.mainRule.call(this.wrapper, {});\n        this.nodeBuilder.addHiddenTokens(lexerResult.hidden);\n        this.unorderedGroups.clear();\n        return {\n            value: result,\n            lexerErrors: lexerResult.errors,\n            parserErrors: this.wrapper.errors\n        };\n    }\n\n    private startImplementation($type: string | symbol | undefined, implementation: RuleImpl): RuleImpl {\n        return (args) => {\n            if (!this.isRecording()) {\n                const node: any = { $type };\n                this.stack.push(node);\n                if ($type === DatatypeSymbol) {\n                    node.value = '';\n                }\n            }\n            let result: unknown;\n            try {\n                result = implementation(args);\n            } catch (err) {\n                result = undefined;\n            }\n            if (!this.isRecording() && result === undefined) {\n                result = this.construct();\n            }\n            return result;\n        };\n    }\n\n    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void {\n        const token = this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording() && this.isValidToken(token)) {\n            const leafNode = this.nodeBuilder.buildLeafNode(token, feature);\n            const { assignment, isCrossRef } = this.getAssignment(feature);\n            const current = this.current;\n            if (assignment) {\n                const convertedValue = isKeyword(feature) ? token.image : this.converter.convert(token.image, leafNode);\n                this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);\n            } else if (isDataTypeNode(current)) {\n                let text = token.image;\n                if (!isKeyword(feature)) {\n                    text = this.converter.convert(text, leafNode).toString();\n                }\n                current.value += text;\n            }\n        }\n    }\n\n    /**\n     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:\n     *\n     * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed\n     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.\n     */\n    private isValidToken(token: IToken): boolean {\n        return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === 'number' && !isNaN(token.endOffset);\n    }\n\n    subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void {\n        let cstNode: CompositeCstNode | undefined;\n        if (!this.isRecording()) {\n            cstNode = this.nodeBuilder.buildCompositeNode(feature);\n        }\n        const subruleResult = this.wrapper.wrapSubrule(idx, rule, args) as any;\n        if (!this.isRecording() && cstNode && cstNode.length > 0) {\n            this.performSubruleAssignment(subruleResult, feature, cstNode);\n        }\n    }\n\n    private performSubruleAssignment(result: any, feature: AbstractElement, cstNode: CompositeCstNode): void {\n        const { assignment, isCrossRef } = this.getAssignment(feature);\n        if (assignment) {\n            this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);\n        } else if (!assignment) {\n            // If we call a subrule without an assignment we either:\n            // 1. append the result of the subrule (data type rule)\n            // 2. override the current object with the newly parsed object\n            // If the current element is an AST node and the result of the subrule\n            // is a data type rule, we can safely discard the results.\n            const current = this.current;\n            if (isDataTypeNode(current)) {\n                current.value += result.toString();\n            } else if (typeof result === 'object' && result) {\n                const resultKind = result.$type;\n                const object = this.assignWithoutOverride(result, current);\n                if (resultKind) {\n                    object.$type = resultKind;\n                }\n                const newItem = object;\n                this.stack.pop();\n                this.stack.push(newItem);\n            }\n        }\n    }\n\n    action($type: string, action: Action): void {\n        if (!this.isRecording()) {\n            let last = this.current;\n            // This branch is used for left recursive grammar rules.\n            // Those don't call `construct` before another action.\n            // Therefore, we need to call it here.\n            if (!last.$cstNode && action.feature && action.operator) {\n                last = this.construct(false);\n                const feature = last.$cstNode.feature;\n                this.nodeBuilder.buildCompositeNode(feature);\n            }\n            const newItem = { $type };\n            this.stack.pop();\n            this.stack.push(newItem);\n            if (action.feature && action.operator) {\n                this.assign(action.operator, action.feature, last, last.$cstNode, false);\n            }\n        }\n    }\n\n    construct(pop = true): unknown {\n        if (this.isRecording()) {\n            return undefined;\n        }\n        const obj = this.current;\n        linkContentToContainer(obj);\n        this.nodeBuilder.construct(obj);\n        if (pop) {\n            this.stack.pop();\n        }\n        if (isDataTypeNode(obj)) {\n            return this.converter.convert(obj.value, obj.$cstNode);\n        } else {\n            assignMandatoryProperties(this.astReflection, obj);\n        }\n        return obj;\n    }\n\n    private getAssignment(feature: AbstractElement): AssignmentElement {\n        if (!this.assignmentMap.has(feature)) {\n            const assignment = getContainerOfType(feature, isAssignment);\n            this.assignmentMap.set(feature, {\n                assignment: assignment,\n                isCrossRef: assignment ? isCrossReference(assignment.terminal) : false\n            });\n        }\n        return this.assignmentMap.get(feature)!;\n    }\n\n    private assign(operator: string, feature: string, value: unknown, cstNode: CstNode, isCrossRef: boolean): void {\n        const obj = this.current;\n        let item: unknown;\n        if (isCrossRef && typeof value === 'string') {\n            item = this.linker.buildReference(obj, feature, cstNode, value);\n        } else {\n            item = value;\n        }\n        switch (operator) {\n            case '=': {\n                obj[feature] = item;\n                break;\n            }\n            case '?=': {\n                obj[feature] = true;\n                break;\n            }\n            case '+=': {\n                if (!Array.isArray(obj[feature])) {\n                    obj[feature] = [];\n                }\n                obj[feature].push(item);\n            }\n        }\n    }\n\n    private assignWithoutOverride(target: any, source: any): any {\n        for (const [name, existingValue] of Object.entries(source)) {\n            const newValue = target[name];\n            if (newValue === undefined) {\n                target[name] = existingValue;\n            } else if (Array.isArray(newValue) && Array.isArray(existingValue)) {\n                existingValue.push(...newValue);\n                target[name] = existingValue;\n            }\n        }\n        return target;\n    }\n\n    get definitionErrors(): IParserDefinitionError[] {\n        return this.wrapper.definitionErrors;\n    }\n}\n\nexport interface IParserDefinitionError {\n    message: string\n    type: number\n    ruleName?: string\n}\n\nexport abstract class AbstractParserErrorMessageProvider implements IParserErrorMessageProvider {\n\n    buildMismatchTokenMessage(options: {\n        expected: TokenType\n        actual: IToken\n        previous: IToken\n        ruleName: string\n    }): string {\n        return defaultParserErrorProvider.buildMismatchTokenMessage(options);\n    }\n\n    buildNotAllInputParsedMessage(options: {\n        firstRedundant: IToken\n        ruleName: string\n    }): string {\n        return defaultParserErrorProvider.buildNotAllInputParsedMessage(options);\n    }\n\n    buildNoViableAltMessage(options: {\n        expectedPathsPerAlt: TokenType[][][]\n        actual: IToken[]\n        previous: IToken\n        customUserDescription: string\n        ruleName: string\n    }): string {\n        return defaultParserErrorProvider.buildNoViableAltMessage(options);\n    }\n\n    buildEarlyExitMessage(options: {\n        expectedIterationPaths: TokenType[][]\n        actual: IToken[]\n        previous: IToken\n        customUserDescription: string\n        ruleName: string\n    }): string {\n        return defaultParserErrorProvider.buildEarlyExitMessage(options);\n    }\n\n}\n\nexport class LangiumParserErrorMessageProvider extends AbstractParserErrorMessageProvider {\n\n    override buildMismatchTokenMessage({ expected, actual }: {\n        expected: TokenType\n        actual: IToken\n        previous: IToken\n        ruleName: string\n    }): string {\n        const expectedMsg = expected.LABEL\n            ? '`' + expected.LABEL + '`'\n            : expected.name.endsWith(':KW')\n                ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'`\n                : `token of type '${expected.name}'`;\n        return `Expecting ${expectedMsg} but found \\`${actual.image}\\`.`;\n    }\n\n    override buildNotAllInputParsedMessage({ firstRedundant }: {\n        firstRedundant: IToken\n        ruleName: string\n    }): string {\n        return `Expecting end of file but found \\`${firstRedundant.image}\\`.`;\n    }\n}\n\nexport interface CompletionParserResult {\n    tokens: IToken[]\n    elementStack: AbstractElement[]\n    tokenIndex: number\n}\n\nexport class LangiumCompletionParser extends AbstractLangiumParser {\n    private mainRule!: RuleResult;\n    private tokens: IToken[] = [];\n\n    private elementStack: AbstractElement[] = [];\n    private lastElementStack: AbstractElement[] = [];\n    private nextTokenIndex = 0;\n    private stackSize = 0;\n\n    action(): void {\n        // NOOP\n    }\n\n    construct(): unknown {\n        // NOOP\n        return undefined;\n    }\n\n    parse(input: string): CompletionParserResult {\n        this.resetState();\n        const tokens = this.lexer.tokenize(input);\n        this.tokens = tokens.tokens;\n        this.wrapper.input = [...this.tokens];\n        this.mainRule.call(this.wrapper, {});\n        this.unorderedGroups.clear();\n        return {\n            tokens: this.tokens,\n            elementStack: [...this.lastElementStack],\n            tokenIndex: this.nextTokenIndex\n        };\n    }\n\n    rule(rule: ParserRule, impl: RuleImpl): RuleResult {\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));\n        if (rule.entry) {\n            this.mainRule = ruleMethod;\n        }\n        return ruleMethod;\n    }\n\n    private resetState(): void {\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n\n    private startImplementation(implementation: RuleImpl): RuleImpl {\n        return (args) => {\n            const size = this.keepStackSize();\n            try {\n                implementation(args);\n            } finally {\n                this.resetStackSize(size);\n            }\n        };\n    }\n\n    private removeUnexpectedElements(): void {\n        this.elementStack.splice(this.stackSize);\n    }\n\n    keepStackSize(): number {\n        const size = this.elementStack.length;\n        this.stackSize = size;\n        return size;\n    }\n\n    resetStackSize(size: number): void {\n        this.removeUnexpectedElements();\n        this.stackSize = size;\n    }\n\n    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void {\n        this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording()) {\n            this.lastElementStack = [...this.elementStack, feature];\n            this.nextTokenIndex = this.currIdx + 1;\n        }\n    }\n\n    subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void {\n        this.before(feature);\n        this.wrapper.wrapSubrule(idx, rule, args);\n        this.after(feature);\n    }\n\n    before(element: AbstractElement): void {\n        if (!this.isRecording()) {\n            this.elementStack.push(element);\n        }\n    }\n\n    after(element: AbstractElement): void {\n        if (!this.isRecording()) {\n            const index = this.elementStack.lastIndexOf(element);\n            if (index >= 0) {\n                this.elementStack.splice(index);\n            }\n        }\n    }\n\n    get currIdx(): number {\n        return (this.wrapper as any).currIdx;\n    }\n}\n\nconst defaultConfig: IParserConfig = {\n    recoveryEnabled: true,\n    nodeLocationTracking: 'full',\n    skipValidations: true,\n    errorMessageProvider: new LangiumParserErrorMessageProvider()\n};\n\n/**\n * This class wraps the embedded actions parser of chevrotain and exposes protected methods.\n * This way, we can build the `LangiumParser` as a composition.\n */\nclass ChevrotainWrapper extends EmbeddedActionsParser {\n\n    // This array is set in the base implementation of Chevrotain.\n    definitionErrors: IParserDefinitionError[];\n\n    constructor(tokens: TokenVocabulary, config?: IParserConfig) {\n        const useDefaultLookahead = config && 'maxLookahead' in config;\n        super(tokens, {\n            ...defaultConfig,\n            lookaheadStrategy: useDefaultLookahead\n                ? new LLkLookaheadStrategy({ maxLookahead: config.maxLookahead })\n                : new LLStarLookaheadStrategy(),\n            ...config,\n        });\n    }\n\n    get IS_RECORDING(): boolean {\n        return this.RECORDING_PHASE;\n    }\n\n    DEFINE_RULE(name: string, impl: RuleImpl): RuleResult {\n        return this.RULE(name, impl);\n    }\n\n    wrapSelfAnalysis(): void {\n        this.performSelfAnalysis();\n    }\n\n    wrapConsume(idx: number, tokenType: TokenType): IToken {\n        return this.consume(idx, tokenType);\n    }\n\n    wrapSubrule(idx: number, rule: RuleResult, args: Args): unknown {\n        return this.subrule(idx, rule, {\n            ARGS: [args]\n        });\n    }\n\n    wrapOr(idx: number, choices: Array<IOrAlt<any>>): void {\n        this.or(idx, choices);\n    }\n\n    wrapOption(idx: number, callback: DSLMethodOpts<unknown>): void {\n        this.option(idx, callback);\n    }\n\n    wrapMany(idx: number, callback: DSLMethodOpts<unknown>): void {\n        this.many(idx, callback);\n    }\n\n    wrapAtLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void {\n        this.atLeastOne(idx, callback);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3876, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3882, "column": 0}, "map": {"version":3,"file":"parser-builder-base.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/parser/parser-builder-base.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { IOrAlt, TokenType, TokenTypeDictionary } from 'chevrotain';\nimport type { AbstractElement, Action, Alternatives, Condition, CrossReference, Grammar, Group, Keyword, NamedArgument, ParserRule, RuleCall, UnorderedGroup } from '../languages/generated/ast.js';\nimport type { BaseParser } from './langium-parser.js';\nimport type { AstNode } from '../syntax-tree.js';\nimport type { Cardinality } from '../utils/grammar-utils.js';\nimport { EMPTY_ALT, EOF } from 'chevrotain';\nimport { isAction, isAlternatives, isEndOfFile, isAssignment, isConjunction, isCrossReference, isDisjunction, isGroup, isKeyword, isNegation, isParameterReference, isParserRule, isRuleCall, isTerminalRule, isUnorderedGroup, isBooleanLiteral } from '../languages/generated/ast.js';\nimport { assertUnreachable, ErrorWithLocation } from '../utils/errors.js';\nimport { stream } from '../utils/stream.js';\nimport { findNameAssignment, getAllReachableRules, getTypeName } from '../utils/grammar-utils.js';\n\ntype RuleContext = {\n    optional: number,\n    consume: number,\n    subrule: number,\n    many: number,\n    or: number\n} & ParserContext;\n\ntype ParserContext = {\n    parser: BaseParser\n    tokens: TokenTypeDictionary\n    rules: Map<string, Rule>\n    ruleNames: Map<AstNode, string>\n}\n\ntype Rule = (args: Args) => unknown;\n\ntype Args = Record<string, boolean>;\n\ntype Predicate = (args: Args) => boolean;\n\ntype Method = (args: Args) => void;\n\nexport function createParser<T extends BaseParser>(grammar: Grammar, parser: T, tokens: TokenTypeDictionary): T {\n    const rules = new Map<string, Rule>();\n    const parserContext: ParserContext = {\n        parser,\n        tokens,\n        rules,\n        ruleNames: new Map()\n    };\n    buildRules(parserContext, grammar);\n    return parser;\n}\n\nfunction buildRules(parserContext: ParserContext, grammar: Grammar): void {\n    const reachable = getAllReachableRules(grammar, false);\n    const parserRules = stream(grammar.rules).filter(isParserRule).filter(rule => reachable.has(rule));\n    for (const rule of parserRules) {\n        const ctx: RuleContext = {\n            ...parserContext,\n            consume: 1,\n            optional: 1,\n            subrule: 1,\n            many: 1,\n            or: 1\n        };\n        ctx.rules.set(\n            rule.name,\n            parserContext.parser.rule(rule, buildElement(ctx, rule.definition))\n        );\n    }\n}\n\nfunction buildElement(ctx: RuleContext, element: AbstractElement, ignoreGuard = false): Method {\n    let method: Method;\n    if (isKeyword(element)) {\n        method = buildKeyword(ctx, element);\n    } else if (isAction(element)) {\n        method = buildAction(ctx, element);\n    } else if (isAssignment(element)) {\n        method = buildElement(ctx, element.terminal);\n    } else if (isCrossReference(element)) {\n        method = buildCrossReference(ctx, element);\n    } else if (isRuleCall(element)) {\n        method = buildRuleCall(ctx, element);\n    } else if (isAlternatives(element)) {\n        method = buildAlternatives(ctx, element);\n    } else if (isUnorderedGroup(element)) {\n        method = buildUnorderedGroup(ctx, element);\n    } else if (isGroup(element)) {\n        method = buildGroup(ctx, element);\n    } else if(isEndOfFile(element)) {\n        const idx = ctx.consume++;\n        method = () => ctx.parser.consume(idx, EOF, element);\n    } else {\n        throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\n    }\n    return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);\n}\n\nfunction buildAction(ctx: RuleContext, action: Action): Method {\n    const actionType = getTypeName(action);\n    return () => ctx.parser.action(actionType, action);\n}\n\nfunction buildRuleCall(ctx: RuleContext, ruleCall: RuleCall): Method {\n    const rule = ruleCall.rule.ref;\n    if (isParserRule(rule)) {\n        const idx = ctx.subrule++;\n        const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), ruleCall, predicate(args));\n    } else if (isTerminalRule(rule)) {\n        const idx = ctx.consume++;\n        const method = getToken(ctx, rule.name);\n        return () => ctx.parser.consume(idx, method, ruleCall);\n    } else if (!rule) {\n        throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule type: ${ruleCall.$type}`);\n    } else {\n        assertUnreachable(rule);\n    }\n}\n\nfunction buildRuleCallPredicate(rule: ParserRule, namedArgs: NamedArgument[]): (args: Args) => Args {\n    const predicates = namedArgs.map(e => buildPredicate(e.value));\n    return (args) => {\n        const ruleArgs: Args = {};\n        for (let i = 0; i < predicates.length; i++) {\n            const ruleTarget = rule.parameters[i];\n            const predicate = predicates[i];\n            ruleArgs[ruleTarget.name] = predicate(args);\n        }\n        return ruleArgs;\n    };\n}\n\ninterface PredicatedMethod {\n    ALT: Method,\n    GATE?: Predicate\n}\n\nfunction buildPredicate(condition: Condition): Predicate {\n    if (isDisjunction(condition)) {\n        const left = buildPredicate(condition.left);\n        const right = buildPredicate(condition.right);\n        return (args) => (left(args) || right(args));\n    } else if (isConjunction(condition)) {\n        const left = buildPredicate(condition.left);\n        const right = buildPredicate(condition.right);\n        return (args) => (left(args) && right(args));\n    } else if (isNegation(condition)) {\n        const value = buildPredicate(condition.value);\n        return (args) => !value(args);\n    } else if (isParameterReference(condition)) {\n        const name = condition.parameter.ref!.name;\n        return (args) => args !== undefined && args[name] === true;\n    } else if (isBooleanLiteral(condition)) {\n        const value = Boolean(condition.true);\n        return () => value;\n    }\n    assertUnreachable(condition);\n}\n\nfunction buildAlternatives(ctx: RuleContext, alternatives: Alternatives): Method {\n    if (alternatives.elements.length === 1) {\n        return buildElement(ctx, alternatives.elements[0]);\n    } else {\n        const methods: PredicatedMethod[] = [];\n\n        for (const element of alternatives.elements) {\n            const predicatedMethod: PredicatedMethod = {\n                // Since we handle the guard condition in the alternative already\n                // We can ignore the group guard condition inside\n                ALT: buildElement(ctx, element, true)\n            };\n            const guard = getGuardCondition(element);\n            if (guard) {\n                predicatedMethod.GATE = buildPredicate(guard);\n            }\n            methods.push(predicatedMethod);\n        }\n\n        const idx = ctx.or++;\n        return (args) => ctx.parser.alternatives(idx, methods.map(method => {\n            const alt: IOrAlt<unknown> = {\n                ALT: () => method.ALT(args)\n            };\n            const gate = method.GATE;\n            if (gate) {\n                alt.GATE = () => gate(args);\n            }\n            return alt;\n        }));\n    }\n}\n\nfunction buildUnorderedGroup(ctx: RuleContext, group: UnorderedGroup): Method {\n    if (group.elements.length === 1) {\n        return buildElement(ctx, group.elements[0]);\n    }\n    const methods: PredicatedMethod[] = [];\n\n    for (const element of group.elements) {\n        const predicatedMethod: PredicatedMethod = {\n            // Since we handle the guard condition in the alternative already\n            // We can ignore the group guard condition inside\n            ALT: buildElement(ctx, element, true)\n        };\n        const guard = getGuardCondition(element);\n        if (guard) {\n            predicatedMethod.GATE = buildPredicate(guard);\n        }\n        methods.push(predicatedMethod);\n    }\n\n    const orIdx = ctx.or++;\n\n    const idFunc = (groupIdx: number, lParser: BaseParser) => {\n        const stackId = lParser.getRuleStack().join('-');\n        return `uGroup_${groupIdx}_${stackId}`;\n    };\n    const alternatives: Method = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\n        const alt: IOrAlt<unknown> = { ALT: () => true };\n        const parser = ctx.parser;\n        alt.ALT = () => {\n            method.ALT(args);\n            if (!parser.isRecording()) {\n                const key = idFunc(orIdx, parser);\n                if (!parser.unorderedGroups.get(key)) {\n                    // init after clear state\n                    parser.unorderedGroups.set(key, []);\n                }\n                const groupState = parser.unorderedGroups.get(key)!;\n                if (typeof groupState?.[idx] === 'undefined') {\n                    // Not accessed yet\n                    groupState[idx] = true;\n                }\n            }\n        };\n        const gate = method.GATE;\n        if (gate) {\n            alt.GATE = () => gate(args);\n        } else {\n            alt.GATE = () => {\n                const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\n                const allow = !trackedAlternatives?.[idx];\n                return allow;\n            };\n        }\n        return alt;\n    }));\n    const wrapped = wrap(ctx, getGuardCondition(group), alternatives, '*');\n    return (args) => {\n        wrapped(args);\n        if (!ctx.parser.isRecording()) {\n            ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\n        }\n    };\n}\n\nfunction buildGroup(ctx: RuleContext, group: Group): Method {\n    const methods = group.elements.map(e => buildElement(ctx, e));\n    return (args) => methods.forEach(method => method(args));\n}\n\nfunction getGuardCondition(element: AbstractElement): Condition | undefined {\n    if (isGroup(element)) {\n        return element.guardCondition;\n    }\n    return undefined;\n}\n\nfunction buildCrossReference(ctx: RuleContext, crossRef: CrossReference, terminal = crossRef.terminal): Method {\n    if (!terminal) {\n        if (!crossRef.type.ref) {\n            throw new Error('Could not resolve reference to type: ' + crossRef.type.$refText);\n        }\n        const assignment = findNameAssignment(crossRef.type.ref);\n        const assignTerminal = assignment?.terminal;\n        if (!assignTerminal) {\n            throw new Error('Could not find name assignment for type: ' + getTypeName(crossRef.type.ref));\n        }\n        return buildCrossReference(ctx, crossRef, assignTerminal);\n    } else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {\n        const idx = ctx.subrule++;\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, terminal.rule.ref as ParserRule), crossRef, args);\n    } else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {\n        const idx = ctx.consume++;\n        const terminalRule = getToken(ctx, terminal.rule.ref.name);\n        return () => ctx.parser.consume(idx, terminalRule, crossRef);\n    } else if (isKeyword(terminal)) {\n        const idx = ctx.consume++;\n        const keyword = getToken(ctx, terminal.value);\n        return () => ctx.parser.consume(idx, keyword, crossRef);\n    }\n    else {\n        throw new Error('Could not build cross reference parser');\n    }\n}\n\nfunction buildKeyword(ctx: RuleContext, keyword: Keyword): Method {\n    const idx = ctx.consume++;\n    const token = ctx.tokens[keyword.value];\n    if (!token) {\n        throw new Error('Could not find token for keyword: ' + keyword.value);\n    }\n    return () => ctx.parser.consume(idx, token, keyword);\n}\n\nfunction wrap(ctx: RuleContext, guard: Condition | undefined, method: Method, cardinality: Cardinality): Method {\n    const gate = guard && buildPredicate(guard);\n\n    if (!cardinality) {\n        if (gate) {\n            const idx = ctx.or++;\n            return (args) => ctx.parser.alternatives(idx, [\n                {\n                    ALT: () => method(args),\n                    GATE: () => gate(args)\n                },\n                {\n                    ALT: EMPTY_ALT(),\n                    GATE: () => !gate(args)\n                }\n            ]);\n        } else {\n            return method;\n        }\n    }\n\n    if (cardinality === '*') {\n        const idx = ctx.many++;\n        return (args) => ctx.parser.many(idx, {\n            DEF: () => method(args),\n            GATE: gate ? () => gate(args) : undefined\n        });\n    } else if (cardinality === '+') {\n        const idx = ctx.many++;\n        if (gate) {\n            const orIdx = ctx.or++;\n            // In the case of a guard condition for the `+` group\n            // We combine it with an empty alternative\n            // If the condition returns true, it needs to parse at least a single iteration\n            // If its false, it is not allowed to parse anything\n            return (args) => ctx.parser.alternatives(orIdx, [\n                {\n                    ALT: () => ctx.parser.atLeastOne(idx, {\n                        DEF: () => method(args)\n                    }),\n                    GATE: () => gate(args)\n                },\n                {\n                    ALT: EMPTY_ALT(),\n                    GATE: () => !gate(args)\n                }\n            ]);\n        } else {\n            return (args) => ctx.parser.atLeastOne(idx, {\n                DEF: () => method(args),\n            });\n        }\n    } else if (cardinality === '?') {\n        const idx = ctx.optional++;\n        return (args) => ctx.parser.optional(idx, {\n            DEF: () => method(args),\n            GATE: gate ? () => gate(args) : undefined\n        });\n    } else {\n        assertUnreachable(cardinality);\n    }\n}\n\nfunction getRule(ctx: ParserContext, element: ParserRule | AbstractElement): Rule {\n    const name = getRuleName(ctx, element);\n    const rule = ctx.rules.get(name);\n    if (!rule) throw new Error(`Rule \"${name}\" not found.\"`);\n    return rule;\n}\n\nfunction getRuleName(ctx: ParserContext, element: ParserRule | AbstractElement): string {\n    if (isParserRule(element)) {\n        return element.name;\n    } else if (ctx.ruleNames.has(element)) {\n        return ctx.ruleNames.get(element)!;\n    } else {\n        let item: AstNode = element;\n        let parent: AstNode = item.$container!;\n        let ruleName: string = element.$type;\n        while (!isParserRule(parent)) {\n            if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {\n                const index = parent.elements.indexOf(item as AbstractElement);\n                ruleName = index.toString() + ':' + ruleName;\n            }\n            item = parent;\n            parent = parent.$container!;\n        }\n        const rule = parent as ParserRule;\n        ruleName = rule.name + ':' + ruleName;\n        ctx.ruleNames.set(element, ruleName);\n        return ruleName;\n    }\n}\n\nfunction getToken(ctx: ParserContext, name: string): TokenType {\n    const token = ctx.tokens[name];\n    if (!token) throw new Error(`Token \"${name}\" not found.\"`);\n    return token;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4235, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4241, "column": 0}, "map": {"version":3,"file":"completion-parser-builder.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/parser/completion-parser-builder.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { LangiumCoreServices } from '../services.js';\nimport { LangiumCompletionParser } from './langium-parser.js';\nimport { createParser } from './parser-builder-base.js';\n\nexport function createCompletionParser(services: LangiumCoreServices): LangiumCompletionParser {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new LangiumCompletionParser(services);\n    createParser(grammar, parser, lexer.definition);\n    parser.finalize();\n    return parser;\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;AAGhF,OAAO,EAAE,uBAAuB,EAAE,MAAM,qBAAqB,CAAC;AAC9D,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;;;AAElD,SAAU,sBAAsB,CAAC,QAA6B;IAChE,MAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;IACjC,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC;IACpC,MAAM,MAAM,GAAG,6LAAI,0BAAuB,CAAC,QAAQ,CAAC,CAAC;yMACrD,eAAA,AAAY,EAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;IAChD,MAAM,CAAC,QAAQ,EAAE,CAAC;IAClB,OAAO,MAAM,CAAC;AAClB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4260, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4266, "column": 0}, "map": {"version":3,"file":"langium-parser-builder.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/parser/langium-parser-builder.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { LangiumCoreServices } from '../services.js';\nimport { LangiumParser } from './langium-parser.js';\nimport { createParser } from './parser-builder-base.js';\n\n/**\n * Create and finalize a Langium parser. The parser rules are derived from the grammar, which is\n * available at `services.Grammar`.\n */\nexport function createLangiumParser(services: LangiumCoreServices): LangiumParser {\n    const parser = prepareLangiumParser(services);\n    parser.finalize();\n    return parser;\n}\n\n/**\n * Create a Langium parser without finalizing it. This is used to extract more detailed error\n * information when the parser is initially validated.\n */\nexport function prepareLangiumParser(services: LangiumCoreServices): LangiumParser {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new LangiumParser(services);\n    return createParser(grammar, parser, lexer.definition);\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AAGhF,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;AACpD,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;;;AAMlD,SAAU,mBAAmB,CAAC,QAA6B;IAC7D,MAAM,MAAM,GAAG,oBAAoB,CAAC,QAAQ,CAAC,CAAC;IAC9C,MAAM,CAAC,QAAQ,EAAE,CAAC;IAClB,OAAO,MAAM,CAAC;AAClB,CAAC;AAMK,SAAU,oBAAoB,CAAC,QAA6B;IAC9D,MAAM,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;IACjC,MAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC;IACpC,MAAM,MAAM,GAAG,6LAAI,gBAAa,CAAC,QAAQ,CAAC,CAAC;IAC3C,4MAAO,eAAA,AAAY,EAAC,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;AAC3D,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4289, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4295, "column": 0}, "map": {"version":3,"file":"token-builder.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/parser/token-builder.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { CustomPatternMatcherFunc, TokenPattern, TokenType, TokenVocabulary } from 'chevrotain';\nimport type { AbstractRule, Grammar, Keyword, TerminalRule } from '../languages/generated/ast.js';\nimport type { Stream } from '../utils/stream.js';\nimport { Lexer } from 'chevrotain';\nimport { isKeyword, isParserRule, isTerminalRule } from '../languages/generated/ast.js';\nimport { streamAllContents } from '../utils/ast-utils.js';\nimport { getAllReachableRules, terminalRegex } from '../utils/grammar-utils.js';\nimport { getCaseInsensitivePattern, isWhitespace, partialMatches } from '../utils/regexp-utils.js';\nimport { stream } from '../utils/stream.js';\n\nexport interface TokenBuilderOptions {\n    caseInsensitive?: boolean\n}\n\nexport interface TokenBuilder {\n    buildTokens(grammar: Grammar, options?: TokenBuilderOptions): TokenVocabulary;\n}\n\nexport class DefaultTokenBuilder implements TokenBuilder {\n\n    buildTokens(grammar: Grammar, options?: TokenBuilderOptions): TokenVocabulary {\n        const reachableRules = stream(getAllReachableRules(grammar, false));\n        const terminalTokens: TokenType[] = this.buildTerminalTokens(reachableRules);\n        const tokens: TokenType[] = this.buildKeywordTokens(reachableRules, terminalTokens, options);\n\n        terminalTokens.forEach(terminalToken => {\n            const pattern = terminalToken.PATTERN;\n            if (typeof pattern === 'object' && pattern && 'test' in pattern && isWhitespace(pattern)) {\n                tokens.unshift(terminalToken);\n            } else {\n                tokens.push(terminalToken);\n            }\n        });\n        // We don't need to add the EOF token explicitly.\n        // It is automatically available at the end of the token stream.\n        return tokens;\n    }\n\n    protected buildTerminalTokens(rules: Stream<AbstractRule>): TokenType[] {\n        return rules.filter(isTerminalRule).filter(e => !e.fragment)\n            .map(terminal => this.buildTerminalToken(terminal)).toArray();\n    }\n\n    protected buildTerminalToken(terminal: TerminalRule): TokenType {\n        const regex = terminalRegex(terminal);\n        const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;\n        const tokenType: TokenType = {\n            name: terminal.name,\n            PATTERN: pattern,\n            LINE_BREAKS: true\n        };\n        if (terminal.hidden) {\n            // Only skip tokens that are able to accept whitespace\n            tokenType.GROUP = isWhitespace(regex) ? Lexer.SKIPPED : 'hidden';\n        }\n        return tokenType;\n    }\n\n    protected requiresCustomPattern(regex: RegExp): boolean {\n        if (regex.flags.includes('u')) {\n            // Unicode regexes are not supported by Chevrotain.\n            return true;\n        } else if (regex.source.includes('?<=') || regex.source.includes('?<!')) {\n            // Negative and positive lookbehind are not supported by Chevrotain yet.\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    protected regexPatternFunction(regex: RegExp): CustomPatternMatcherFunc {\n        const stickyRegex = new RegExp(regex, regex.flags + 'y');\n        return (text, offset) => {\n            stickyRegex.lastIndex = offset;\n            const execResult = stickyRegex.exec(text);\n            return execResult;\n        };\n    }\n\n    protected buildKeywordTokens(rules: Stream<AbstractRule>, terminalTokens: TokenType[], options?: TokenBuilderOptions): TokenType[] {\n        return rules\n            // We filter by parser rules, since keywords in terminal rules get transformed into regex and are not actual tokens\n            .filter(isParserRule)\n            .flatMap(rule => streamAllContents(rule).filter(isKeyword))\n            .distinct(e => e.value).toArray()\n            // Sort keywords by descending length\n            .sort((a, b) => b.value.length - a.value.length)\n            .map(keyword => this.buildKeywordToken(keyword, terminalTokens, Boolean(options?.caseInsensitive)));\n    }\n\n    protected buildKeywordToken(keyword: Keyword, terminalTokens: TokenType[], caseInsensitive: boolean): TokenType {\n        return {\n            name: keyword.value,\n            PATTERN: this.buildKeywordPattern(keyword, caseInsensitive),\n            LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)\n        };\n    }\n\n    protected buildKeywordPattern(keyword: Keyword, caseInsensitive: boolean): TokenPattern {\n        return caseInsensitive ?\n            new RegExp(getCaseInsensitivePattern(keyword.value)) :\n            keyword.value;\n    }\n\n    protected findLongerAlt(keyword: Keyword, terminalTokens: TokenType[]): TokenType[] {\n        return terminalTokens.reduce((longerAlts: TokenType[], token) => {\n            const pattern = token?.PATTERN as RegExp;\n            if (pattern?.source && partialMatches('^' + pattern.source + '$', keyword.value)) {\n                longerAlts.push(token);\n            }\n            return longerAlts;\n        }, []);\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;AAKhF,OAAO,EAAE,KAAK,EAAE,MAAM,YAAY,CAAC;AACnC,OAAO,EAAE,SAAS,EAAE,YAAY,EAAE,cAAc,EAAE,MAAM,+BAA+B,CAAC;AACxF,OAAO,EAAE,iBAAiB,EAAE,MAAM,uBAAuB,CAAC;AAC1D,OAAO,EAAE,oBAAoB,EAAE,aAAa,EAAE,MAAM,2BAA2B,CAAC;AAChF,OAAO,EAAE,yBAAyB,EAAE,YAAY,EAAE,cAAc,EAAE,MAAM,0BAA0B,CAAC;AACnG,OAAO,EAAE,MAAM,EAAE,MAAM,oBAAoB,CAAC;;;;;;;;AAUtC,MAAO,mBAAmB;IAE5B,WAAW,CAAC,OAAgB,EAAE,OAA6B,EAAA;QACvD,MAAM,cAAc,oLAAG,SAAA,AAAM,4LAAC,wBAAA,AAAoB,EAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;QACpE,MAAM,cAAc,GAAgB,IAAI,CAAC,mBAAmB,CAAC,cAAc,CAAC,CAAC;QAC7E,MAAM,MAAM,GAAgB,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,cAAc,EAAE,OAAO,CAAC,CAAC;QAE7F,cAAc,CAAC,OAAO,EAAC,aAAa,CAAC,EAAE;YACnC,MAAM,OAAO,GAAG,aAAa,CAAC,OAAO,CAAC;YACtC,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,IAAI,MAAM,IAAI,OAAO,QAAI,qMAAA,AAAY,EAAC,OAAO,CAAC,EAAE;gBACtF,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;aACjC,MAAM;gBACH,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;aAC9B;QACL,CAAC,CAAC,CAAC;QACH,iDAAiD;QACjD,gEAAgE;QAChE,OAAO,MAAM,CAAC;IAClB,CAAC;IAES,mBAAmB,CAAC,KAA2B,EAAA;QACrD,OAAO,KAAK,CAAC,MAAM,2LAAC,kBAAc,CAAC,CAAC,MAAM,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CACvD,GAAG,EAAC,QAAQ,CAAC,EAAE,AAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;IACtE,CAAC;IAES,kBAAkB,CAAC,QAAsB,EAAA;QAC/C,MAAM,KAAK,8LAAG,gBAAA,AAAa,EAAC,QAAQ,CAAC,CAAC;QACtC,MAAM,OAAO,GAAG,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QAC7F,MAAM,SAAS,GAAc;YACzB,IAAI,EAAE,QAAQ,CAAC,IAAI;YACnB,OAAO,EAAE,OAAO;YAChB,WAAW,EAAE,IAAI;SACpB,CAAC;QACF,IAAI,QAAQ,CAAC,MAAM,EAAE;YACjB,sDAAsD;YACtD,SAAS,CAAC,KAAK,OAAG,qMAAA,AAAY,EAAC,KAAK,CAAC,CAAC,CAAC,6LAAC,QAAK,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC;SACpE;QACD,OAAO,SAAS,CAAC;IACrB,CAAC;IAES,qBAAqB,CAAC,KAAa,EAAA;QACzC,IAAI,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;YAC3B,mDAAmD;YACnD,OAAO,IAAI,CAAC;SACf,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;YACrE,wEAAwE;YACxE,OAAO,IAAI,CAAC;SACf,MAAM;YACH,OAAO,KAAK,CAAC;SAChB;IACL,CAAC;IAES,oBAAoB,CAAC,KAAa,EAAA;QACxC,MAAM,WAAW,GAAG,IAAI,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,GAAG,GAAG,CAAC,CAAC;QACzD,OAAO,CAAC,IAAI,EAAE,MAAM,EAAE,EAAE;YACpB,WAAW,CAAC,SAAS,GAAG,MAAM,CAAC;YAC/B,MAAM,UAAU,GAAG,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC1C,OAAO,UAAU,CAAC;QACtB,CAAC,CAAC;IACN,CAAC;IAES,kBAAkB,CAAC,KAA2B,EAAE,cAA2B,EAAE,OAA6B,EAAA;QAChH,OAAO,KAAK,AACR,mHAAmH;SAClH,MAAM,4LAAC,eAAY,CAAC,CACpB,OAAO,EAAC,IAAI,CAAC,EAAE,uLAAC,oBAAA,AAAiB,EAAC,IAAI,CAAC,CAAC,MAAM,4LAAC,YAAS,CAAC,CAAC,CAC1D,QAAQ,EAAC,CAAC,CAAC,EAAG,AAAD,CAAE,CAAC,KAAK,CAAC,CAAC,OAAO,EAAE,AACjC,qCAAqC;SACpC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAG,CAAC,AAAF,CAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAC/C,GAAG,EAAC,OAAO,CAAC,EAAE,AAAC,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,cAAc,EAAE,OAAO,CAAC,OAAO,KAAA,QAAP,OAAO,KAAA,KAAA,IAAA,KAAA,IAAP,OAAO,CAAE,eAAe,CAAC,CAAC,CAAC,CAAC;IAC5G,CAAC;IAES,iBAAiB,CAAC,OAAgB,EAAE,cAA2B,EAAE,eAAwB,EAAA;QAC/F,OAAO;YACH,IAAI,EAAE,OAAO,CAAC,KAAK;YACnB,OAAO,EAAE,IAAI,CAAC,mBAAmB,CAAC,OAAO,EAAE,eAAe,CAAC;YAC3D,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,cAAc,CAAC;SAC1D,CAAC;IACN,CAAC;IAES,mBAAmB,CAAC,OAAgB,EAAE,eAAwB,EAAA;QACpE,OAAO,eAAe,CAAC,CAAC,CACpB,IAAI,MAAM,2LAAC,4BAAA,AAAyB,EAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CACtD,OAAO,CAAC,KAAK,CAAC;IACtB,CAAC;IAES,aAAa,CAAC,OAAgB,EAAE,cAA2B,EAAA;QACjE,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC,UAAuB,EAAE,KAAK,EAAE,EAAE;YAC5D,MAAM,OAAO,GAAG,KAAK,KAAA,QAAL,KAAK,KAAA,KAAA,IAAA,KAAA,IAAL,KAAK,CAAE,OAAiB,CAAC;YACzC,IAAI,CAAA,OAAO,KAAA,QAAP,OAAO,KAAA,KAAA,IAAA,KAAA,IAAP,OAAO,CAAE,MAAM,+LAAI,iBAAA,AAAc,EAAC,GAAG,GAAG,OAAO,CAAC,MAAM,GAAG,GAAG,EAAE,OAAO,CAAC,KAAK,CAAC,EAAE;gBAC9E,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aAC1B;YACD,OAAO,UAAU,CAAC;QACtB,CAAC,EAAE,EAAE,CAAC,CAAC;IACX,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 4393, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4399, "column": 0}, "map": {"version":3,"file":"value-converter.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/parser/value-converter.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { AbstractElement, AbstractRule } from '../languages/generated/ast.js';\nimport type { CstNode } from '../syntax-tree.js';\nimport { isCrossReference, isRuleCall } from '../languages/generated/ast.js';\nimport { getCrossReferenceTerminal, getRuleType } from '../utils/grammar-utils.js';\n\n/**\n * Language-specific service for converting string values from the source text format into a value to be held in the AST.\n */\nexport interface ValueConverter {\n    /**\n     * Converts a string value from the source text format into a value to be held in the AST.\n     */\n    convert(input: string, cstNode: CstNode): ValueType;\n}\n\nexport type ValueType = string | number | boolean | bigint | Date;\n\nexport class DefaultValueConverter implements ValueConverter {\n\n    convert(input: string, cstNode: CstNode): ValueType {\n        let feature: AbstractElement | undefined = cstNode.grammarSource;\n        if (isCrossReference(feature)) {\n            feature = getCrossReferenceTerminal(feature);\n        }\n        if (isRuleCall(feature)) {\n            const rule = feature.rule.ref;\n            if (!rule) {\n                throw new Error('This cst node was not parsed by a rule.');\n            }\n            return this.runConverter(rule, input, cstNode);\n        }\n        return input;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    protected runConverter(rule: AbstractRule, input: string, cstNode: CstNode): ValueType {\n        switch (rule.name.toUpperCase()) {\n            case 'INT': return ValueConverter.convertInt(input);\n            case 'STRING': return ValueConverter.convertString(input);\n            case 'ID': return ValueConverter.convertID(input);\n        }\n        switch (getRuleType(rule)?.toLowerCase()) {\n            case 'number': return ValueConverter.convertNumber(input);\n            case 'boolean': return ValueConverter.convertBoolean(input);\n            case 'bigint': return ValueConverter.convertBigint(input);\n            case 'date': return ValueConverter.convertDate(input);\n            default: return input;\n        }\n    }\n}\n\nexport namespace ValueConverter {\n\n    export function convertString(input: string): string {\n        let result = '';\n        for (let i = 1; i < input.length - 1; i++) {\n            const c = input.charAt(i);\n            if (c === '\\\\') {\n                const c1 = input.charAt(++i);\n                result += convertEscapeCharacter(c1);\n            } else {\n                result += c;\n            }\n        }\n        return result;\n    }\n\n    function convertEscapeCharacter(char: string): string {\n        switch (char) {\n            case 'b': return '\\b';\n            case 'f': return '\\f';\n            case 'n': return '\\n';\n            case 'r': return '\\r';\n            case 't': return '\\t';\n            case 'v': return '\\v';\n            case '0': return '\\0';\n            default: return char;\n        }\n    }\n\n    export function convertID(input: string): string {\n        if (input.charAt(0) === '^') {\n            return input.substring(1);\n        } else {\n            return input;\n        }\n    }\n\n    export function convertInt(input: string): number {\n        return parseInt(input);\n    }\n\n    export function convertBigint(input: string): bigint {\n        return BigInt(input);\n    }\n\n    export function convertDate(input: string): Date {\n        return new Date(input);\n    }\n\n    export function convertNumber(input: string): number {\n        return Number(input);\n    }\n\n    export function convertBoolean(input: string): boolean {\n        return input.toLowerCase() === 'true';\n    }\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4516, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4522, "column": 0}, "map": {"version":3,"file":"cancellation.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/cancellation.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2024 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n// eslint-disable-next-line no-restricted-imports\nexport * from 'vscode-jsonrpc/lib/common/cancellation.js';\n"],"names":[],"mappings":"AAAA;;;;gFAIgF,CAEhF,iDAAiD","ignoreList":[0]}},
    {"offset": {"line": 4530, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4545, "column": 0}, "map": {"version":3,"file":"promise-utils.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/promise-utils.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport { CancellationToken, CancellationTokenSource, type AbstractCancellationTokenSource } from '../utils/cancellation.js';\n\nexport type MaybePromise<T> = T | Promise<T>\n\n/**\n * Delays the execution of the current code to the next tick of the event loop.\n * Don't call this method directly in a tight loop to prevent too many promises from being created.\n */\nexport function delayNextTick(): Promise<void> {\n    return new Promise(resolve => {\n        // In case we are running in a non-node environment, `setImmediate` isn't available.\n        // Using `setTimeout` of the browser API accomplishes the same result.\n        if (typeof setImmediate === 'undefined') {\n            setTimeout(resolve, 0);\n        } else {\n            setImmediate(resolve);\n        }\n    });\n}\n\nlet lastTick = 0;\nlet globalInterruptionPeriod = 10;\n\n/**\n * Reset the global interruption period and create a cancellation token source.\n */\nexport function startCancelableOperation(): AbstractCancellationTokenSource {\n    lastTick = Date.now();\n    return new CancellationTokenSource();\n}\n\n/**\n * Change the period duration for `interruptAndCheck` to the given number of milliseconds.\n * The default value is 10ms.\n */\nexport function setInterruptionPeriod(period: number): void {\n    globalInterruptionPeriod = period;\n}\n\n/**\n * This symbol may be thrown in an asynchronous context by any Langium service that receives\n * a `CancellationToken`. This means that the promise returned by such a service is rejected with\n * this symbol as rejection reason.\n */\nexport const OperationCancelled = Symbol('OperationCancelled');\n\n/**\n * Use this in a `catch` block to check whether the thrown object indicates that the operation\n * has been cancelled.\n */\nexport function isOperationCancelled(err: unknown): err is typeof OperationCancelled {\n    return err === OperationCancelled;\n}\n\n/**\n * This function does two things:\n *  1. Check the elapsed time since the last call to this function or to `startCancelableOperation`. If the predefined\n *     period (configured with `setInterruptionPeriod`) is exceeded, execution is delayed with `delayNextTick`.\n *  2. If the predefined period is not met yet or execution is resumed after an interruption, the given cancellation\n *     token is checked, and if cancellation is requested, `OperationCanceled` is thrown.\n *\n * All services in Langium that receive a `CancellationToken` may potentially call this function, so the\n * `CancellationToken` must be caught (with an `async` try-catch block or a `catch` callback attached to\n * the promise) to avoid that event being exposed as an error.\n */\nexport async function interruptAndCheck(token: CancellationToken): Promise<void> {\n    if (token === CancellationToken.None) {\n        // Early exit in case cancellation was disabled by the caller\n        return;\n    }\n    const current = Date.now();\n    if (current - lastTick >= globalInterruptionPeriod) {\n        lastTick = current;\n        await delayNextTick();\n    }\n    if (token.isCancellationRequested) {\n        throw OperationCancelled;\n    }\n}\n\n/**\n * Simple implementation of the deferred pattern.\n * An object that exposes a promise and functions to resolve and reject it.\n */\nexport class Deferred<T = void> {\n    resolve: (value: T) => this;\n    reject: (err?: unknown) => this;\n\n    promise = new Promise<T>((resolve, reject) => {\n        this.resolve = (arg) => {\n            resolve(arg);\n            return this;\n        };\n        this.reject = (err) => {\n            reject(err);\n            return this;\n        };\n    });\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;;;;;;;AAEhF,OAAO,EAAE,iBAAiB,EAAE,uBAAuB,EAAwC,MAAM,0BAA0B,CAAC;;AAQtH,SAAU,aAAa;IACzB,OAAO,IAAI,OAAO,EAAC,OAAO,CAAC,EAAE;QACzB,oFAAoF;QACpF,sEAAsE;QACtE,IAAI,OAAO,YAAY,KAAK,WAAW,EAAE;YACrC,UAAU,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;SAC1B,MAAM;YACH,YAAY,CAAC,OAAO,CAAC,CAAC;SACzB;IACL,CAAC,CAAC,CAAC;AACP,CAAC;AAED,IAAI,QAAQ,GAAG,CAAC,CAAC;AACjB,IAAI,wBAAwB,GAAG,EAAE,CAAC;AAK5B,SAAU,wBAAwB;IACpC,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IACtB,OAAO,kMAAI,0BAAuB,EAAE,CAAC;AACzC,CAAC;AAMK,SAAU,qBAAqB,CAAC,MAAc;IAChD,wBAAwB,GAAG,MAAM,CAAC;AACtC,CAAC;AAOM,MAAM,kBAAkB,GAAG,MAAM,CAAC,oBAAoB,CAAC,CAAC;AAMzD,SAAU,oBAAoB,CAAC,GAAY;IAC7C,OAAO,GAAG,KAAK,kBAAkB,CAAC;AACtC,CAAC;AAaM,KAAK,UAAU,iBAAiB,CAAC,KAAwB;IAC5D,IAAI,KAAK,mMAAK,oBAAiB,CAAC,IAAI,EAAE;QAClC,6DAA6D;QAC7D,OAAO;KACV;IACD,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;IAC3B,IAAI,OAAO,GAAG,QAAQ,IAAI,wBAAwB,EAAE;QAChD,QAAQ,GAAG,OAAO,CAAC;QACnB,MAAM,aAAa,EAAE,CAAC;KACzB;IACD,IAAI,KAAK,CAAC,uBAAuB,EAAE;QAC/B,MAAM,kBAAkB,CAAC;KAC5B;AACL,CAAC;AAMK,MAAO,QAAQ;IAArB,aAAA;QAII,IAAA,CAAA,OAAO,GAAG,IAAI,OAAO,CAAI,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACzC,IAAI,CAAC,OAAO,GAAG,CAAC,GAAG,EAAE,EAAE;gBACnB,OAAO,CAAC,GAAG,CAAC,CAAC;gBACb,OAAO,IAAI,CAAC;YAChB,CAAC,CAAC;YACF,IAAI,CAAC,MAAM,GAAG,CAAC,GAAG,EAAE,EAAE;gBAClB,MAAM,CAAC,GAAG,CAAC,CAAC;gBACZ,OAAO,IAAI,CAAC;YAChB,CAAC,CAAC;QACN,CAAC,CAAC,CAAC;IACP,CAAC;CAAA","ignoreList":[0]}},
    {"offset": {"line": 4613, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4619, "column": 0}, "map": {"version":3,"file":"uri-utils.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/uri-utils.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport { URI, Utils } from 'vscode-uri';\n\nexport { URI };\n\nexport namespace UriUtils {\n\n    export const basename = Utils.basename;\n    export const dirname = Utils.dirname;\n    export const extname = Utils.extname;\n    export const joinPath = Utils.joinPath;\n    export const resolvePath = Utils.resolvePath;\n\n    export function equals(a?: URI | string, b?: URI | string): boolean {\n        return a?.toString() === b?.toString();\n    }\n\n    export function relative(from: URI | string, to: URI | string): string {\n        const fromPath = typeof from === 'string' ? from : from.path;\n        const toPath = typeof to === 'string' ? to : to.path;\n        const fromParts = fromPath.split('/').filter(e => e.length > 0);\n        const toParts = toPath.split('/').filter(e => e.length > 0);\n        let i = 0;\n        for (; i < fromParts.length; i++) {\n            if (fromParts[i] !== toParts[i]) {\n                break;\n            }\n        }\n        const backPart = '../'.repeat(fromParts.length - i);\n        const toPart = toParts.slice(i).join('/');\n        return backPart + toPart;\n    }\n\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;AAEhF,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,YAAY,CAAC;;;AAIlC,IAAW,QAAQ,CA4BxB;AA5BD,CAAA,SAAiB,QAAQ;IAER,SAAA,QAAQ,oLAAG,QAAK,CAAC,QAAQ,CAAC;IAC1B,SAAA,OAAO,oLAAG,QAAK,CAAC,OAAO,CAAC;IACxB,SAAA,OAAO,oLAAG,QAAK,CAAC,OAAO,CAAC;IACxB,SAAA,QAAQ,oLAAG,QAAK,CAAC,QAAQ,CAAC;IAC1B,SAAA,WAAW,oLAAG,QAAK,CAAC,WAAW,CAAC;IAE7C,SAAgB,MAAM,CAAC,CAAgB,EAAE,CAAgB;QACrD,OAAO,CAAA,CAAC,KAAA,QAAD,CAAC,KAAA,KAAA,IAAA,KAAA,IAAD,CAAC,CAAE,QAAQ,EAAE,MAAA,CAAK,CAAC,KAAA,QAAD,CAAC,KAAA,KAAA,IAAA,KAAA,IAAD,CAAC,CAAE,QAAQ,EAAE,CAAA,CAAC;IAC3C,CAAC;IAFe,SAAA,MAAM,GAAA,MAErB,CAAA;IAED,SAAgB,QAAQ,CAAC,IAAkB,EAAE,EAAgB;QACzD,MAAM,QAAQ,GAAG,OAAO,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAC7D,MAAM,MAAM,GAAG,OAAO,EAAE,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC;QACrD,MAAM,SAAS,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAChE,MAAM,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC5D,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,MAAO,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;YAC9B,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,OAAO,CAAC,CAAC,CAAC,EAAE;gBAC7B,MAAM;aACT;SACJ;QACD,MAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACpD,MAAM,MAAM,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC1C,OAAO,QAAQ,GAAG,MAAM,CAAC;IAC7B,CAAC;IAde,SAAA,QAAQ,GAAA,QAcvB,CAAA;AAEL,CAAC,EA5BgB,QAAQ,IAAA,CAAR,QAAQ,GAAA,CAAA,CAAA,GA4BxB","ignoreList":[0]}},
    {"offset": {"line": 4657, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4671, "column": 0}, "map": {"version":3,"file":"documents.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/workspace/documents.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/**\n * Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,\n *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,\n *  the overhead is very small, just a few kilobytes.\n * Everything else of that package (at the time contributing) is also defined\n *  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.\n */\nexport { TextDocument } from 'vscode-languageserver-textdocument';\n\nimport type { Diagnostic, Range } from 'vscode-languageserver-types';\nimport type { FileSystemProvider } from './file-system-provider.js';\nimport type { ParseResult } from '../parser/langium-parser.js';\nimport type { ServiceRegistry } from '../service-registry.js';\nimport type { LangiumSharedCoreServices } from '../services.js';\nimport type { AstNode, AstNodeDescription, Mutable, Reference } from '../syntax-tree.js';\nimport type { MultiMap } from '../utils/collections.js';\nimport type { Stream } from '../utils/stream.js';\nimport { TextDocument } from './documents.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { stream } from '../utils/stream.js';\nimport { URI } from '../utils/uri-utils.js';\n\n/**\n * A Langium document holds the parse result (AST and CST) and any additional state that is derived\n * from the AST, e.g. the result of scope precomputation.\n */\nexport interface LangiumDocument<T extends AstNode = AstNode> {\n    /** The Uniform Resource Identifier (URI) of the document */\n    readonly uri: URI;\n    /** The text document used to convert between offsets and positions */\n    readonly textDocument: TextDocument;\n    /** The current state of the document */\n    state: DocumentState;\n    /** The parse result holds the Abstract Syntax Tree (AST) and potentially also parser / lexer errors */\n    parseResult: ParseResult<T>;\n    /** Result of the scope precomputation phase */\n    precomputedScopes?: PrecomputedScopes;\n    /** An array of all cross-references found in the AST while linking */\n    references: Reference[];\n    /** Result of the validation phase */\n    diagnostics?: Diagnostic[]\n}\n\n/**\n * A document is subject to several phases that are run in predefined order. Any state value implies that\n * smaller state values are finished as well.\n */\nexport enum DocumentState {\n    /**\n     * The text content has changed and needs to be parsed again. The AST held by this outdated\n     * document instance is no longer valid.\n     */\n    Changed = 0,\n    /**\n     * An AST has been created from the text content. The document structure can be traversed,\n     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated\n     * at this stage as a preprocessing step.\n     */\n    Parsed = 1,\n    /**\n     * The `IndexManager` service has processed AST nodes of this document. This means the\n     * exported symbols are available in the global scope and can be resolved from other documents.\n     */\n    IndexedContent = 2,\n    /**\n     * The `ScopeComputation` service has processed this document. This means the local symbols\n     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.\n     * Once a document has reached this state, you may follow every reference - it will lazily\n     * resolve its `ref` property and yield either the target AST node or `undefined` in case\n     * the target is not in scope.\n     */\n    ComputedScopes = 3,\n    /**\n     * The `Linker` service has processed this document. All outgoing references have been\n     * resolved or marked as erroneous.\n     */\n    Linked = 4,\n    /**\n     * The `IndexManager` service has processed AST node references of this document. This is\n     * necessary to determine which documents are affected by a change in one of the workspace\n     * documents.\n     */\n    IndexedReferences = 5,\n    /**\n     * The `DocumentValidator` service has processed this document. The language server listens\n     * to the results of this phase and sends diagnostics to the client.\n     */\n    Validated = 6\n}\n\n/**\n * Result of the scope precomputation phase (`ScopeComputation` service).\n * It maps every AST node to the set of symbols that are visible in the subtree of that node.\n */\nexport type PrecomputedScopes = MultiMap<AstNode, AstNodeDescription>\n\nexport interface DocumentSegment {\n    readonly range: Range\n    readonly offset: number\n    readonly length: number\n    readonly end: number\n}\n\n/**\n * Surrogate definition of the `TextDocuments` interface from the `vscode-languageserver` package.\n * No implementation object is expected to be offered by `LangiumCoreServices`, but only by `LangiumLSPServices`.\n */\nexport type TextDocumentProvider = {\n    get(uri: string): TextDocument | undefined\n}\n\n/**\n * Shared service for creating `LangiumDocument` instances.\n *\n * Register a custom implementation if special (additional) behavior is required for your language(s).\n * Note: If you specialize {@link fromString} or {@link fromTextDocument} you probably might want to\n * specialize {@link update}, too!\n */\nexport interface LangiumDocumentFactory {\n    /**\n     * Create a Langium document from a `TextDocument` (usually associated with a file).\n     */\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI): LangiumDocument<T>;\n    /**\n     * Create a Langium document from a `TextDocument` asynchronously. This action can be cancelled if a cancellable parser implementation has been provided.\n     */\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri: URI | undefined, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;\n\n    /**\n     * Create an Langium document from an in-memory string.\n     */\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI): LangiumDocument<T>;\n    /**\n     * Create a Langium document from an in-memory string asynchronously. This action can be cancelled if a cancellable parser implementation has been provided.\n     */\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;\n\n    /**\n     * Create an Langium document from a model that has been constructed in memory.\n     */\n    fromModel<T extends AstNode = AstNode>(model: T, uri: URI): LangiumDocument<T>;\n\n    /**\n     * Create an Langium document from a specified `URI`. The factory will use the `FileSystemAccess` service to read the file.\n     */\n    fromUri<T extends AstNode = AstNode>(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument<T>>;\n\n    /**\n     * Update the given document after changes in the corresponding textual representation.\n     * Method is called by the document builder after it has been requested to build an existing\n     * document and the document's state is {@link DocumentState.Changed}.\n     * The text parsing is expected to be done the same way as in {@link fromTextDocument}\n     * and {@link fromString}.\n     */\n    update<T extends AstNode = AstNode>(document: LangiumDocument<T>, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>\n}\n\nexport class DefaultLangiumDocumentFactory implements LangiumDocumentFactory {\n\n    protected readonly serviceRegistry: ServiceRegistry;\n    protected readonly textDocuments?: TextDocumentProvider;\n    protected readonly fileSystemProvider: FileSystemProvider;\n\n    constructor(services: LangiumSharedCoreServices) {\n        this.serviceRegistry = services.ServiceRegistry;\n        this.textDocuments = services.workspace.TextDocuments;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n    }\n\n    async fromUri<T extends AstNode = AstNode>(uri: URI, cancellationToken = CancellationToken.None): Promise<LangiumDocument<T>> {\n        const content = await this.fileSystemProvider.readFile(uri);\n        return this.createAsync<T>(uri, content, cancellationToken);\n    }\n\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI): LangiumDocument<T>;\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri: URI | undefined, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI, cancellationToken?: CancellationToken): LangiumDocument<T> | Promise<LangiumDocument<T>> {\n        uri = uri ?? URI.parse(textDocument.uri);\n        if (cancellationToken) {\n            return this.createAsync<T>(uri, textDocument, cancellationToken);\n        } else {\n            return this.create<T>(uri, textDocument);\n        }\n    }\n\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI): LangiumDocument<T>;\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, cancellationToken: CancellationToken): Promise<LangiumDocument<T>>;\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI, cancellationToken?: CancellationToken): LangiumDocument<T> | Promise<LangiumDocument<T>> {\n        if (cancellationToken) {\n            return this.createAsync<T>(uri, text, cancellationToken);\n        } else {\n            return this.create<T>(uri, text);\n        }\n    }\n\n    fromModel<T extends AstNode = AstNode>(model: T, uri: URI): LangiumDocument<T> {\n        return this.create<T>(uri, { $model: model });\n    }\n\n    protected create<T extends AstNode = AstNode>(uri: URI, content: string | TextDocument | { $model: T }): LangiumDocument<T> {\n        if (typeof content === 'string') {\n            const parseResult = this.parse<T>(uri, content);\n            return this.createLangiumDocument<T>(parseResult, uri, undefined, content);\n\n        } else if ('$model' in content) {\n            const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };\n            return this.createLangiumDocument<T>(parseResult, uri);\n\n        } else {\n            const parseResult = this.parse<T>(uri, content.getText());\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n\n    protected async createAsync<T extends AstNode = AstNode>(uri: URI, content: string | TextDocument, cancelToken: CancellationToken): Promise<LangiumDocument<T>> {\n        if (typeof content === 'string') {\n            const parseResult = await this.parseAsync<T>(uri, content, cancelToken);\n            return this.createLangiumDocument<T>(parseResult, uri, undefined, content);\n        } else {\n            const parseResult = await this.parseAsync<T>(uri, content.getText(), cancelToken);\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n\n    /**\n     * Create a LangiumDocument from a given parse result.\n     *\n     * A TextDocument is created on demand if it is not provided as argument here. Usually this\n     * should not be necessary because the main purpose of the TextDocument is to convert between\n     * text ranges and offsets, which is done solely in LSP request handling.\n     *\n     * With the introduction of {@link update} below this method is supposed to be mainly called\n     * during workspace initialization and on addition/recognition of new files, while changes in\n     * existing documents are processed via {@link update}.\n     */\n    protected createLangiumDocument<T extends AstNode = AstNode>(parseResult: ParseResult<T>, uri: URI, textDocument?: TextDocument, text?: string): LangiumDocument<T> {\n        let document: LangiumDocument<T>;\n        if (textDocument) {\n            document = {\n                parseResult,\n                uri,\n                state: DocumentState.Parsed,\n                references: [],\n                textDocument\n            };\n        } else {\n            const textDocumentGetter = this.createTextDocumentGetter(uri, text);\n            document = {\n                parseResult,\n                uri,\n                state: DocumentState.Parsed,\n                references: [],\n                get textDocument() {\n                    return textDocumentGetter();\n                }\n            };\n        }\n        (parseResult.value as Mutable<AstNode>).$document = document;\n        return document;\n    }\n\n    async update<T extends AstNode = AstNode>(document: Mutable<LangiumDocument<T>>, cancellationToken: CancellationToken): Promise<LangiumDocument<T>> {\n        // The CST full text property contains the original text that was used to create the AST.\n        const oldText = document.parseResult.value.$cstNode?.root.fullText;\n        const textDocument = this.textDocuments?.get(document.uri.toString());\n        const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);\n\n        if (textDocument) {\n            Object.defineProperty(\n                document,\n                'textDocument',\n                {\n                    value: textDocument\n                }\n            );\n        } else {\n            const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\n            Object.defineProperty(\n                document,\n                'textDocument',\n                {\n                    get: textDocumentGetter\n                }\n            );\n        }\n\n        // Some of these documents can be pretty large, so parsing them again can be quite expensive.\n        // Therefore, we only parse if the text has actually changed.\n        if (oldText !== text) {\n            document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);\n            (document.parseResult.value as Mutable<AstNode>).$document = document;\n        }\n        document.state = DocumentState.Parsed;\n        return document;\n    }\n\n    protected parse<T extends AstNode>(uri: URI, text: string): ParseResult<T> {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.LangiumParser.parse<T>(text);\n    }\n\n    protected parseAsync<T extends AstNode>(uri: URI, text: string, cancellationToken: CancellationToken): Promise<ParseResult<T>> {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.AsyncParser.parse<T>(text, cancellationToken);\n    }\n\n    protected createTextDocumentGetter(uri: URI, text?: string): () => TextDocument {\n        const serviceRegistry = this.serviceRegistry;\n        let textDoc: TextDocument | undefined = undefined;\n        return () => {\n            return textDoc ??= TextDocument.create(\n                uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text ?? ''\n            );\n        };\n    }\n}\n\n/**\n * Shared service for managing Langium documents.\n */\nexport interface LangiumDocuments {\n\n    /**\n     * A stream of all documents managed under this service.\n     */\n    readonly all: Stream<LangiumDocument>\n\n    /**\n     * Manage a new document under this service.\n     * @throws an error if a document with the same URI is already present.\n     */\n    addDocument(document: LangiumDocument): void;\n\n    /**\n     * Retrieve the document with the given URI, if present. Otherwise returns `undefined`.\n     */\n    getDocument(uri: URI): LangiumDocument | undefined;\n\n    /**\n     * Retrieve the document with the given URI. If not present, a new one will be created using the file system access.\n     * The new document will be added to the list of documents managed under this service.\n     */\n    getOrCreateDocument(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument>;\n\n    /**\n     * Creates a new document with the given URI and text content.\n     * The new document is automatically added to this service and can be retrieved using {@link getDocument}.\n     *\n     * @throws an error if a document with the same URI is already present.\n     */\n    createDocument(uri: URI, text: string): LangiumDocument;\n\n    /**\n     * Creates a new document with the given URI and text content asynchronously.\n     * The process can be interrupted with a cancellation token.\n     * The new document is automatically added to this service and can be retrieved using {@link getDocument}.\n     *\n     * @throws an error if a document with the same URI is already present.\n     */\n    createDocument(uri: URI, text: string, cancellationToken: CancellationToken): Promise<LangiumDocument>;\n\n    /**\n     * Returns `true` if a document with the given URI is managed under this service.\n     */\n    hasDocument(uri: URI): boolean;\n\n    /**\n     * Flag the document with the given URI as `Changed`, if present, meaning that its content\n     * is no longer valid. The content (parseResult) stays untouched, while internal data may\n     * be dropped to reduce memory footprint.\n     *\n     * @returns the affected {@link LangiumDocument} if existing for convenience\n     */\n    invalidateDocument(uri: URI): LangiumDocument | undefined;\n\n    /**\n     * Remove the document with the given URI, if present, and mark it as `Changed`, meaning\n     * that its content is no longer valid. The next call to `getOrCreateDocument` with the same\n     * URI will create a new document instance.\n     *\n     * @returns the affected {@link LangiumDocument} if existing for convenience\n     */\n    deleteDocument(uri: URI): LangiumDocument | undefined;\n}\n\nexport class DefaultLangiumDocuments implements LangiumDocuments {\n\n    protected readonly langiumDocumentFactory: LangiumDocumentFactory;\n\n    protected readonly documentMap: Map<string, LangiumDocument> = new Map();\n\n    constructor(services: LangiumSharedCoreServices) {\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n    }\n\n    get all(): Stream<LangiumDocument> {\n        return stream(this.documentMap.values());\n    }\n\n    addDocument(document: LangiumDocument): void {\n        const uriString = document.uri.toString();\n        if (this.documentMap.has(uriString)) {\n            throw new Error(`A document with the URI '${uriString}' is already present.`);\n        }\n        this.documentMap.set(uriString, document);\n    }\n\n    getDocument(uri: URI): LangiumDocument | undefined {\n        const uriString = uri.toString();\n        return this.documentMap.get(uriString);\n    }\n\n    async getOrCreateDocument(uri: URI, cancellationToken?: CancellationToken): Promise<LangiumDocument> {\n        let document = this.getDocument(uri);\n        if (document) {\n            return document;\n        }\n        document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);\n        this.addDocument(document);\n        return document;\n    }\n\n    createDocument(uri: URI, text: string): LangiumDocument;\n    createDocument(uri: URI, text: string, cancellationToken: CancellationToken): Promise<LangiumDocument>;\n    createDocument(uri: URI, text: string, cancellationToken?: CancellationToken): LangiumDocument | Promise<LangiumDocument> {\n        if (cancellationToken) {\n            return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then(document => {\n                this.addDocument(document);\n                return document;\n            });\n        } else {\n            const document = this.langiumDocumentFactory.fromString(text, uri);\n            this.addDocument(document);\n            return document;\n        }\n    }\n\n    hasDocument(uri: URI): boolean {\n        return this.documentMap.has(uri.toString());\n    }\n\n    invalidateDocument(uri: URI): LangiumDocument | undefined {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            langiumDoc.state = DocumentState.Changed;\n            langiumDoc.precomputedScopes = undefined;\n            langiumDoc.references = [];\n            langiumDoc.diagnostics = undefined;\n        }\n        return langiumDoc;\n    }\n\n    deleteDocument(uri: URI): LangiumDocument | undefined {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            langiumDoc.state = DocumentState.Changed;\n            this.documentMap.delete(uriString);\n        }\n        return langiumDoc;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4926, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4945, "column": 0}, "map": {"version":3,"file":"linker.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/references/linker.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { LangiumCoreServices } from '../services.js';\nimport type { AstNode, AstNodeDescription, AstReflection, CstNode, LinkingError, Reference, ReferenceInfo } from '../syntax-tree.js';\nimport type { AstNodeLocator } from '../workspace/ast-node-locator.js';\nimport type { LangiumDocument, LangiumDocuments } from '../workspace/documents.js';\nimport type { ScopeProvider } from './scope-provider.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { isAstNode, isAstNodeDescription, isLinkingError } from '../syntax-tree.js';\nimport { getDocument, streamAst, streamReferences } from '../utils/ast-utils.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\nimport { DocumentState } from '../workspace/documents.js';\n\n/**\n * Language-specific service for resolving cross-references in the AST.\n */\nexport interface Linker {\n\n    /**\n     * Links all cross-references within the specified document. The default implementation loads only target\n     * elements from documents that are present in the `LangiumDocuments` service. The linked references are\n     * stored in the document's `references` property.\n     *\n     * @param document A LangiumDocument that shall be linked.\n     * @param cancelToken A token for cancelling the operation.\n     */\n    link(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;\n\n    /**\n     * Unlinks all references within the specified document and removes them from the list of `references`.\n     *\n     * @param document A LangiumDocument that shall be unlinked.\n     */\n    unlink(document: LangiumDocument): void;\n\n    /**\n     * Determines a candidate AST node description for linking the given reference.\n     *\n     * @param node The AST node containing the reference.\n     * @param refId The reference identifier used to build a scope.\n     * @param reference The actual reference to resolve.\n     */\n    getCandidate(refInfo: ReferenceInfo): AstNodeDescription | LinkingError;\n\n    /**\n     * Creates a cross reference node being aware of its containing AstNode, the corresponding CstNode,\n     * the cross reference text denoting the target AstNode being already extracted of the document text,\n     * as well as the unique cross reference identifier.\n     *\n     * Default behavior:\n     *  - The returned Reference's 'ref' property pointing to the target AstNode is populated lazily on its\n     *    first visit.\n     *  - If the target AstNode cannot be resolved on the first visit, an error indicator will be installed\n     *    and further resolution attempts will *not* be performed.\n     *\n     * @param node The containing AST node\n     * @param refNode The corresponding CST node\n     * @param refId The cross reference identifier like '<entityTypeName>:<propertyName>'\n     * @param refText The cross reference text denoting the target AstNode\n     * @returns the desired Reference node, whose behavior wrt. resolving the cross reference is implementation specific.\n     */\n    buildReference(node: AstNode, property: string, refNode: CstNode | undefined, refText: string): Reference;\n\n}\n\ninterface DefaultReference extends Reference {\n    _ref?: AstNode | LinkingError;\n    _nodeDescription?: AstNodeDescription;\n}\n\nexport class DefaultLinker implements Linker {\n    protected readonly reflection: AstReflection;\n    protected readonly scopeProvider: ScopeProvider;\n    protected readonly astNodeLocator: AstNodeLocator;\n    protected readonly langiumDocuments: () => LangiumDocuments;\n\n    constructor(services: LangiumCoreServices) {\n        this.reflection = services.shared.AstReflection;\n        this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;\n        this.scopeProvider = services.references.ScopeProvider;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n    }\n\n    async link(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<void> {\n        for (const node of streamAst(document.parseResult.value)) {\n            await interruptAndCheck(cancelToken);\n            streamReferences(node).forEach(ref => this.doLink(ref, document));\n        }\n    }\n\n    protected doLink(refInfo: ReferenceInfo, document: LangiumDocument): void {\n        const ref = refInfo.reference as DefaultReference;\n        // The reference may already have been resolved lazily by accessing its `ref` property.\n        if (ref._ref === undefined) {\n            try {\n                const description = this.getCandidate(refInfo);\n                if (isLinkingError(description)) {\n                    ref._ref = description;\n                } else {\n                    ref._nodeDescription = description;\n                    if (this.langiumDocuments().hasDocument(description.documentUri)) {\n                        // The target document is already loaded\n                        const linkedNode = this.loadAstNode(description);\n                        ref._ref = linkedNode ?? this.createLinkingError(refInfo, description);\n                    }\n                }\n            } catch (err) {\n                ref._ref = {\n                    ...refInfo,\n                    message: `An error occurred while resolving reference to '${ref.$refText}': ${err}`\n                };\n            }\n        }\n        // Add the reference to the document's array of references\n        document.references.push(ref);\n    }\n\n    unlink(document: LangiumDocument): void {\n        for (const ref of document.references) {\n            delete (ref as DefaultReference)._ref;\n            delete (ref as DefaultReference)._nodeDescription;\n        }\n        document.references = [];\n    }\n\n    getCandidate(refInfo: ReferenceInfo): AstNodeDescription | LinkingError {\n        const scope = this.scopeProvider.getScope(refInfo);\n        const description = scope.getElement(refInfo.reference.$refText);\n        return description ?? this.createLinkingError(refInfo);\n    }\n\n    buildReference(node: AstNode, property: string, refNode: CstNode | undefined, refText: string): Reference {\n        // See behavior description in doc of Linker, update that on changes in here.\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const linker = this;\n        const reference: DefaultReference = {\n            $refNode: refNode,\n            $refText: refText,\n\n            get ref() {\n                if (isAstNode(this._ref)) {\n                    // Most frequent case: the target is already resolved.\n                    return this._ref;\n                } else if (isAstNodeDescription(this._nodeDescription)) {\n                    // A candidate has been found before, but it is not loaded yet.\n                    const linkedNode = linker.loadAstNode(this._nodeDescription);\n                    this._ref = linkedNode ??\n                        linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);\n                } else if (this._ref === undefined) {\n                    // The reference has not been linked yet, so do that now.\n                    const refData = linker.getLinkedNode({ reference, container: node, property });\n                    if (refData.error && getDocument(node).state < DocumentState.ComputedScopes) {\n                        // Document scope is not ready, don't set `this._ref` so linker can retry later.\n                        return undefined;\n                    }\n                    this._ref = refData.node ?? refData.error;\n                    this._nodeDescription = refData.descr;\n                }\n                return isAstNode(this._ref) ? this._ref : undefined;\n            },\n            get $nodeDescription() {\n                return this._nodeDescription;\n            },\n            get error() {\n                return isLinkingError(this._ref) ? this._ref : undefined;\n            }\n        };\n        return reference;\n    }\n\n    protected getLinkedNode(refInfo: ReferenceInfo): { node?: AstNode, descr?: AstNodeDescription, error?: LinkingError } {\n        try {\n            const description = this.getCandidate(refInfo);\n            if (isLinkingError(description)) {\n                return { error: description };\n            }\n            const linkedNode = this.loadAstNode(description);\n            if (linkedNode) {\n                return { node: linkedNode, descr: description };\n            }\n            else {\n                return {\n                    descr: description,\n                    error:\n                        this.createLinkingError(refInfo, description)\n                };\n            }\n        } catch (err) {\n            return {\n                error: {\n                    ...refInfo,\n                    message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${err}`\n                }\n            };\n        }\n    }\n\n    protected loadAstNode(nodeDescription: AstNodeDescription): AstNode | undefined {\n        if (nodeDescription.node) {\n            return nodeDescription.node;\n        }\n        const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);\n        if (!doc) {\n            return undefined;\n        }\n        return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\n    }\n\n    protected createLinkingError(refInfo: ReferenceInfo, targetDescription?: AstNodeDescription): LinkingError {\n        // Check whether the document is sufficiently processed by the DocumentBuilder. If not, this is a hint for a bug\n        // in the language implementation.\n        const document = getDocument(refInfo.container);\n        if (document.state < DocumentState.ComputedScopes) {\n            console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);\n        }\n        const referenceType = this.reflection.getReferenceType(refInfo);\n        return {\n            ...refInfo,\n            message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`,\n            targetDescription\n        };\n    }\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5111, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5117, "column": 0}, "map": {"version":3,"file":"name-provider.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/references/name-provider.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { AstNode, CstNode } from '../syntax-tree.js';\nimport { findNodeForProperty } from '../utils/grammar-utils.js';\n\nexport interface NamedAstNode extends AstNode {\n    name: string;\n}\n\nexport function isNamed(node: AstNode): node is NamedAstNode {\n    return typeof (node as NamedAstNode).name === 'string';\n}\n\n/**\n * Utility service for retrieving the `name` of an `AstNode` or the `CstNode` containing a `name`.\n */\nexport interface NameProvider {\n    /**\n     * Returns the `name` of a given AstNode.\n     * @param node Specified `AstNode` whose name node shall be retrieved.\n     */\n    getName(node: AstNode): string | undefined;\n    /**\n     * Returns the `CstNode` which contains the parsed value of the `name` assignment.\n     * @param node Specified `AstNode` whose name node shall be retrieved.\n     */\n    getNameNode(node: AstNode): CstNode | undefined;\n}\n\nexport class DefaultNameProvider implements NameProvider {\n    getName(node: AstNode): string | undefined {\n        if (isNamed(node)) {\n            return node.name;\n        }\n        return undefined;\n    }\n\n    getNameNode(node: AstNode): CstNode | undefined {\n        return findNodeForProperty(node.$cstNode, 'name');\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AAGhF,OAAO,EAAE,mBAAmB,EAAE,MAAM,2BAA2B,CAAC;;AAM1D,SAAU,OAAO,CAAC,IAAa;IACjC,OAAO,OAAQ,IAAqB,CAAC,IAAI,KAAK,QAAQ,CAAC;AAC3D,CAAC;AAkBK,MAAO,mBAAmB;IAC5B,OAAO,CAAC,IAAa,EAAA;QACjB,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE;YACf,OAAO,IAAI,CAAC,IAAI,CAAC;SACpB;QACD,OAAO,SAAS,CAAC;IACrB,CAAC;IAED,WAAW,CAAC,IAAa,EAAA;QACrB,kMAAO,sBAAA,AAAmB,EAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IACtD,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 5141, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5147, "column": 0}, "map": {"version":3,"file":"references.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/references/references.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { LangiumCoreServices } from '../services.js';\nimport type { AstNode, CstNode, GenericAstNode } from '../syntax-tree.js';\nimport type { Stream } from '../utils/stream.js';\nimport type { ReferenceDescription } from '../workspace/ast-descriptions.js';\nimport type { AstNodeLocator } from '../workspace/ast-node-locator.js';\nimport type { IndexManager } from '../workspace/index-manager.js';\nimport type { NameProvider } from './name-provider.js';\nimport type { URI } from '../utils/uri-utils.js';\nimport { findAssignment } from '../utils/grammar-utils.js';\nimport { isReference } from '../syntax-tree.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { isChildNode, toDocumentSegment } from '../utils/cst-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { UriUtils } from '../utils/uri-utils.js';\n\n/**\n * Language-specific service for finding references and declaration of a given `CstNode`.\n */\nexport interface References {\n\n    /**\n     * If the CstNode is a reference node the target CstNode will be returned.\n     * If the CstNode is a significant node of the CstNode this CstNode will be returned.\n     *\n     * @param sourceCstNode CstNode that points to a AstNode\n     */\n    findDeclaration(sourceCstNode: CstNode): AstNode | undefined;\n\n    /**\n     * If the CstNode is a reference node the target CstNode will be returned.\n     * If the CstNode is a significant node of the CstNode this CstNode will be returned.\n     *\n     * @param sourceCstNode CstNode that points to a AstNode\n     */\n    findDeclarationNode(sourceCstNode: CstNode): CstNode | undefined;\n\n    /**\n     * Finds all references to the target node as references (local references) or reference descriptions.\n     *\n     * @param targetNode Specified target node whose references should be returned\n     */\n    findReferences(targetNode: AstNode, options: FindReferencesOptions): Stream<ReferenceDescription>;\n}\n\nexport interface FindReferencesOptions {\n    /**\n     * @deprecated Since v1.2.0. Please use `documentUri` instead.\n     */\n    onlyLocal?: boolean;\n    /**\n     * When set, the `findReferences` method will only return references/declarations from the specified document.\n     */\n    documentUri?: URI;\n    /**\n     * Whether the returned list of references should include the declaration.\n     */\n    includeDeclaration?: boolean;\n}\n\nexport class DefaultReferences implements References {\n    protected readonly nameProvider: NameProvider;\n    protected readonly index: IndexManager;\n    protected readonly nodeLocator: AstNodeLocator;\n\n    constructor(services: LangiumCoreServices) {\n        this.nameProvider = services.references.NameProvider;\n        this.index = services.shared.workspace.IndexManager;\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n\n    findDeclaration(sourceCstNode: CstNode): AstNode | undefined {\n        if (sourceCstNode) {\n            const assignment = findAssignment(sourceCstNode);\n            const nodeElem = sourceCstNode.astNode;\n            if (assignment && nodeElem) {\n                const reference = (nodeElem as GenericAstNode)[assignment.feature];\n\n                if (isReference(reference)) {\n                    return reference.ref;\n                } else if (Array.isArray(reference)) {\n                    for (const ref of reference) {\n                        if (isReference(ref) && ref.$refNode\n                            && ref.$refNode.offset <= sourceCstNode.offset\n                            && ref.$refNode.end >= sourceCstNode.end) {\n                            return ref.ref;\n                        }\n                    }\n                }\n            }\n            if (nodeElem) {\n                const nameNode = this.nameProvider.getNameNode(nodeElem);\n                // Only return the targeted node in case the targeted cst node is the name node or part of it\n                if (nameNode && (nameNode === sourceCstNode || isChildNode(sourceCstNode, nameNode))) {\n                    return nodeElem;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    findDeclarationNode(sourceCstNode: CstNode): CstNode | undefined {\n        const astNode = this.findDeclaration(sourceCstNode);\n        if (astNode?.$cstNode) {\n            const targetNode = this.nameProvider.getNameNode(astNode);\n            return targetNode ?? astNode.$cstNode;\n        }\n        return undefined;\n    }\n\n    findReferences(targetNode: AstNode, options: FindReferencesOptions): Stream<ReferenceDescription> {\n        const refs: ReferenceDescription[] = [];\n        if (options.includeDeclaration) {\n            const ref = this.getReferenceToSelf(targetNode);\n            if (ref) {\n                refs.push(ref);\n            }\n        }\n        let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));\n        if (options.documentUri) {\n            indexReferences = indexReferences.filter(ref => UriUtils.equals(ref.sourceUri, options.documentUri));\n        }\n        refs.push(...indexReferences);\n        return stream(refs);\n    }\n\n    protected getReferenceToSelf(targetNode: AstNode): ReferenceDescription | undefined {\n        const nameNode = this.nameProvider.getNameNode(targetNode);\n        if (nameNode) {\n            const doc = getDocument(targetNode);\n            const path = this.nodeLocator.getAstNodePath(targetNode);\n            return {\n                sourceUri: doc.uri,\n                sourcePath: path,\n                targetUri: doc.uri,\n                targetPath: path,\n                segment: toDocumentSegment(nameNode),\n                local: true\n            };\n        }\n        return undefined;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5239, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5245, "column": 0}, "map": {"version":3,"file":"collections.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/collections.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { Stream } from './stream.js';\nimport { Reduction, stream } from './stream.js';\n\n/**\n * A multimap is a variation of a Map that has potentially multiple values for every key.\n */\nexport class MultiMap<K, V> {\n\n    private map = new Map<K, V[]>();\n\n    constructor()\n    constructor(elements: Array<[K, V]>)\n    constructor(elements?: Array<[K, V]>) {\n        if (elements) {\n            for (const [key, value] of elements) {\n                this.add(key, value);\n            }\n        }\n    }\n\n    /**\n     * The total number of values in the multimap.\n     */\n    get size(): number {\n        return Reduction.sum(stream(this.map.values()).map(a => a.length));\n    }\n\n    /**\n     * Clear all entries in the multimap.\n     */\n    clear(): void {\n        this.map.clear();\n    }\n\n    /**\n     * Operates differently depending on whether a `value` is given:\n     *  * With a value, this method deletes the specific key / value pair from the multimap.\n     *  * Without a value, all values associated with the given key are deleted.\n     *\n     * @returns `true` if a value existed and has been removed, or `false` if the specified\n     *     key / value does not exist.\n     */\n    delete(key: K, value?: V): boolean {\n        if (value === undefined) {\n            return this.map.delete(key);\n        } else {\n            const values = this.map.get(key);\n            if (values) {\n                const index = values.indexOf(value);\n                if (index >= 0) {\n                    if (values.length === 1) {\n                        this.map.delete(key);\n                    } else {\n                        values.splice(index, 1);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Returns an array of all values associated with the given key. If no value exists,\n     * an empty array is returned.\n     *\n     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a\n     * value and `delete` to remove a value from the multimap.\n     */\n    get(key: K): readonly V[] {\n        return this.map.get(key) ?? [];\n    }\n\n    /**\n     * Operates differently depending on whether a `value` is given:\n     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.\n     *  * Without a value, this method returns `true` if the given key is present in the multimap.\n     */\n    has(key: K, value?: V): boolean {\n        if (value === undefined) {\n            return this.map.has(key);\n        } else {\n            const values = this.map.get(key);\n            if (values) {\n                return values.indexOf(value) >= 0;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Add the given key / value pair to the multimap.\n     */\n    add(key: K, value: V): this {\n        if (this.map.has(key)) {\n            this.map.get(key)!.push(value);\n        } else {\n            this.map.set(key, [value]);\n        }\n        return this;\n    }\n\n    /**\n     * Add the given set of key / value pairs to the multimap.\n     */\n    addAll(key: K, values: Iterable<V>): this {\n        if (this.map.has(key)) {\n            this.map.get(key)!.push(...values);\n        } else {\n            this.map.set(key, Array.from(values));\n        }\n        return this;\n    }\n\n    /**\n     * Invokes the given callback function for every key / value pair in the multimap.\n     */\n    forEach(callbackfn: (value: V, key: K, map: this) => void): void {\n        this.map.forEach((array, key) =>\n            array.forEach(value => callbackfn(value, key, this))\n        );\n    }\n\n    /**\n     * Returns an iterator of key, value pairs for every entry in the map.\n     */\n    [Symbol.iterator](): Iterator<[K, V]> {\n        return this.entries().iterator();\n    }\n\n    /**\n     * Returns a stream of key, value pairs for every entry in the map.\n     */\n    entries(): Stream<[K, V]> {\n        return stream(this.map.entries())\n            .flatMap(([key, array]) => array.map(value => [key, value] as [K, V]));\n    }\n\n    /**\n     * Returns a stream of keys in the map.\n     */\n    keys(): Stream<K> {\n        return stream(this.map.keys());\n    }\n\n    /**\n     * Returns a stream of values in the map.\n     */\n    values(): Stream<V> {\n        return stream(this.map.values()).flat();\n    }\n\n    /**\n     * Returns a stream of key, value set pairs for every key in the map.\n     */\n    entriesGroupedByKey(): Stream<[K, V[]]> {\n        return stream(this.map.entries());\n    }\n\n}\n\nexport class BiMap<K, V> {\n\n    private map = new Map<K, V>();\n    private inverse = new Map<V, K>();\n\n    get size(): number {\n        return this.map.size;\n    }\n\n    constructor()\n    constructor(elements: Array<[K, V]>)\n    constructor(elements?: Array<[K, V]>) {\n        if (elements) {\n            for (const [key, value] of elements) {\n                this.set(key, value);\n            }\n        }\n    }\n\n    clear(): void {\n        this.map.clear();\n        this.inverse.clear();\n    }\n\n    set(key: K, value: V): this {\n        this.map.set(key, value);\n        this.inverse.set(value, key);\n        return this;\n    }\n\n    get(key: K): V | undefined {\n        return this.map.get(key);\n    }\n\n    getKey(value: V): K | undefined {\n        return this.inverse.get(value);\n    }\n\n    delete(key: K): boolean {\n        const value = this.map.get(key);\n        if (value !== undefined) {\n            this.map.delete(key);\n            this.inverse.delete(value);\n            return true;\n        }\n        return false;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5419, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5425, "column": 0}, "map": {"version":3,"file":"scope-computation.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/references/scope-computation.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { LangiumCoreServices } from '../services.js';\nimport type { AstNode, AstNodeDescription } from '../syntax-tree.js';\nimport type { AstNodeDescriptionProvider } from '../workspace/ast-descriptions.js';\nimport type { LangiumDocument, PrecomputedScopes } from '../workspace/documents.js';\nimport type { NameProvider } from './name-provider.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { streamAllContents, streamContents } from '../utils/ast-utils.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\n\n/**\n * Language-specific service for precomputing global and local scopes. The service methods are executed\n * as the first and second phase in the `DocumentBuilder`.\n */\nexport interface ScopeComputation {\n\n    /**\n     * Creates descriptions of all AST nodes that shall be exported into the _global_ scope from the given\n     * document. These descriptions are gathered by the `IndexManager` and stored in the global index so\n     * they can be referenced from other documents.\n     *\n     * _Note:_ You should not resolve any cross-references in this service method. Cross-reference resolution\n     * depends on the scope computation phase to be completed (`computeScope` method), which runs after the\n     * initial indexing where this method is used.\n     *\n     * @param document The document from which to gather exported AST nodes.\n     * @param cancelToken Indicates when to cancel the current operation.\n     * @throws `OperationCanceled` if a user action occurs during execution\n     */\n    computeExports(document: LangiumDocument, cancelToken?: CancellationToken): Promise<AstNodeDescription[]>;\n\n    /**\n     * Precomputes the _local_ scopes for a document, which are necessary for the default way of\n     * resolving references to symbols in the same document. The result is a multimap assigning a\n     * set of AST node descriptions to every level of the AST. These data are used by the `ScopeProvider`\n     * service to determine which target nodes are visible in the context of a specific cross-reference.\n     *\n     * _Note:_ You should not resolve any cross-references in this service method. Cross-reference\n     * resolution depends on the scope computation phase to be completed.\n     *\n     * @param document The document in which to compute scopes.\n     * @param cancelToken Indicates when to cancel the current operation.\n     * @throws `OperationCanceled` if a user action occurs during execution\n     */\n    computeLocalScopes(document: LangiumDocument, cancelToken?: CancellationToken): Promise<PrecomputedScopes>;\n\n}\n\n/**\n * The default scope computation creates and collectes descriptions of the AST nodes to be exported into the\n * _global_ scope from the given document. By default those are the document's root AST node and its directly\n * contained child nodes.\n *\n * Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them\n * in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,\n * target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)\n * are visible. Elements being nested inside lower levels (children, children of siblings and parents' siblings)\n * are _invisible_ by default, but that can be changed by customizing this service.\n */\nexport class DefaultScopeComputation implements ScopeComputation {\n\n    protected readonly nameProvider: NameProvider;\n    protected readonly descriptions: AstNodeDescriptionProvider;\n\n    constructor(services: LangiumCoreServices) {\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n    }\n\n    async computeExports(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<AstNodeDescription[]> {\n        return this.computeExportsForNode(document.parseResult.value, document, undefined, cancelToken);\n    }\n\n    /**\n     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.\n     * The list of children to be considered is determined by the function parameter {@link children}.\n     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.\n     *\n     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.\n     * @param document The document containing the AST node to be exported.\n     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.\n     * @param cancelToken Indicates when to cancel the current operation.\n     * @throws `OperationCanceled` if a user action occurs during execution.\n     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.\n     */\n    async computeExportsForNode(parentNode: AstNode, document: LangiumDocument<AstNode>, children: (root: AstNode) => Iterable<AstNode> = streamContents, cancelToken: CancellationToken = CancellationToken.None): Promise<AstNodeDescription[]> {\n        const exports: AstNodeDescription[] = [];\n\n        this.exportNode(parentNode, exports, document);\n        for (const node of children(parentNode)) {\n            await interruptAndCheck(cancelToken);\n            this.exportNode(node, exports, document);\n        }\n        return exports;\n    }\n\n    /**\n     * Add a single node to the list of exports if it has a name. Override this method to change how\n     * symbols are exported, e.g. by modifying their exported name.\n     */\n    protected exportNode(node: AstNode, exports: AstNodeDescription[], document: LangiumDocument): void {\n        const name = this.nameProvider.getName(node);\n        if (name) {\n            exports.push(this.descriptions.createDescription(node, name, document));\n        }\n    }\n\n    async computeLocalScopes(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<PrecomputedScopes> {\n        const rootNode = document.parseResult.value;\n        const scopes = new MultiMap<AstNode, AstNodeDescription>();\n        // Here we navigate the full AST - local scopes shall be available in the whole document\n        for (const node of streamAllContents(rootNode)) {\n            await interruptAndCheck(cancelToken);\n            this.processNode(node, document, scopes);\n        }\n        return scopes;\n    }\n\n    /**\n     * Process a single node during scopes computation. The default implementation makes the node visible\n     * in the subtree of its container (if the node has a name). Override this method to change this,\n     * e.g. by increasing the visibility to a higher level in the AST.\n     */\n    protected processNode(node: AstNode, document: LangiumDocument, scopes: PrecomputedScopes): void {\n        const container = node.$container;\n        if (container) {\n            const name = this.nameProvider.getName(node);\n            if (name) {\n                scopes.add(container, this.descriptions.createDescription(node, name, document));\n            }\n        }\n    }\n\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;AAOhF,OAAO,EAAE,iBAAiB,EAAE,MAAM,0BAA0B,CAAC;AAC7D,OAAO,EAAE,iBAAiB,EAAE,cAAc,EAAE,MAAM,uBAAuB,CAAC;AAC1E,OAAO,EAAE,QAAQ,EAAE,MAAM,yBAAyB,CAAC;AACnD,OAAO,EAAE,iBAAiB,EAAE,MAAM,2BAA2B,CAAC;;;;;;AAmDxD,MAAO,uBAAuB;IAKhC,YAAY,QAA6B,CAAA;QACrC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,UAAU,CAAC,YAAY,CAAC;QACrD,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,SAAS,CAAC,0BAA0B,CAAC;IACtE,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,QAAyB,EAAE,WAAW,iMAAG,oBAAiB,CAAC,IAAI,EAAA;QAChF,OAAO,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,WAAW,CAAC,KAAK,EAAE,QAAQ,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC;IACpG,CAAC;IAED;;;;;;;;;;;OAWG,CACH,KAAK,CAAC,qBAAqB,CAAC,UAAmB,EAAE,QAAkC,EAAE,WAAiD,oMAAc,EAAE,4MAAiC,oBAAiB,CAAC,IAAI,EAAA;QACzM,MAAM,OAAO,GAAyB,EAAE,CAAC;QAEzC,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;QAC/C,KAAK,MAAM,IAAI,IAAI,QAAQ,CAAC,UAAU,CAAC,CAAE;YACrC,iMAAM,oBAAA,AAAiB,EAAC,WAAW,CAAC,CAAC;YACrC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;SAC5C;QACD,OAAO,OAAO,CAAC;IACnB,CAAC;IAED;;;OAGG,CACO,UAAU,CAAC,IAAa,EAAE,OAA6B,EAAE,QAAyB,EAAA;QACxF,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAC7C,IAAI,IAAI,EAAE;YACN,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;SAC3E;IACL,CAAC;IAED,KAAK,CAAC,kBAAkB,CAAC,QAAyB,EAAE,WAAW,iMAAG,oBAAiB,CAAC,IAAI,EAAA;QACpF,MAAM,QAAQ,GAAG,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC;QAC5C,MAAM,MAAM,GAAG,qLAAI,YAAQ,EAA+B,CAAC;QAC3D,wFAAwF;QACxF,KAAK,MAAM,IAAI,2LAAI,oBAAA,AAAiB,EAAC,QAAQ,CAAC,CAAE;YAC5C,iMAAM,oBAAA,AAAiB,EAAC,WAAW,CAAC,CAAC;YACrC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;SAC5C;QACD,OAAO,MAAM,CAAC;IAClB,CAAC;IAED;;;;OAIG,CACO,WAAW,CAAC,IAAa,EAAE,QAAyB,EAAE,MAAyB,EAAA;QACrF,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;QAClC,IAAI,SAAS,EAAE;YACX,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC7C,IAAI,IAAI,EAAE;gBACN,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;aACpF;SACJ;IACL,CAAC;CAEJ","ignoreList":[0]}},
    {"offset": {"line": 5502, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5508, "column": 0}, "map": {"version":3,"file":"scope.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/references/scope.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { AstNodeDescription } from '../syntax-tree.js';\nimport type { Stream } from '../utils/stream.js';\nimport { EMPTY_STREAM, stream } from '../utils/stream.js';\n\n/**\n * A scope describes what target elements are visible from a specific cross-reference context.\n */\nexport interface Scope {\n\n    /**\n     * Find a target element matching the given name. If no element is found, `undefined` is returned.\n     * If multiple matching elements are present, the selection of the returned element should be done\n     * according to the semantics of your language. Usually it is the element that is most closely defined.\n     *\n     * @param name Name of the cross-reference target as it appears in the source text.\n     */\n    getElement(name: string): AstNodeDescription | undefined;\n\n    /**\n     * Create a stream of all elements in the scope. This is used to compute completion proposals to be\n     * shown in the editor.\n     */\n    getAllElements(): Stream<AstNodeDescription>;\n\n}\n\nexport interface ScopeOptions {\n    caseInsensitive?: boolean;\n}\n\n/**\n * The default scope implementation is based on a `Stream`. It has an optional _outer scope_ describing\n * the next level of elements, which are queried when a target element is not found in the stream provided\n * to this scope.\n */\nexport class StreamScope implements Scope {\n    readonly elements: Stream<AstNodeDescription>;\n    readonly outerScope?: Scope;\n    readonly caseInsensitive: boolean;\n\n    constructor(elements: Stream<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions) {\n        this.elements = elements;\n        this.outerScope = outerScope;\n        this.caseInsensitive = options?.caseInsensitive ?? false;\n    }\n\n    getAllElements(): Stream<AstNodeDescription> {\n        if (this.outerScope) {\n            return this.elements.concat(this.outerScope.getAllElements());\n        } else {\n            return this.elements;\n        }\n    }\n\n    getElement(name: string): AstNodeDescription | undefined {\n        const local = this.caseInsensitive\n            ? this.elements.find(e => e.name.toLowerCase() === name.toLowerCase())\n            : this.elements.find(e => e.name === name);\n        if (local) {\n            return local;\n        }\n        if (this.outerScope) {\n            return this.outerScope.getElement(name);\n        }\n        return undefined;\n    }\n}\n\nexport class MapScope implements Scope {\n    readonly elements: Map<string, AstNodeDescription>;\n    readonly outerScope?: Scope;\n    readonly caseInsensitive: boolean;\n\n    constructor(elements: Iterable<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions) {\n        this.elements = new Map();\n        this.caseInsensitive = options?.caseInsensitive ?? false;\n        for (const element of elements) {\n            const name = this.caseInsensitive\n                ? element.name.toLowerCase()\n                : element.name;\n            this.elements.set(name, element);\n        }\n        this.outerScope = outerScope;\n    }\n\n    getElement(name: string): AstNodeDescription | undefined {\n        const localName = this.caseInsensitive ? name.toLowerCase() : name;\n        const local = this.elements.get(localName);\n        if (local) {\n            return local;\n        }\n        if (this.outerScope) {\n            return this.outerScope.getElement(name);\n        }\n        return undefined;\n    }\n\n    getAllElements(): Stream<AstNodeDescription> {\n        let elementStream = stream(this.elements.values());\n        if (this.outerScope) {\n            elementStream = elementStream.concat(this.outerScope.getAllElements());\n        }\n        return elementStream;\n    }\n\n}\n\nexport const EMPTY_SCOPE: Scope = {\n    getElement(): undefined {\n        return undefined;\n    },\n    getAllElements(): Stream<AstNodeDescription> {\n        return EMPTY_STREAM;\n    }\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5582, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5588, "column": 0}, "map": {"version":3,"file":"caching.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/caching.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { Disposable } from './disposable.js';\nimport type { URI } from './uri-utils.js';\nimport type { LangiumSharedCoreServices } from '../services.js';\n\nexport abstract class DisposableCache implements Disposable {\n\n    protected toDispose: Disposable[] = [];\n    protected isDisposed = false;\n\n    onDispose(disposable: Disposable): void {\n        this.toDispose.push(disposable);\n    }\n\n    dispose(): void {\n        this.throwIfDisposed();\n        this.clear();\n        this.isDisposed = true;\n        this.toDispose.forEach(disposable => disposable.dispose());\n    }\n\n    protected throwIfDisposed(): void {\n        if (this.isDisposed) {\n            throw new Error('This cache has already been disposed');\n        }\n    }\n\n    abstract clear(): void;\n}\n\nexport class SimpleCache<K, V> extends DisposableCache {\n    protected readonly cache = new Map<K, V>();\n\n    has(key: K): boolean {\n        this.throwIfDisposed();\n        return this.cache.has(key);\n    }\n\n    set(key: K, value: V): void {\n        this.throwIfDisposed();\n        this.cache.set(key, value);\n    }\n\n    get(key: K): V | undefined;\n    get(key: K, provider: () => V): V;\n    get(key: K, provider?: () => V): V | undefined {\n        this.throwIfDisposed();\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        } else if (provider) {\n            const value = provider();\n            this.cache.set(key, value);\n            return value;\n        } else {\n            return undefined;\n        }\n    }\n\n    delete(key: K): boolean {\n        this.throwIfDisposed();\n        return this.cache.delete(key);\n    }\n\n    clear(): void {\n        this.throwIfDisposed();\n        this.cache.clear();\n    }\n}\n\nexport class ContextCache<Context, Key, Value, ContextKey = Context> extends DisposableCache {\n\n    private readonly cache = new Map<ContextKey | Context, Map<Key, Value>>();\n    private readonly converter: (input: Context) => ContextKey | Context;\n\n    constructor(converter?: (input: Context) => ContextKey) {\n        super();\n        this.converter = converter ?? (value => value);\n    }\n\n    has(contextKey: Context, key: Key): boolean {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).has(key);\n    }\n\n    set(contextKey: Context, key: Key, value: Value): void {\n        this.throwIfDisposed();\n        this.cacheForContext(contextKey).set(key, value);\n    }\n\n    get(contextKey: Context, key: Key): Value | undefined;\n    get(contextKey: Context, key: Key, provider: () => Value): Value;\n    get(contextKey: Context, key: Key, provider?: () => Value): Value | undefined {\n        this.throwIfDisposed();\n        const contextCache = this.cacheForContext(contextKey);\n        if (contextCache.has(key)) {\n            return contextCache.get(key);\n        } else if (provider) {\n            const value = provider();\n            contextCache.set(key, value);\n            return value;\n        } else {\n            return undefined;\n        }\n    }\n\n    delete(contextKey: Context, key: Key): boolean {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).delete(key);\n    }\n\n    clear(): void;\n    clear(contextKey: Context): void;\n    clear(contextKey?: Context): void {\n        this.throwIfDisposed();\n        if (contextKey) {\n            const mapKey = this.converter(contextKey);\n            this.cache.delete(mapKey);\n        } else {\n            this.cache.clear();\n        }\n    }\n\n    protected cacheForContext(contextKey: Context): Map<Key, Value> {\n        const mapKey = this.converter(contextKey);\n        let documentCache = this.cache.get(mapKey);\n        if (!documentCache) {\n            documentCache = new Map();\n            this.cache.set(mapKey, documentCache);\n        }\n        return documentCache;\n    }\n}\n\n/**\n * Every key/value pair in this cache is scoped to a document.\n * If this document is changed or deleted, all associated key/value pairs are deleted.\n */\nexport class DocumentCache<K, V> extends ContextCache<URI | string, K, V, string> {\n    constructor(sharedServices: LangiumSharedCoreServices) {\n        super(uri => uri.toString());\n        this.onDispose(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted) => {\n            const allUris = changed.concat(deleted);\n            for (const uri of allUris) {\n                this.clear(uri);\n            }\n        }));\n    }\n}\n\n/**\n * Every key/value pair in this cache is scoped to the whole workspace.\n * If any document in the workspace changes, the whole cache is evicted.\n */\nexport class WorkspaceCache<K, V> extends SimpleCache<K, V> {\n    constructor(sharedServices: LangiumSharedCoreServices) {\n        super();\n        this.onDispose(sharedServices.workspace.DocumentBuilder.onUpdate(() => {\n            this.clear();\n        }));\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5722, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5728, "column": 0}, "map": {"version":3,"file":"scope-provider.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/references/scope-provider.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { LangiumCoreServices } from '../services.js';\nimport type { AstNode, AstNodeDescription, AstReflection, ReferenceInfo } from '../syntax-tree.js';\nimport type { Stream } from '../utils/stream.js';\nimport type { AstNodeDescriptionProvider } from '../workspace/ast-descriptions.js';\nimport type { IndexManager } from '../workspace/index-manager.js';\nimport type { NameProvider } from './name-provider.js';\nimport type { Scope, ScopeOptions} from './scope.js';\nimport { MapScope, StreamScope } from './scope.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { WorkspaceCache } from '../utils/caching.js';\n\n/**\n * Language-specific service for determining the scope of target elements visible in a specific cross-reference context.\n */\nexport interface ScopeProvider {\n\n    /**\n     * Return a scope describing what elements are visible for the given AST node and cross-reference\n     * identifier.\n     *\n     * @param context Information about the reference for which a scope is requested.\n     */\n    getScope(context: ReferenceInfo): Scope;\n\n}\n\nexport class DefaultScopeProvider implements ScopeProvider {\n\n    protected readonly reflection: AstReflection;\n    protected readonly nameProvider: NameProvider;\n    protected readonly descriptions: AstNodeDescriptionProvider;\n    protected readonly indexManager: IndexManager;\n\n    protected readonly globalScopeCache: WorkspaceCache<string, Scope>;\n\n    constructor(services: LangiumCoreServices) {\n        this.reflection = services.shared.AstReflection;\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.globalScopeCache = new WorkspaceCache<string, Scope>(services.shared);\n    }\n\n    getScope(context: ReferenceInfo): Scope {\n        const scopes: Array<Stream<AstNodeDescription>> = [];\n        const referenceType = this.reflection.getReferenceType(context);\n\n        const precomputed = getDocument(context.container).precomputedScopes;\n        if (precomputed) {\n            let currentNode: AstNode | undefined = context.container;\n            do {\n                const allDescriptions = precomputed.get(currentNode);\n                if (allDescriptions.length > 0) {\n                    scopes.push(stream(allDescriptions).filter(\n                        desc => this.reflection.isSubtype(desc.type, referenceType)));\n                }\n                currentNode = currentNode.$container;\n            } while (currentNode);\n        }\n\n        let result: Scope = this.getGlobalScope(referenceType, context);\n        for (let i = scopes.length - 1; i >= 0; i--) {\n            result = this.createScope(scopes[i], result);\n        }\n        return result;\n    }\n\n    /**\n     * Create a scope for the given collection of AST node descriptions.\n     */\n    protected createScope(elements: Iterable<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions): Scope {\n        return new StreamScope(stream(elements), outerScope, options);\n    }\n\n    /**\n     * Create a scope for the given collection of AST nodes, which need to be transformed into respective\n     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\n     */\n    protected createScopeForNodes(elements: Iterable<AstNode>, outerScope?: Scope, options?: ScopeOptions): Scope {\n        const s = stream(elements).map(e => {\n            const name = this.nameProvider.getName(e);\n            if (name) {\n                return this.descriptions.createDescription(e, name);\n            }\n            return undefined;\n        }).nonNullable();\n        return new StreamScope(s, outerScope, options);\n    }\n\n    /**\n     * Create a global scope filtered for the given reference type.\n     */\n    protected getGlobalScope(referenceType: string, _context: ReferenceInfo): Scope {\n        return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));\n    }\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5795, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5801, "column": 0}, "map": {"version":3,"file":"json-serializer.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/serializer/json-serializer.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport { URI } from 'vscode-uri';\nimport type { CommentProvider } from '../documentation/comment-provider.js';\nimport type { NameProvider } from '../references/name-provider.js';\nimport type { LangiumCoreServices } from '../services.js';\nimport type { AstNode, CstNode, GenericAstNode, Mutable, Reference } from '../syntax-tree.js';\nimport { isAstNode, isReference } from '../syntax-tree.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { findNodesForProperty } from '../utils/grammar-utils.js';\nimport type { AstNodeLocator } from '../workspace/ast-node-locator.js';\nimport type { DocumentSegment, LangiumDocument, LangiumDocuments } from '../workspace/documents.js';\n\nexport interface JsonSerializeOptions {\n    /** The space parameter for `JSON.stringify`, controlling whether and how to pretty-print the output. */\n    space?: string | number;\n    /** Whether to include the `$refText` property for references (the name used to identify the target node). */\n    refText?: boolean;\n    /** Whether to include the `$sourceText` property, which holds the full source text from which an AST node was parsed. */\n    sourceText?: boolean;\n    /** Whether to include the `$textRegion` property, which holds information to trace AST node properties to their respective source text regions. */\n    textRegions?: boolean;\n    /** Whether to include the `$comment` property, which holds comments according to the CommentProvider service. */\n    comments?: boolean;\n    /** The replacer parameter for `JSON.stringify`; the default replacer given as parameter should be used to apply basic replacements. */\n    replacer?: (key: string, value: unknown, defaultReplacer: (key: string, value: unknown) => unknown) => unknown\n    /** Used to convert and serialize URIs when the target of a cross-reference is in a different document. */\n    uriConverter?: (uri: URI, reference: Reference) => string\n}\n\nexport interface JsonDeserializeOptions {\n    /** Used to parse and convert URIs when the target of a cross-reference is in a different document. */\n    uriConverter?: (uri: string) => URI\n}\n\n/**\n * {@link AstNode}s that may carry information on their definition area within the DSL text.\n */\nexport interface AstNodeWithTextRegion extends AstNode {\n    $sourceText?: string;\n    $textRegion?: AstNodeRegionWithAssignments;\n}\n\n/**\n * {@link AstNode}s that may carry a semantically relevant comment.\n */\nexport interface AstNodeWithComment extends AstNode {\n    $comment?: string;\n}\n\nexport function isAstNodeWithComment(node: AstNode): node is AstNodeWithComment {\n    return typeof (node as AstNodeWithComment).$comment === 'string';\n}\n\n/**\n * A {@DocumentSegment} representing the definition area of an AstNode within the DSL text.\n * Usually contains text region information on all assigned property values of the AstNode,\n * and may contain the defining file's URI as string.\n */\nexport interface AstNodeRegionWithAssignments extends DocumentSegment {\n    /**\n     * A record containing an entry for each assigned property of the AstNode.\n     * The key is equal to the property name and the value is an array of the property values'\n     * text regions, regardless of whether the property is a single value or list property.\n     */\n    assignments?: Record<string, DocumentSegment[]>;\n    /**\n     * The AstNode defining file's URI as string\n     */\n    documentURI?: string;\n}\n\n/**\n * Utility service for transforming an `AstNode` into a JSON string and vice versa.\n */\nexport interface JsonSerializer {\n    /**\n     * Serialize an `AstNode` into a JSON `string`.\n     * @param node The `AstNode` to be serialized.\n     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n     */\n    serialize(node: AstNode, options?: JsonSerializeOptions): string;\n    /**\n     * Deserialize (parse) a JSON `string` into an `AstNode`.\n     */\n    deserialize<T extends AstNode = AstNode>(content: string, options?: JsonDeserializeOptions): T;\n}\n\n/**\n * A cross-reference in the serialized JSON representation of an AstNode.\n */\ninterface IntermediateReference {\n    /** URI pointing to the target element. This is either `#${path}` if the target is in the same document, or `${documentURI}#${path}` otherwise. */\n    $ref?: string\n    /** The actual text used to look up the reference target in the surrounding scope. */\n    $refText?: string\n    /** If any problem occurred while resolving the reference, it is described by this property. */\n    $error?: string\n}\n\nfunction isIntermediateReference(obj: unknown): obj is IntermediateReference {\n    return typeof obj === 'object' && !!obj && ('$ref' in obj || '$error' in obj);\n}\n\nexport class DefaultJsonSerializer implements JsonSerializer {\n\n    /** The set of AstNode properties to be ignored by the serializer. */\n    ignoreProperties = new Set(['$container', '$containerProperty', '$containerIndex', '$document', '$cstNode']);\n\n    /** The document that is currently processed by the serializer; this is used by the replacer function.  */\n    protected currentDocument: LangiumDocument | undefined;\n\n    protected readonly langiumDocuments: LangiumDocuments;\n    protected readonly astNodeLocator: AstNodeLocator;\n    protected readonly nameProvider: NameProvider;\n    protected readonly commentProvider: CommentProvider;\n\n    constructor(services: LangiumCoreServices) {\n        this.langiumDocuments = services.shared.workspace.LangiumDocuments;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n\n    serialize(node: AstNode, options: JsonSerializeOptions = {}): string {\n        const specificReplacer = options?.replacer;\n        const defaultReplacer = (key: string, value: unknown) => this.replacer(key, value, options);\n        const replacer = specificReplacer ? (key: string, value: unknown) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;\n\n        try {\n            this.currentDocument = getDocument(node);\n            return JSON.stringify(node, replacer, options?.space);\n        } finally {\n            this.currentDocument = undefined;\n        }\n    }\n\n    deserialize<T extends AstNode = AstNode>(content: string, options: JsonDeserializeOptions = {}): T {\n        const root = JSON.parse(content);\n        this.linkNode(root, root, options);\n        return root;\n    }\n\n    protected replacer(key: string, value: unknown, { refText, sourceText, textRegions, comments, uriConverter }: JsonSerializeOptions): unknown {\n        if (this.ignoreProperties.has(key)) {\n            return undefined;\n        } else if (isReference(value)) {\n            const refValue = value.ref;\n            const $refText = refText ? value.$refText : undefined;\n            if (refValue) {\n                const targetDocument = getDocument(refValue);\n                let targetUri = '';\n                if (this.currentDocument && this.currentDocument !== targetDocument) {\n                    if (uriConverter) {\n                        targetUri = uriConverter(targetDocument.uri, value);\n                    } else {\n                        targetUri = targetDocument.uri.toString();\n                    }\n                }\n                const targetPath = this.astNodeLocator.getAstNodePath(refValue);\n                return {\n                    $ref: `${targetUri}#${targetPath}`,\n                    $refText\n                } satisfies IntermediateReference;\n            } else {\n                return {\n                    $error: value.error?.message ?? 'Could not resolve reference',\n                    $refText\n                } satisfies IntermediateReference;\n            }\n        } else if (isAstNode(value)) {\n            let astNode: AstNodeWithTextRegion | undefined = undefined;\n            if (textRegions) {\n                astNode = this.addAstNodeRegionWithAssignmentsTo({ ...value });\n                if ((!key || value.$document) && astNode?.$textRegion) {\n                    // The document URI is added to the root node of the resulting JSON tree\n                    astNode.$textRegion.documentURI = this.currentDocument?.uri.toString();\n                }\n            }\n            if (sourceText && !key) {\n                astNode ??= { ...value };\n                astNode.$sourceText = value.$cstNode?.text;\n            }\n            if (comments) {\n                astNode ??= { ...value };\n                const comment = this.commentProvider.getComment(value);\n                if (comment) {\n                    (astNode as AstNodeWithComment).$comment = comment.replace(/\\r/g, '');\n                }\n            }\n            return astNode ?? value;\n        } else {\n            return value;\n        }\n    }\n\n    protected addAstNodeRegionWithAssignmentsTo(node: AstNodeWithTextRegion) {\n        const createDocumentSegment: (cstNode: CstNode) => AstNodeRegionWithAssignments = cstNode => <DocumentSegment>{\n            offset: cstNode.offset,\n            end: cstNode.end,\n            length: cstNode.length,\n            range: cstNode.range,\n        };\n\n        if (node.$cstNode) {\n            const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);\n            const assignments: Record<string, DocumentSegment[]> = textRegion.assignments = {};\n\n            Object.keys(node).filter(key => !key.startsWith('$')).forEach(key => {\n                const propertyAssignments = findNodesForProperty(node.$cstNode, key).map(createDocumentSegment);\n                if (propertyAssignments.length !== 0) {\n                    assignments[key] = propertyAssignments;\n                }\n            });\n\n            return node;\n        }\n        return undefined;\n    }\n\n    protected linkNode(node: GenericAstNode, root: AstNode, options: JsonDeserializeOptions, container?: AstNode, containerProperty?: string, containerIndex?: number) {\n        for (const [propertyName, item] of Object.entries(node)) {\n            if (Array.isArray(item)) {\n                for (let index = 0; index < item.length; index++) {\n                    const element = item[index];\n                    if (isIntermediateReference(element)) {\n                        item[index] = this.reviveReference(node, propertyName, root, element, options);\n                    } else if (isAstNode(element)) {\n                        this.linkNode(element as GenericAstNode, root, options, node, propertyName, index);\n                    }\n                }\n            } else if (isIntermediateReference(item)) {\n                node[propertyName] = this.reviveReference(node, propertyName, root, item, options);\n            } else if (isAstNode(item)) {\n                this.linkNode(item as GenericAstNode, root, options, node, propertyName);\n            }\n        }\n        const mutable = node as Mutable<AstNode>;\n        mutable.$container = container;\n        mutable.$containerProperty = containerProperty;\n        mutable.$containerIndex = containerIndex;\n    }\n\n    protected reviveReference(container: AstNode, property: string, root: AstNode, reference: IntermediateReference, options: JsonDeserializeOptions): Reference | undefined {\n        let refText = reference.$refText;\n        let error = reference.$error;\n        if (reference.$ref) {\n            const ref = this.getRefNode(root, reference.$ref, options.uriConverter);\n            if (isAstNode(ref)) {\n                if (!refText) {\n                    refText = this.nameProvider.getName(ref);\n                }\n                return {\n                    $refText: refText ?? '',\n                    ref\n                };\n            } else {\n                error = ref;\n            }\n        }\n        if (error) {\n            const ref: Mutable<Reference> = {\n                $refText: refText ?? ''\n            };\n            ref.error = {\n                container,\n                property,\n                message: error,\n                reference: ref\n            };\n            return ref;\n        } else {\n            return undefined;\n        }\n    }\n\n    protected getRefNode(root: AstNode, uri: string, uriConverter?: (uri: string) => URI): AstNode | string {\n        try {\n            const fragmentIndex = uri.indexOf('#');\n            if (fragmentIndex === 0) {\n                const node = this.astNodeLocator.getAstNode(root, uri.substring(1));\n                if (!node) {\n                    return 'Could not resolve path: ' + uri;\n                }\n                return node;\n            }\n            if (fragmentIndex < 0) {\n                const documentUri = uriConverter ? uriConverter(uri) : URI.parse(uri);\n                const document = this.langiumDocuments.getDocument(documentUri);\n                if (!document) {\n                    return 'Could not find document for URI: ' + uri;\n                }\n                return document.parseResult.value;\n            }\n            const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : URI.parse(uri.substring(0, fragmentIndex));\n            const document = this.langiumDocuments.getDocument(documentUri);\n            if (!document) {\n                return 'Could not find document for URI: ' + uri;\n            }\n            if (fragmentIndex === uri.length - 1) {\n                return document.parseResult.value;\n            }\n            const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));\n            if (!node) {\n                return 'Could not resolve URI: ' + uri;\n            }\n            return node;\n        } catch (err) {\n            return String(err);\n        }\n    }\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6016, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6022, "column": 0}, "map": {"version":3,"file":"service-registry.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/service-registry.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { LangiumCoreServices } from './services.js';\nimport { UriUtils, type URI } from './utils/uri-utils.js';\n\n/**\n * The service registry provides access to the language-specific {@link LangiumCoreServices} optionally including LSP-related services.\n * These are resolved via the URI of a text document.\n */\nexport interface ServiceRegistry {\n\n    /**\n     * Register a language via its injected services.\n     */\n    register(language: LangiumCoreServices): void;\n\n    /**\n     * Retrieve the language-specific services for the given URI. In case only one language is\n     * registered, it may be used regardless of the URI format.\n     */\n    getServices(uri: URI): LangiumCoreServices;\n\n    /**\n     * The full set of registered language services.\n     */\n    readonly all: readonly LangiumCoreServices[];\n}\n\n/**\n * Generic registry for Langium services, but capable of being used with extending service sets as well (such as the lsp-complete LangiumCoreServices set)\n */\nexport class DefaultServiceRegistry implements ServiceRegistry {\n\n    protected singleton?: LangiumCoreServices;\n    protected map?: Record<string, LangiumCoreServices>;\n\n    register(language: LangiumCoreServices): void {\n        if (!this.singleton && !this.map) {\n            // This is the first language to be registered; store it as singleton.\n            this.singleton = language;\n            return;\n        }\n        if (!this.map) {\n            this.map = {};\n            if (this.singleton) {\n                // Move the previous singleton instance to the new map.\n                for (const ext of this.singleton.LanguageMetaData.fileExtensions) {\n                    this.map[ext] = this.singleton;\n                }\n                this.singleton = undefined;\n            }\n        }\n        // Store the language services in the map.\n        for (const ext of language.LanguageMetaData.fileExtensions) {\n            if (this.map[ext] !== undefined && this.map[ext] !== language) {\n                console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${language.LanguageMetaData.languageId}'.`);\n            }\n            this.map[ext] = language;\n        }\n    }\n\n    getServices(uri: URI): LangiumCoreServices {\n        if (this.singleton !== undefined) {\n            return this.singleton;\n        }\n        if (this.map === undefined) {\n            throw new Error('The service registry is empty. Use `register` to register the services of a language.');\n        }\n        const ext = UriUtils.extname(uri);\n        const services = this.map[ext];\n        if (!services) {\n            throw new Error(`The service registry contains no services for the extension '${ext}'.`);\n        }\n        return services;\n    }\n\n    get all(): readonly LangiumCoreServices[] {\n        if (this.singleton !== undefined) {\n            return [this.singleton];\n        }\n        if (this.map !== undefined) {\n            return Object.values(this.map);\n        }\n        return [];\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AAGhF,OAAO,EAAE,QAAQ,EAAY,MAAM,sBAAsB,CAAC;;AA4BpD,MAAO,sBAAsB;IAK/B,QAAQ,CAAC,QAA6B,EAAA;QAClC,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE;YAC9B,sEAAsE;YACtE,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;YAC1B,OAAO;SACV;QACD,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE;YACX,IAAI,CAAC,GAAG,GAAG,CAAA,CAAE,CAAC;YACd,IAAI,IAAI,CAAC,SAAS,EAAE;gBAChB,uDAAuD;gBACvD,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,cAAc,CAAE;oBAC9D,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;iBAClC;gBACD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;aAC9B;SACJ;QACD,0CAA0C;QAC1C,KAAK,MAAM,GAAG,IAAI,QAAQ,CAAC,gBAAgB,CAAC,cAAc,CAAE;YACxD,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,SAAS,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,QAAQ,EAAE;gBAC3D,OAAO,CAAC,IAAI,CAAC,CAAA,mBAAA,EAAsB,GAAG,CAAA,uDAAA,EAA0D,QAAQ,CAAC,gBAAgB,CAAC,UAAU,CAAA,EAAA,CAAI,CAAC,CAAC;aAC7I;YACD,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC;SAC5B;IACL,CAAC;IAED,WAAW,CAAC,GAAQ,EAAA;QAChB,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE;YAC9B,OAAO,IAAI,CAAC,SAAS,CAAC;SACzB;QACD,IAAI,IAAI,CAAC,GAAG,KAAK,SAAS,EAAE;YACxB,MAAM,IAAI,KAAK,CAAC,uFAAuF,CAAC,CAAC;SAC5G;QACD,MAAM,GAAG,sMAAG,WAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAClC,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC/B,IAAI,CAAC,QAAQ,EAAE;YACX,MAAM,IAAI,KAAK,CAAC,CAAA,6DAAA,EAAgE,GAAG,CAAA,EAAA,CAAI,CAAC,CAAC;SAC5F;QACD,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED,IAAI,GAAG,GAAA;QACH,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,EAAE;YAC9B,OAAO;gBAAC,IAAI,CAAC,SAAS;aAAC,CAAC;SAC3B;QACD,IAAI,IAAI,CAAC,GAAG,KAAK,SAAS,EAAE;YACxB,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SAClC;QACD,OAAO,EAAE,CAAC;IACd,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 6083, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6089, "column": 0}, "map": {"version":3,"file":"validation-registry.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/validation/validation-registry.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { CodeDescription, DiagnosticRelatedInformation, DiagnosticTag, integer, Range } from 'vscode-languageserver-types';\nimport type { CancellationToken } from '../utils/cancellation.js';\nimport type { LangiumCoreServices } from '../services.js';\nimport type { AstNode, AstReflection, Properties } from '../syntax-tree.js';\nimport type { MaybePromise } from '../utils/promise-utils.js';\nimport type { Stream } from '../utils/stream.js';\nimport type { DocumentSegment } from '../workspace/documents.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { isOperationCancelled } from '../utils/promise-utils.js';\nimport { stream } from '../utils/stream.js';\n\nexport type DiagnosticInfo<N extends AstNode, P extends string = Properties<N>> = {\n    /** The AST node to which the diagnostic is attached. */\n    node: N;\n    /** If a property name is given, the diagnostic is restricted to the corresponding text region. */\n    property?: P;\n    /** If the value of a keyword is given, the diagnostic will appear at its corresponding text region */\n    keyword?: string;\n    /** In case of a multi-value property (array), an index can be given to select a specific element. */\n    index?: number;\n    /** If you want to create a diagnostic independent to any property, use the range property. */\n    range?: Range;\n    /** The diagnostic's code, which usually appear in the user interface. */\n    code?: integer | string;\n    /** An optional property to describe the error code. */\n    codeDescription?: CodeDescription;\n    /** Additional metadata about the diagnostic. */\n    tags?: DiagnosticTag[];\n    /** An array of related diagnostic information, e.g. when symbol-names within a scope collide all definitions can be marked via this property. */\n    relatedInformation?: DiagnosticRelatedInformation[];\n    /** A data entry field that is preserved between a `textDocument/publishDiagnostics` notification and `textDocument/codeAction` request. */\n    data?: unknown;\n}\n\n/**\n * Shape of information commonly used in the `data` field of diagnostics.\n */\nexport interface DiagnosticData {\n    /** Diagnostic code for identifying which code action to apply. This code is _not_ shown in the user interface. */\n    code: string\n    /** Specifies where to apply the code action in the form of a `DocumentSegment`. */\n    actionSegment?: DocumentSegment\n    /** Specifies where to apply the code action in the form of a `Range`. */\n    actionRange?: Range\n}\n\n/**\n * Create DiagnosticData for a given diagnostic code. The result can be put into the `data` field of a DiagnosticInfo.\n */\nexport function diagnosticData(code: string): DiagnosticData {\n    return { code };\n}\n\nexport type ValidationAcceptor = <N extends AstNode>(severity: 'error' | 'warning' | 'info' | 'hint', message: string, info: DiagnosticInfo<N>) => void\n\nexport type ValidationCheck<T extends AstNode = AstNode> = (node: T, accept: ValidationAcceptor, cancelToken: CancellationToken) => MaybePromise<void>;\n\n/**\n * A utility type for associating non-primitive AST types to corresponding validation checks. For example:\n *\n * ```ts\n *   const checks: ValidationChecks<StatemachineAstType> = {\n *       State: validator.checkStateNameStartsWithCapital\n *    };\n * ```\n *\n * If an AST type does not extend AstNode, e.g. if it describes a union of string literals, that type's name must not occur as a key in objects of type `ValidationCheck<...>`.\n *\n * @param T a type definition mapping language specific type names (keys) to the corresponding types (values)\n */\nexport type ValidationChecks<T> = {\n    [K in keyof T]?: T[K] extends AstNode ? ValidationCheck<T[K]> | Array<ValidationCheck<T[K]>> : never\n} & {\n    AstNode?: ValidationCheck<AstNode> | Array<ValidationCheck<AstNode>>;\n}\n\n/**\n * `fast` checks can be executed after every document change (i.e. as the user is typing). If a check\n * is too slow it can delay the response to document changes, yielding bad user experience. By marking\n * it as `slow`, it will be skipped for normal as-you-type validation. Then it's up to you when to\n * schedule these long-running checks: after the fast checks are done, or after saving a document,\n * or with an explicit command, etc.\n *\n * `built-in` checks are errors produced by the lexer, the parser, or the linker. They cannot be used\n * for custom validation checks.\n */\nexport type ValidationCategory = 'fast' | 'slow' | 'built-in'\n\nexport namespace ValidationCategory {\n    export const all: readonly ValidationCategory[] = ['fast', 'slow', 'built-in'];\n}\n\ntype ValidationCheckEntry = {\n    check: ValidationCheck\n    category: ValidationCategory\n}\n\n/**\n * Manages a set of `ValidationCheck`s to be applied when documents are validated.\n */\nexport class ValidationRegistry {\n    private readonly entries = new MultiMap<string, ValidationCheckEntry>();\n    private readonly reflection: AstReflection;\n\n    constructor(services: LangiumCoreServices) {\n        this.reflection = services.shared.AstReflection;\n    }\n\n    /**\n     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)\n     * or an array of validation checks.\n     *\n     * @param checksRecord Set of validation checks to register.\n     * @param category Optional category for the validation checks (defaults to `'fast'`).\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    register<T>(checksRecord: ValidationChecks<T>, thisObj: ThisParameterType<unknown> = this, category: ValidationCategory = 'fast'): void {\n        if (category === 'built-in') {\n            throw new Error(\"The 'built-in' category is reserved for lexer, parser, and linker errors.\");\n        }\n        for (const [type, ch] of Object.entries(checksRecord)) {\n            const callbacks = ch as ValidationCheck | ValidationCheck[];\n            if (Array.isArray(callbacks)) {\n                for (const check of callbacks) {\n                    const entry: ValidationCheckEntry = {\n                        check: this.wrapValidationException(check, thisObj),\n                        category\n                    };\n                    this.addEntry(type, entry);\n                }\n            } else if (typeof callbacks === 'function') {\n                const entry: ValidationCheckEntry = {\n                    check: this.wrapValidationException(callbacks, thisObj),\n                    category\n                };\n                this.addEntry(type, entry);\n            }\n        }\n    }\n\n    protected wrapValidationException(check: ValidationCheck, thisObj: unknown): ValidationCheck {\n        return async (node, accept, cancelToken) => {\n            try {\n                await check.call(thisObj, node, accept, cancelToken);\n            } catch (err) {\n                if (isOperationCancelled(err)) {\n                    throw err;\n                }\n                console.error('An error occurred during validation:', err);\n                const message = err instanceof Error ? err.message : String(err);\n                if (err instanceof Error && err.stack) {\n                    console.error(err.stack);\n                }\n                accept('error', 'An error occurred during validation: ' + message, { node });\n            }\n        };\n    }\n\n    protected addEntry(type: string, entry: ValidationCheckEntry): void {\n        if (type === 'AstNode') {\n            this.entries.add('AstNode', entry);\n            return;\n        }\n        for (const subtype of this.reflection.getAllSubTypes(type)) {\n            this.entries.add(subtype, entry);\n        }\n    }\n\n    getChecks(type: string, categories?: ValidationCategory[]): Stream<ValidationCheck> {\n        let checks = stream(this.entries.get(type))\n            .concat(this.entries.get('AstNode'));\n        if (categories) {\n            checks = checks.filter(entry => categories.includes(entry.category));\n        }\n        return checks.map(entry => entry.check);\n    }\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6188, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6194, "column": 0}, "map": {"version":3,"file":"document-validator.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/validation/document-validator.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { MismatchedTokenException } from 'chevrotain';\nimport type { DiagnosticSeverity, Position, Range, Diagnostic } from 'vscode-languageserver-types';\nimport type { LanguageMetaData } from '../languages/language-meta-data.js';\nimport type { ParseResult } from '../parser/langium-parser.js';\nimport type { LangiumCoreServices } from '../services.js';\nimport type { AstNode, CstNode } from '../syntax-tree.js';\nimport type { LangiumDocument } from '../workspace/documents.js';\nimport type { DiagnosticData, DiagnosticInfo, ValidationAcceptor, ValidationCategory, ValidationRegistry } from './validation-registry.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { findNodeForKeyword, findNodeForProperty } from '../utils/grammar-utils.js';\nimport { streamAst } from '../utils/ast-utils.js';\nimport { tokenToRange } from '../utils/cst-utils.js';\nimport { interruptAndCheck, isOperationCancelled } from '../utils/promise-utils.js';\nimport { diagnosticData } from './validation-registry.js';\n\nexport interface ValidationOptions {\n    /**\n     * If this is set, only the checks associated with these categories are executed; otherwise\n     * all checks are executed. The default category if not specified to the registry is `'fast'`.\n     */\n    categories?: ValidationCategory[];\n    /** If true, no further diagnostics are reported if there are lexing errors. */\n    stopAfterLexingErrors?: boolean\n    /** If true, no further diagnostics are reported if there are parsing errors. */\n    stopAfterParsingErrors?: boolean\n    /** If true, no further diagnostics are reported if there are linking errors. */\n    stopAfterLinkingErrors?: boolean\n}\n\n/**\n * Language-specific service for validating `LangiumDocument`s.\n */\nexport interface DocumentValidator {\n    /**\n     * Validates the whole specified document.\n     *\n     * @param document specified document to validate\n     * @param options options to control the validation process\n     * @param cancelToken allows to cancel the current operation\n     * @throws `OperationCanceled` if a user action occurs during execution\n     */\n    validateDocument(document: LangiumDocument, options?: ValidationOptions, cancelToken?: CancellationToken): Promise<Diagnostic[]>;\n}\n\nexport class DefaultDocumentValidator implements DocumentValidator {\n\n    protected readonly validationRegistry: ValidationRegistry;\n    protected readonly metadata: LanguageMetaData;\n\n    constructor(services: LangiumCoreServices) {\n        this.validationRegistry = services.validation.ValidationRegistry;\n        this.metadata = services.LanguageMetaData;\n    }\n\n    async validateDocument(document: LangiumDocument, options: ValidationOptions = {}, cancelToken = CancellationToken.None): Promise<Diagnostic[]> {\n        const parseResult = document.parseResult;\n        const diagnostics: Diagnostic[] = [];\n\n        await interruptAndCheck(cancelToken);\n\n        if (!options.categories || options.categories.includes('built-in')) {\n            this.processLexingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterLexingErrors && diagnostics.some(d => d.data?.code === DocumentValidator.LexingError)) {\n                return diagnostics;\n            }\n\n            this.processParsingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterParsingErrors && diagnostics.some(d => d.data?.code === DocumentValidator.ParsingError)) {\n                return diagnostics;\n            }\n\n            this.processLinkingErrors(document, diagnostics, options);\n            if (options.stopAfterLinkingErrors && diagnostics.some(d => d.data?.code === DocumentValidator.LinkingError)) {\n                return diagnostics;\n            }\n        }\n\n        // Process custom validations\n        try {\n            diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));\n        } catch (err) {\n            if (isOperationCancelled(err)) {\n                throw err;\n            }\n            console.error('An error occurred during validation:', err);\n        }\n\n        await interruptAndCheck(cancelToken);\n\n        return diagnostics;\n    }\n\n    protected processLexingErrors(parseResult: ParseResult, diagnostics: Diagnostic[], _options: ValidationOptions): void {\n        for (const lexerError of parseResult.lexerErrors) {\n            const diagnostic: Diagnostic = {\n                severity: toDiagnosticSeverity('error'),\n                range: {\n                    start: {\n                        line: lexerError.line! - 1,\n                        character: lexerError.column! - 1\n                    },\n                    end: {\n                        line: lexerError.line! - 1,\n                        character: lexerError.column! + lexerError.length - 1\n                    }\n                },\n                message: lexerError.message,\n                data: diagnosticData(DocumentValidator.LexingError),\n                source: this.getSource()\n            };\n            diagnostics.push(diagnostic);\n        }\n    }\n\n    protected processParsingErrors(parseResult: ParseResult, diagnostics: Diagnostic[], _options: ValidationOptions): void {\n        for (const parserError of parseResult.parserErrors) {\n            let range: Range | undefined = undefined;\n            // We can run into the chevrotain error recovery here\n            // The token contained in the parser error might be automatically inserted\n            // In this case every position value will be `NaN`\n            if (isNaN(parserError.token.startOffset)) {\n                // Some special parser error types contain a `previousToken`\n                // We can simply append our diagnostic to that token\n                if ('previousToken' in parserError) {\n                    const token = (parserError as MismatchedTokenException).previousToken;\n                    if (!isNaN(token.startOffset)) {\n                        const position: Position = { line: token.endLine! - 1, character: token.endColumn! };\n                        range = { start: position, end: position};\n                    } else {\n                        // No valid prev token. Might be empty document or containing only hidden tokens.\n                        // Point to document start\n                        const position: Position = { line: 0, character: 0 };\n                        range = { start: position, end: position};\n                    }\n                }\n            } else {\n                range = tokenToRange(parserError.token);\n            }\n            if (range) {\n                const diagnostic: Diagnostic = {\n                    severity: toDiagnosticSeverity('error'),\n                    range,\n                    message: parserError.message,\n                    data: diagnosticData(DocumentValidator.ParsingError),\n                    source: this.getSource()\n                };\n                diagnostics.push(diagnostic);\n            }\n        }\n    }\n\n    protected processLinkingErrors(document: LangiumDocument, diagnostics: Diagnostic[], _options: ValidationOptions): void {\n        for (const reference of document.references) {\n            const linkingError = reference.error;\n            if (linkingError) {\n                const info: DiagnosticInfo<AstNode, string> = {\n                    node: linkingError.container,\n                    property: linkingError.property,\n                    index: linkingError.index,\n                    data: {\n                        code: DocumentValidator.LinkingError,\n                        containerType: linkingError.container.$type,\n                        property: linkingError.property,\n                        refText: linkingError.reference.$refText\n                    } satisfies LinkingErrorData\n                };\n                diagnostics.push(this.toDiagnostic('error', linkingError.message, info));\n            }\n        }\n    }\n\n    protected async validateAst(rootNode: AstNode, options: ValidationOptions, cancelToken = CancellationToken.None): Promise<Diagnostic[]> {\n        const validationItems: Diagnostic[] = [];\n        const acceptor: ValidationAcceptor = <N extends AstNode>(severity: 'error' | 'warning' | 'info' | 'hint', message: string, info: DiagnosticInfo<N>) => {\n            validationItems.push(this.toDiagnostic(severity, message, info));\n        };\n\n        await Promise.all(streamAst(rootNode).map(async node => {\n            await interruptAndCheck(cancelToken);\n            const checks = this.validationRegistry.getChecks(node.$type, options.categories);\n            for (const check of checks) {\n                await check(node, acceptor, cancelToken);\n            }\n        }));\n        return validationItems;\n    }\n\n    protected toDiagnostic<N extends AstNode>(severity: 'error' | 'warning' | 'info' | 'hint', message: string, info: DiagnosticInfo<N, string>): Diagnostic {\n        return {\n            message,\n            range: getDiagnosticRange(info),\n            severity: toDiagnosticSeverity(severity),\n            code: info.code,\n            codeDescription: info.codeDescription,\n            tags: info.tags,\n            relatedInformation: info.relatedInformation,\n            data: info.data,\n            source: this.getSource()\n        };\n    }\n\n    protected getSource(): string | undefined {\n        return this.metadata.languageId;\n    }\n}\n\nexport function getDiagnosticRange<N extends AstNode>(info: DiagnosticInfo<N, string>): Range {\n    if (info.range) {\n        return info.range;\n    }\n    let cstNode: CstNode | undefined;\n    if (typeof info.property === 'string') {\n        cstNode = findNodeForProperty(info.node.$cstNode, info.property, info.index);\n    } else if (typeof info.keyword === 'string') {\n        cstNode = findNodeForKeyword(info.node.$cstNode, info.keyword, info.index);\n    }\n    cstNode ??= info.node.$cstNode;\n    if (!cstNode) {\n        return {\n            start: { line: 0, character: 0 },\n            end: { line: 0, character: 0 }\n        };\n    }\n    return cstNode.range;\n}\n\nexport function toDiagnosticSeverity(severity: 'error' | 'warning' | 'info' | 'hint'): DiagnosticSeverity {\n    switch (severity) {\n        case 'error':\n            return 1; // according to vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity.Error\n        case 'warning':\n            return 2; // according to vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity.Warning\n        case 'info':\n            return 3; // according to vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity.Information\n        case 'hint':\n            return 4; // according to vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity.Hint\n        default:\n            throw new Error('Invalid diagnostic severity: ' + severity);\n    }\n}\n\nexport namespace DocumentValidator {\n    export const LexingError = 'lexing-error';\n    export const ParsingError = 'parsing-error';\n    export const LinkingError = 'linking-error';\n}\n\nexport interface LinkingErrorData extends DiagnosticData {\n    containerType: string\n    property: string\n    refText: string\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6425, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6431, "column": 0}, "map": {"version":3,"file":"ast-descriptions.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/workspace/ast-descriptions.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { URI } from '../utils/uri-utils.js';\nimport type { NameProvider } from '../references/name-provider.js';\nimport type { LangiumCoreServices } from '../services.js';\nimport type { AstNode, AstNodeDescription, ReferenceInfo } from '../syntax-tree.js';\nimport type { AstNodeLocator } from './ast-node-locator.js';\nimport type { DocumentSegment, LangiumDocument } from './documents.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { isLinkingError } from '../syntax-tree.js';\nimport { getDocument, streamAst, streamReferences } from '../utils/ast-utils.js';\nimport { toDocumentSegment } from '../utils/cst-utils.js';\nimport { interruptAndCheck } from '../utils/promise-utils.js';\nimport { UriUtils } from '../utils/uri-utils.js';\n\n/**\n * Language-specific service for creating descriptions of AST nodes to be used for cross-reference resolutions.\n */\nexport interface AstNodeDescriptionProvider {\n\n    /**\n     * Create a description for the given AST node. This service method is typically used while indexing\n     * the contents of a document and during scope computation.\n     *\n     * @param node An AST node.\n     * @param name The name to be used to refer to the AST node. By default, this is determined by the\n     *     `NameProvider` service, but alternative names may be provided according to the semantics\n     *     of your language.\n     * @param document The document containing the AST node. If omitted, it is taken from the root AST node.\n     */\n    createDescription(node: AstNode, name: string | undefined, document?: LangiumDocument): AstNodeDescription;\n\n}\n\nexport class DefaultAstNodeDescriptionProvider implements AstNodeDescriptionProvider {\n\n    protected readonly astNodeLocator: AstNodeLocator;\n    protected readonly nameProvider: NameProvider;\n\n    constructor(services: LangiumCoreServices) {\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n    }\n\n    createDescription(node: AstNode, name: string | undefined, document: LangiumDocument = getDocument(node)): AstNodeDescription {\n        name ??= this.nameProvider.getName(node);\n        const path = this.astNodeLocator.getAstNodePath(node);\n        if (!name) {\n            throw new Error(`Node at path ${path} has no name.`);\n        }\n        let nameNodeSegment: DocumentSegment | undefined;\n        const nameSegmentGetter = () => nameNodeSegment ??= toDocumentSegment(this.nameProvider.getNameNode(node) ?? node.$cstNode);\n        return {\n            node,\n            name,\n            get nameSegment() {\n                return nameSegmentGetter();\n            },\n            selectionSegment: toDocumentSegment(node.$cstNode),\n            type: node.$type,\n            documentUri: document.uri,\n            path\n        };\n    }\n\n}\n\n/**\n * Describes a cross-reference within a document or between two documents.\n */\nexport interface ReferenceDescription {\n    /** URI of the document that holds a reference */\n    sourceUri: URI\n    /** Path to AstNode that holds a reference */\n    sourcePath: string\n    /** Target document uri */\n    targetUri: URI\n    /** Path to the target AstNode inside the document */\n    targetPath: string\n    /** Segment of the reference text. */\n    segment: DocumentSegment\n    /** Marks a local reference i.e. a cross reference inside a document.   */\n    local?: boolean\n}\n\n/**\n * Language-specific service to create descriptions of all cross-references in a document. These are used by the `IndexManager`\n * to determine which documents are affected and should be rebuilt when a document is changed.\n */\nexport interface ReferenceDescriptionProvider {\n    /**\n     * Create descriptions of all cross-references found in the given document. These descriptions are\n     * gathered by the `IndexManager` and stored in the global index so they can be considered when\n     * a document change is reported by the client.\n     *\n     * @param document The document in which to gather cross-references.\n     * @param cancelToken Indicates when to cancel the current operation.\n     * @throws `OperationCanceled` if a user action occurs during execution\n     */\n    createDescriptions(document: LangiumDocument, cancelToken?: CancellationToken): Promise<ReferenceDescription[]>;\n}\n\nexport class DefaultReferenceDescriptionProvider implements ReferenceDescriptionProvider {\n\n    protected readonly nodeLocator: AstNodeLocator;\n\n    constructor(services: LangiumCoreServices) {\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n\n    async createDescriptions(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<ReferenceDescription[]> {\n        const descr: ReferenceDescription[] = [];\n        const rootNode = document.parseResult.value;\n        for (const astNode of streamAst(rootNode)) {\n            await interruptAndCheck(cancelToken);\n            streamReferences(astNode).filter(refInfo => !isLinkingError(refInfo)).forEach(refInfo => {\n                // TODO: Consider logging a warning or throw an exception when DocumentState is < than Linked\n                const description = this.createDescription(refInfo);\n                if (description) {\n                    descr.push(description);\n                }\n            });\n        }\n        return descr;\n    }\n\n    protected createDescription(refInfo: ReferenceInfo): ReferenceDescription | undefined {\n        const targetNodeDescr = refInfo.reference.$nodeDescription;\n        const refCstNode = refInfo.reference.$refNode;\n        if (!targetNodeDescr || !refCstNode) {\n            return undefined;\n        }\n        const docUri = getDocument(refInfo.container).uri;\n        return {\n            sourceUri: docUri,\n            sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),\n            targetUri: targetNodeDescr.documentUri,\n            targetPath: targetNodeDescr.path,\n            segment: toDocumentSegment(refCstNode),\n            local: UriUtils.equals(targetNodeDescr.documentUri, docUri)\n        };\n    }\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6518, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6524, "column": 0}, "map": {"version":3,"file":"ast-node-locator.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/workspace/ast-node-locator.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { AstNode } from '../syntax-tree.js';\n\n/**\n * Language-specific service for locating an `AstNode` in a document.\n */\nexport interface AstNodeLocator {\n\n    /**\n     * Creates a path represented by a `string` that identifies an `AstNode` inside its document.\n     * It must be possible to retrieve exactly the same `AstNode` from the document using this path.\n     *\n     * @param node The `AstNode` for which to create the path.\n     * @returns a path represented by a `string` that identifies `node` inside its document.\n     * @see AstNodeLocator.getAstNode\n     */\n    getAstNodePath(node: AstNode): string;\n\n    /**\n     * Locates an `AstNode` inside another node by following the given path.\n     *\n     * @param node Parent element.\n     * @param path Describes how to locate the `AstNode` inside the given `node`.\n     * @returns The `AstNode` located under the given path, or `undefined` if the path cannot be resolved.\n     * @see AstNodeLocator.getAstNodePath\n     */\n    getAstNode<T extends AstNode = AstNode>(node: AstNode, path: string): T | undefined;\n\n}\n\nexport class DefaultAstNodeLocator implements AstNodeLocator {\n    protected segmentSeparator = '/';\n    protected indexSeparator = '@';\n\n    getAstNodePath(node: AstNode): string {\n        if (node.$container) {\n            const containerPath = this.getAstNodePath(node.$container);\n            const newSegment = this.getPathSegment(node);\n            const nodePath = containerPath + this.segmentSeparator + newSegment;\n            return nodePath;\n        }\n        return '';\n    }\n\n    protected getPathSegment({ $containerProperty, $containerIndex }: AstNode): string {\n        if (!$containerProperty) {\n            throw new Error(\"Missing '$containerProperty' in AST node.\");\n        }\n        if ($containerIndex !== undefined) {\n            return $containerProperty + this.indexSeparator + $containerIndex;\n        }\n        return $containerProperty;\n    }\n\n    getAstNode<T extends AstNode = AstNode>(node: AstNode, path: string): T | undefined {\n        const segments = path.split(this.segmentSeparator);\n        return segments.reduce((previousValue, currentValue) => {\n            if (!previousValue || currentValue.length === 0) {\n                return previousValue;\n            }\n            const propertyIndex = currentValue.indexOf(this.indexSeparator);\n            if (propertyIndex > 0) {\n                const property = currentValue.substring(0, propertyIndex);\n                const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));\n                const array = (previousValue as unknown as Record<string, AstNode[]>)[property];\n                return array?.[arrayIndex];\n            }\n            return (previousValue as unknown as Record<string, AstNode>)[currentValue];\n        }, node) as T;\n    }\n\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;AA+B1E,MAAO,qBAAqB;IAAlC,aAAA;QACc,IAAA,CAAA,gBAAgB,GAAG,GAAG,CAAC;QACvB,IAAA,CAAA,cAAc,GAAG,GAAG,CAAC;IAuCnC,CAAC;IArCG,cAAc,CAAC,IAAa,EAAA;QACxB,IAAI,IAAI,CAAC,UAAU,EAAE;YACjB,MAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC3D,MAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YAC7C,MAAM,QAAQ,GAAG,aAAa,GAAG,IAAI,CAAC,gBAAgB,GAAG,UAAU,CAAC;YACpE,OAAO,QAAQ,CAAC;SACnB;QACD,OAAO,EAAE,CAAC;IACd,CAAC;IAES,cAAc,CAAC,EAAE,kBAAkB,EAAE,eAAe,EAAW,EAAA;QACrE,IAAI,CAAC,kBAAkB,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;SAChE;QACD,IAAI,eAAe,KAAK,SAAS,EAAE;YAC/B,OAAO,kBAAkB,GAAG,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC;SACrE;QACD,OAAO,kBAAkB,CAAC;IAC9B,CAAC;IAED,UAAU,CAA8B,IAAa,EAAE,IAAY,EAAA;QAC/D,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACnD,OAAO,QAAQ,CAAC,MAAM,CAAC,CAAC,aAAa,EAAE,YAAY,EAAE,EAAE;YACnD,IAAI,CAAC,aAAa,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC7C,OAAO,aAAa,CAAC;aACxB;YACD,MAAM,aAAa,GAAG,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YAChE,IAAI,aAAa,GAAG,CAAC,EAAE;gBACnB,MAAM,QAAQ,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC;gBAC1D,MAAM,UAAU,GAAG,QAAQ,CAAC,YAAY,CAAC,SAAS,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;gBACvE,MAAM,KAAK,GAAI,aAAsD,CAAC,QAAQ,CAAC,CAAC;gBAChF,OAAO,KAAK,KAAA,QAAL,KAAK,KAAA,KAAA,IAAA,KAAA,IAAL,KAAK,CAAG,UAAU,CAAC,CAAC;aAC9B;YACD,OAAQ,aAAoD,CAAC,YAAY,CAAC,CAAC;QAC/E,CAAC,EAAE,IAAI,CAAM,CAAC;IAClB,CAAC;CAEJ","ignoreList":[0]}},
    {"offset": {"line": 6571, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6577, "column": 0}, "map": {"version":3,"file":"configuration.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/workspace/configuration.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { ConfigurationItem, DidChangeConfigurationParams, DidChangeConfigurationRegistrationOptions, InitializeParams, InitializedParams } from 'vscode-languageserver-protocol';\nimport type { ServiceRegistry } from '../service-registry.js';\nimport type { LangiumSharedCoreServices } from '../services.js';\nimport { Deferred } from '../utils/promise-utils.js';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport interface ConfigurationProvider {\n\n    /**\n     * A promise that resolves when the configuration provider is ready to be used.\n     */\n    readonly ready: Promise<void>;\n\n    /**\n     * When used in a language server context, this method is called when the server receives\n     * the `initialize` request.\n     */\n    initialize(params: InitializeParams): void;\n\n    /**\n     * When used in a language server context, this method is called when the server receives\n     * the `initialized` notification.\n     */\n    initialized(params: ConfigurationInitializedParams): Promise<void>;\n\n    /**\n     * Returns a configuration value stored for the given language.\n     *\n     * @param language The language id\n     * @param configuration Configuration name\n     */\n    getConfiguration(language: string, configuration: string): Promise<any>;\n\n    /**\n     *  Updates the cached configurations using the `change` notification parameters.\n     *\n     * @param change The parameters of a change configuration notification.\n     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\n     */\n    updateConfiguration(change: DidChangeConfigurationParams): void;\n}\n\nexport interface ConfigurationInitializedParams extends InitializedParams {\n    register?: (params: DidChangeConfigurationRegistrationOptions) => void,\n    fetchConfiguration?: (configuration: ConfigurationItem[]) => Promise<any>\n}\n\n/**\n * Base configuration provider for building up other configuration providers\n */\nexport class DefaultConfigurationProvider implements ConfigurationProvider {\n\n    protected readonly serviceRegistry: ServiceRegistry;\n    protected readonly _ready = new Deferred<void>();\n    protected settings: Record<string, Record<string, any>> = {};\n    protected workspaceConfig = false;\n\n    constructor(services: LangiumSharedCoreServices) {\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n\n    get ready(): Promise<void> {\n        return this._ready.promise;\n    }\n\n    initialize(params: InitializeParams): void {\n        this.workspaceConfig = params.capabilities.workspace?.configuration ?? false;\n    }\n\n    async initialized(params: ConfigurationInitializedParams): Promise<void> {\n        if (this.workspaceConfig) {\n            if (params.register) {\n                // params.register(...) is a function to be provided by the calling language server for the sake of\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\n\n                const languages = this.serviceRegistry.all;\n                params.register({\n                    // Listen to configuration changes for all languages\n                    section: languages.map(lang => this.toSectionName(lang.LanguageMetaData.languageId))\n                });\n            }\n\n            if (params.fetchConfiguration) {\n                // params.fetchConfiguration(...) is a function to be provided by the calling language server for the sake of\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\n                const configToUpdate = this.serviceRegistry.all.map(lang => <ConfigurationItem>{\n                    // Fetch the configuration changes for all languages\n                    section: this.toSectionName(lang.LanguageMetaData.languageId)\n                });\n\n                // get workspace configurations (default scope URI)\n                const configs = await params.fetchConfiguration(configToUpdate);\n                configToUpdate.forEach((conf, idx) => {\n                    this.updateSectionConfiguration(conf.section!, configs[idx]);\n                });\n            }\n        }\n        this._ready.resolve();\n    }\n\n    /**\n     *  Updates the cached configurations using the `change` notification parameters.\n     *\n     * @param change The parameters of a change configuration notification.\n     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\n     */\n    updateConfiguration(change: DidChangeConfigurationParams): void {\n        if (!change.settings) {\n            return;\n        }\n        Object.keys(change.settings).forEach(section => {\n            this.updateSectionConfiguration(section, change.settings[section]);\n        });\n    }\n\n    protected updateSectionConfiguration(section: string, configuration: any): void {\n        this.settings[section] = configuration;\n    }\n\n    /**\n    * Returns a configuration value stored for the given language.\n    *\n    * @param language The language id\n    * @param configuration Configuration name\n    */\n    async getConfiguration(language: string, configuration: string): Promise<any> {\n        await this.ready;\n\n        const sectionName = this.toSectionName(language);\n        if (this.settings[sectionName]) {\n            return this.settings[sectionName][configuration];\n        }\n    }\n\n    protected toSectionName(languageId: string): string {\n        return `${languageId}`;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6659, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6665, "column": 0}, "map": {"version":3,"file":"disposable.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/disposable.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport interface Disposable {\n    /**\n     * Dispose this object.\n     */\n    dispose(): void;\n}\n\nexport interface AsyncDisposable {\n    /**\n     * Dispose this object.\n     */\n    dispose(): Promise<void>;\n}\n\nexport namespace Disposable {\n    export function create(callback: () => Promise<void>): AsyncDisposable;\n    export function create(callback: () => void): Disposable;\n    export function create(callback: () => void | Promise<void>): Disposable | AsyncDisposable {\n        return {\n            dispose: async () => await callback()\n        };\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;AAgB1E,IAAW,UAAU,CAQ1B;AARD,CAAA,SAAiB,UAAU;IAGvB,SAAgB,MAAM,CAAC,QAAoC;QACvD,OAAO;YACH,OAAO,EAAE,KAAK,IAAI,CAAG,CAAD,KAAO,QAAQ,EAAE;SACxC,CAAC;IACN,CAAC;IAJe,WAAA,MAAM,GAAA,MAIrB,CAAA;AACL,CAAC,EARgB,UAAU,IAAA,CAAV,UAAU,GAAA,CAAA,CAAA,GAQ1B","ignoreList":[0]}},
    {"offset": {"line": 6681, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6687, "column": 0}, "map": {"version":3,"file":"document-builder.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/workspace/document-builder.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { Disposable } from '../utils/disposable.js';\nimport type { ServiceRegistry } from '../service-registry.js';\nimport type { LangiumSharedCoreServices } from '../services.js';\nimport type { AstNode } from '../syntax-tree.js';\nimport type { MaybePromise } from '../utils/promise-utils.js';\nimport type { Deferred } from '../utils/promise-utils.js';\nimport type { ValidationOptions } from '../validation/document-validator.js';\nimport type { IndexManager } from '../workspace/index-manager.js';\nimport type { LangiumDocument, LangiumDocuments, LangiumDocumentFactory } from './documents.js';\nimport { MultiMap } from '../utils/collections.js';\nimport { OperationCancelled, interruptAndCheck } from '../utils/promise-utils.js';\nimport { stream } from '../utils/stream.js';\nimport type { URI } from '../utils/uri-utils.js';\nimport { ValidationCategory } from '../validation/validation-registry.js';\nimport { DocumentState } from './documents.js';\n\nexport interface BuildOptions {\n    /**\n     * Control the validation phase with this option:\n     *  - `true` enables all validation checks and forces revalidating the documents\n     *  - `false` or `undefined` disables all validation checks\n     *  - An object runs only the necessary validation checks; the `categories` property restricts this to a specific subset\n     */\n    validation?: boolean | ValidationOptions\n}\n\nexport interface DocumentBuildState {\n    /** Whether a document has completed its last build process. */\n    completed: boolean\n    /** The options used for the last build process. */\n    options: BuildOptions\n    /** Additional information about the last build result. */\n    result?: {\n        validationChecks?: ValidationCategory[]\n    }\n}\n\n/**\n * Shared-service for building and updating `LangiumDocument`s.\n */\nexport interface DocumentBuilder {\n\n    /** The options used for rebuilding documents after an update. */\n    updateBuildOptions: BuildOptions;\n\n    /**\n     * Execute all necessary build steps for the given documents.\n     *\n     * @param documents Set of documents to be built.\n     * @param options Options for the document builder.\n     * @param cancelToken Indicates when to cancel the current operation.\n     * @throws `OperationCanceled` if a user action occurs during execution\n     */\n    build<T extends AstNode>(documents: Array<LangiumDocument<T>>, options?: BuildOptions, cancelToken?: CancellationToken): Promise<void>;\n\n    /**\n     * This method is called when a document change is detected. It updates the state of all\n     * affected documents, including those with references to the changed ones, so they are rebuilt.\n     *\n     * @param changed URIs of changed or created documents\n     * @param deleted URIs of deleted documents\n     * @param cancelToken allows to cancel the current operation\n     * @throws `OperationCancelled` if cancellation is detected during execution\n     */\n    update(changed: URI[], deleted: URI[], cancelToken?: CancellationToken): Promise<void>;\n\n    /**\n     * Notify the given callback when a document update was triggered, but before any document\n     * is rebuilt. Listeners to this event should not perform any long-running task.\n     */\n    onUpdate(callback: DocumentUpdateListener): Disposable;\n\n    /**\n     * Notify the given callback when a set of documents has been built reaching a desired target state.\n     */\n    onBuildPhase(targetState: DocumentState, callback: DocumentBuildListener): Disposable;\n\n    /**\n     * Wait until the workspace has reached the specified state for all documents.\n     *\n     * @param state The desired state. The promise won't resolve until all documents have reached this state\n     * @param cancelToken Optionally allows to cancel the wait operation, disposing any listeners in the process\n     * @throws `OperationCancelled` if cancellation has been requested before the state has been reached\n     */\n    waitUntil(state: DocumentState, cancelToken?: CancellationToken): Promise<void>;\n\n    /**\n     * Wait until the document specified by the {@link uri} has reached the specified state.\n     *\n     * @param state The desired state. The promise won't resolve until the document has reached this state.\n     * @param uri The specified URI that points to the document. If the URI does not exist, the promise will resolve once the workspace has reached the specified state.\n     * @param cancelToken Optionally allows to cancel the wait operation, disposing any listeners in the process.\n     * @return The URI of the document that has reached the desired state, or `undefined` if the document does not exist.\n     * @throws `OperationCancelled` if cancellation has been requested before the state has been reached\n     */\n    waitUntil(state: DocumentState, uri?: URI, cancelToken?: CancellationToken): Promise<URI | undefined>;\n}\n\nexport type DocumentUpdateListener = (changed: URI[], deleted: URI[]) => void | Promise<void>\nexport type DocumentBuildListener = (built: LangiumDocument[], cancelToken: CancellationToken) => void | Promise<void>\nexport class DefaultDocumentBuilder implements DocumentBuilder {\n\n    updateBuildOptions: BuildOptions = {\n        // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)\n        validation: {\n            categories: ['built-in', 'fast']\n        }\n    };\n\n    protected readonly langiumDocuments: LangiumDocuments;\n    protected readonly langiumDocumentFactory: LangiumDocumentFactory;\n    protected readonly indexManager: IndexManager;\n    protected readonly serviceRegistry: ServiceRegistry;\n    protected readonly updateListeners: DocumentUpdateListener[] = [];\n    protected readonly buildPhaseListeners = new MultiMap<DocumentState, DocumentBuildListener>();\n    protected readonly buildState = new Map<string, DocumentBuildState>();\n    protected readonly documentBuildWaiters = new Map<string, Deferred<void>>();\n    protected currentState = DocumentState.Changed;\n\n    constructor(services: LangiumSharedCoreServices) {\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n        this.indexManager = services.workspace.IndexManager;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n\n    async build<T extends AstNode>(documents: Array<LangiumDocument<T>>, options: BuildOptions = {}, cancelToken = CancellationToken.None): Promise<void> {\n        for (const document of documents) {\n            const key = document.uri.toString();\n            if (document.state === DocumentState.Validated) {\n                if (typeof options.validation === 'boolean' && options.validation) {\n                    // Force re-running all validation checks\n                    document.state = DocumentState.IndexedReferences;\n                    document.diagnostics = undefined;\n                    this.buildState.delete(key);\n                } else if (typeof options.validation === 'object') {\n                    const buildState = this.buildState.get(key);\n                    const previousCategories = buildState?.result?.validationChecks;\n                    if (previousCategories) {\n                        // Validation with explicit options was requested for a document that has already been partly validated.\n                        // In this case, we need to merge the previous validation categories with the new ones.\n                        const newCategories = options.validation.categories ?? ValidationCategory.all as ValidationCategory[];\n                        const categories = newCategories.filter(c => !previousCategories.includes(c));\n                        if (categories.length > 0) {\n                            this.buildState.set(key, {\n                                completed: false,\n                                options: {\n                                    validation: {\n                                        ...options.validation,\n                                        categories\n                                    }\n                                },\n                                result: buildState.result\n                            });\n                            document.state = DocumentState.IndexedReferences;\n                        }\n                    }\n                }\n            } else {\n                // Default: forget any previous build options\n                this.buildState.delete(key);\n            }\n        }\n        this.currentState = DocumentState.Changed;\n        await this.emitUpdate(documents.map(e => e.uri), []);\n        await this.buildDocuments(documents, options, cancelToken);\n    }\n\n    async update(changed: URI[], deleted: URI[], cancelToken = CancellationToken.None): Promise<void> {\n        this.currentState = DocumentState.Changed;\n        // Remove all metadata of documents that are reported as deleted\n        for (const deletedUri of deleted) {\n            this.langiumDocuments.deleteDocument(deletedUri);\n            this.buildState.delete(deletedUri.toString());\n            this.indexManager.remove(deletedUri);\n        }\n        // Set the state of all changed documents to `Changed` so they are completely rebuilt\n        for (const changedUri of changed) {\n            const invalidated = this.langiumDocuments.invalidateDocument(changedUri);\n            if (!invalidated) {\n                // We create an unparsed, invalid document.\n                // This will be parsed as soon as we reach the first document builder phase.\n                // This allows to cancel the parsing process later in case we need it.\n                const newDocument = this.langiumDocumentFactory.fromModel({ $type: 'INVALID' }, changedUri);\n                newDocument.state = DocumentState.Changed;\n                this.langiumDocuments.addDocument(newDocument);\n            }\n            this.buildState.delete(changedUri.toString());\n        }\n        // Set the state of all documents that should be relinked to `ComputedScopes` (if not already lower)\n        const allChangedUris = stream(changed).concat(deleted).map(uri => uri.toString()).toSet();\n        this.langiumDocuments.all\n            .filter(doc => !allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris))\n            .forEach(doc => {\n                const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n                linker.unlink(doc);\n                doc.state = Math.min(doc.state, DocumentState.ComputedScopes);\n                doc.diagnostics = undefined;\n            });\n        // Notify listeners of the update\n        await this.emitUpdate(changed, deleted);\n        // Only allow interrupting the execution after all state changes are done\n        await interruptAndCheck(cancelToken);\n\n        // Collect all documents that we should rebuild\n        const rebuildDocuments = this.langiumDocuments.all\n            .filter(doc =>\n                // This includes those that were reported as changed and those that we selected for relinking\n                doc.state < DocumentState.Linked\n                // This includes those for which a previous build has been cancelled\n                || !this.buildState.get(doc.uri.toString())?.completed\n            )\n            .toArray();\n        await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);\n    }\n\n    protected async emitUpdate(changed: URI[], deleted: URI[]): Promise<void> {\n        await Promise.all(this.updateListeners.map(listener => listener(changed, deleted)));\n    }\n\n    /**\n     * Check whether the given document should be relinked after changes were found in the given URIs.\n     */\n    protected shouldRelink(document: LangiumDocument, changedUris: Set<string>): boolean {\n        // Relink documents with linking errors -- maybe those references can be resolved now\n        if (document.references.some(ref => ref.error !== undefined)) {\n            return true;\n        }\n        // Check whether the document is affected by any of the changed URIs\n        return this.indexManager.isAffected(document, changedUris);\n    }\n\n    onUpdate(callback: DocumentUpdateListener): Disposable {\n        this.updateListeners.push(callback);\n        return Disposable.create(() => {\n            const index = this.updateListeners.indexOf(callback);\n            if (index >= 0) {\n                this.updateListeners.splice(index, 1);\n            }\n        });\n    }\n\n    /**\n     * Build the given documents by stepping through all build phases. If a document's state indicates\n     * that a certain build phase is already done, the phase is skipped for that document.\n     */\n    protected async buildDocuments(documents: LangiumDocument[], options: BuildOptions, cancelToken: CancellationToken): Promise<void> {\n        this.prepareBuild(documents, options);\n        // 0. Parse content\n        await this.runCancelable(documents, DocumentState.Parsed, cancelToken, doc =>\n            this.langiumDocumentFactory.update(doc, cancelToken)\n        );\n        // 1. Index content\n        await this.runCancelable(documents, DocumentState.IndexedContent, cancelToken, doc =>\n            this.indexManager.updateContent(doc, cancelToken)\n        );\n        // 2. Compute scopes\n        await this.runCancelable(documents, DocumentState.ComputedScopes, cancelToken, async doc => {\n            const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;\n            doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);\n        });\n        // 3. Linking\n        await this.runCancelable(documents, DocumentState.Linked, cancelToken, doc => {\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            return linker.link(doc, cancelToken);\n        });\n        // 4. Index references\n        await this.runCancelable(documents, DocumentState.IndexedReferences, cancelToken, doc =>\n            this.indexManager.updateReferences(doc, cancelToken)\n        );\n        // 5. Validation\n        const toBeValidated = documents.filter(doc => this.shouldValidate(doc));\n        await this.runCancelable(toBeValidated, DocumentState.Validated, cancelToken, doc =>\n            this.validate(doc, cancelToken)\n        );\n\n        // If we've made it to this point without being cancelled, we can mark the build state as completed.\n        for (const doc of documents) {\n            const state = this.buildState.get(doc.uri.toString());\n            if (state) {\n                state.completed = true;\n            }\n        }\n    }\n\n    protected prepareBuild(documents: LangiumDocument[], options: BuildOptions): void {\n        for (const doc of documents) {\n            const key = doc.uri.toString();\n            const state = this.buildState.get(key);\n            // If the document has no previous build state, we set it. If it has one, but it's already marked\n            // as completed, we overwrite it. If the previous build was not completed, we keep its state\n            // and continue where it was cancelled.\n            if (!state || state.completed) {\n                this.buildState.set(key, {\n                    completed: false,\n                    options,\n                    result: state?.result\n                });\n            }\n        }\n    }\n\n    protected async runCancelable(documents: LangiumDocument[], targetState: DocumentState, cancelToken: CancellationToken,\n        callback: (document: LangiumDocument) => MaybePromise<unknown>): Promise<void> {\n        const filtered = documents.filter(e => e.state < targetState);\n        for (const document of filtered) {\n            await interruptAndCheck(cancelToken);\n            await callback(document);\n            document.state = targetState;\n        }\n        await this.notifyBuildPhase(filtered, targetState, cancelToken);\n        this.currentState = targetState;\n    }\n\n    onBuildPhase(targetState: DocumentState, callback: DocumentBuildListener): Disposable {\n        this.buildPhaseListeners.add(targetState, callback);\n        return Disposable.create(() => {\n            this.buildPhaseListeners.delete(targetState, callback);\n        });\n    }\n\n    waitUntil(state: DocumentState, cancelToken?: CancellationToken): Promise<void>;\n    waitUntil(state: DocumentState, uri?: URI, cancelToken?: CancellationToken): Promise<URI | undefined>;\n    waitUntil(state: DocumentState, uriOrToken?: URI | CancellationToken, cancelToken?: CancellationToken): Promise<URI | undefined | void> {\n        let uri: URI | undefined = undefined;\n        if (uriOrToken && 'path' in uriOrToken) {\n            uri = uriOrToken;\n        } else {\n            cancelToken = uriOrToken;\n        }\n        cancelToken ??= CancellationToken.None;\n        if (uri) {\n            const document = this.langiumDocuments.getDocument(uri);\n            if (document && document.state > state) {\n                return Promise.resolve(uri);\n            }\n        }\n        if (this.currentState >= state) {\n            return Promise.resolve(undefined);\n        } else if (cancelToken.isCancellationRequested) {\n            return Promise.reject(OperationCancelled);\n        }\n        return new Promise((resolve, reject) => {\n            const buildDisposable = this.onBuildPhase(state, () => {\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                if (uri) {\n                    const document = this.langiumDocuments.getDocument(uri);\n                    resolve(document?.uri);\n                } else {\n                    resolve(undefined);\n                }\n            });\n            const cancelDisposable = cancelToken!.onCancellationRequested(() => {\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                reject(OperationCancelled);\n            });\n        });\n    }\n\n    protected async notifyBuildPhase(documents: LangiumDocument[], state: DocumentState, cancelToken: CancellationToken): Promise<void> {\n        if (documents.length === 0) {\n            // Don't notify when no document has been processed\n            return;\n        }\n        const listeners = this.buildPhaseListeners.get(state);\n        for (const listener of listeners) {\n            await interruptAndCheck(cancelToken);\n            await listener(documents, cancelToken);\n        }\n    }\n\n    /**\n     * Determine whether the given document should be validated during a build. The default\n     * implementation checks the `validation` property of the build options. If it's set to `true`\n     * or a `ValidationOptions` object, the document is included in the validation phase.\n     */\n    protected shouldValidate(document: LangiumDocument): boolean {\n        return Boolean(this.getBuildOptions(document).validation);\n    }\n\n    /**\n     * Run validation checks on the given document and store the resulting diagnostics in the document.\n     * If the document already contains diagnostics, the new ones are added to the list.\n     */\n    protected async validate(document: LangiumDocument, cancelToken: CancellationToken): Promise<void> {\n        const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;\n        const validationSetting = this.getBuildOptions(document).validation;\n        const options = typeof validationSetting === 'object' ? validationSetting : undefined;\n        const diagnostics = await validator.validateDocument(document, options, cancelToken);\n        if (document.diagnostics) {\n            document.diagnostics.push(...diagnostics);\n        } else {\n            document.diagnostics = diagnostics;\n        }\n\n        // Store information about the executed validation in the build state\n        const state = this.buildState.get(document.uri.toString());\n        if (state) {\n            state.result ??= {};\n            const newCategories = options?.categories ?? ValidationCategory.all;\n            if (state.result.validationChecks) {\n                state.result.validationChecks.push(...newCategories);\n            } else {\n                state.result.validationChecks = [...newCategories];\n            }\n        }\n    }\n\n    protected getBuildOptions(document: LangiumDocument): BuildOptions {\n        return this.buildState.get(document.uri.toString())?.options ?? {};\n    }\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6989, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6995, "column": 0}, "map": {"version":3,"file":"index-manager.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/workspace/index-manager.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { ServiceRegistry } from '../service-registry.js';\nimport type { LangiumSharedCoreServices } from '../services.js';\nimport type { AstNode, AstNodeDescription, AstReflection } from '../syntax-tree.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { ContextCache } from '../utils/caching.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport type { Stream } from '../utils/stream.js';\nimport { stream } from '../utils/stream.js';\nimport type { URI } from '../utils/uri-utils.js';\nimport { UriUtils } from '../utils/uri-utils.js';\nimport type { ReferenceDescription } from './ast-descriptions.js';\nimport type { LangiumDocument, LangiumDocuments } from './documents.js';\n\n/**\n * The index manager is responsible for keeping metadata about symbols and cross-references\n * in the workspace. It is used to look up symbols in the global scope, mostly during linking\n * and completion. This service is shared between all languages of a language server.\n */\nexport interface IndexManager {\n\n    /**\n     * Removes the specified document URI from the index.\n     * Necessary when documents are deleted and not referenceable anymore.\n     *\n     * @param uri The URI of the document for which index data shall be removed\n     */\n    remove(uri: URI): void;\n\n    /**\n     * Updates the information about the exportable content of a document inside the index.\n     *\n     * @param document Document to be updated\n     * @param cancelToken Indicates when to cancel the current operation.\n     * @throws `OperationCanceled` if a user action occurs during execution\n     */\n    updateContent(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;\n\n    /**\n     * Updates the information about the cross-references of a document inside the index.\n     *\n     * @param document Document to be updated\n     * @param cancelToken Indicates when to cancel the current operation.\n     * @throws `OperationCanceled` if a user action occurs during execution\n     */\n    updateReferences(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;\n\n    /**\n     * Determine whether the given document could be affected by changes of the documents\n     * identified by the given URIs (second parameter). The document is typically regarded as\n     * affected if it contains a reference to any of the changed files.\n     *\n     * @param document Document to check whether it's affected\n     * @param changedUris URIs of the changed documents\n     */\n    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean;\n\n    /**\n     * Compute a list of all exported elements, optionally filtered using a type identifier and document URIs.\n     *\n     * @param nodeType The type to filter with, or `undefined` to return descriptions of all types.\n     * @param uris If specified, only returns elements from the given URIs.\n     * @returns a `Stream` containing all globally visible nodes (of a given type).\n     */\n    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription>;\n\n    /**\n     * Returns all known references that are pointing to the given `targetNode`.\n     *\n     * @param targetNode the `AstNode` to look up references for\n     * @param astNodePath the path that points to the `targetNode` inside the document. See also `AstNodeLocator`\n     *\n     * @returns a `Stream` of references that are targeting the `targetNode`\n     */\n    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription>;\n\n}\n\nexport class DefaultIndexManager implements IndexManager {\n\n    protected readonly serviceRegistry: ServiceRegistry;\n    protected readonly documents: LangiumDocuments;\n    protected readonly astReflection: AstReflection;\n\n    /**\n     * The symbol index stores all `AstNodeDescription` items exported by a document.\n     * The key used in this map is the string representation of the specific document URI.\n     */\n    protected readonly symbolIndex = new Map<string, AstNodeDescription[]>();\n    /**\n     * This is a cache for the `allElements()` method.\n     * It caches the descriptions from `symbolIndex` grouped by types.\n     */\n    protected readonly symbolByTypeIndex = new ContextCache<string, string, AstNodeDescription[]>();\n    /**\n     * This index keeps track of all `ReferenceDescription` items exported by a document.\n     * This is used to compute which elements are affected by a document change\n     * and for finding references to an AST node.\n     */\n    protected readonly referenceIndex = new Map<string, ReferenceDescription[]>();\n\n    constructor(services: LangiumSharedCoreServices) {\n        this.documents = services.workspace.LangiumDocuments;\n        this.serviceRegistry = services.ServiceRegistry;\n        this.astReflection = services.AstReflection;\n    }\n\n    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription> {\n        const targetDocUri = getDocument(targetNode).uri;\n        const result: ReferenceDescription[] = [];\n        this.referenceIndex.forEach(docRefs => {\n            docRefs.forEach(refDescr => {\n                if (UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {\n                    result.push(refDescr);\n                }\n            });\n        });\n        return stream(result);\n    }\n\n    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription> {\n        let documentUris = stream(this.symbolIndex.keys());\n        if (uris) {\n            documentUris = documentUris.filter(uri => !uris || uris.has(uri));\n        }\n        return documentUris\n            .map(uri => this.getFileDescriptions(uri, nodeType))\n            .flat();\n    }\n\n    protected getFileDescriptions(uri: string, nodeType?: string): AstNodeDescription[] {\n        if (!nodeType) {\n            return this.symbolIndex.get(uri) ?? [];\n        }\n        const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {\n            const allFileDescriptions = this.symbolIndex.get(uri) ?? [];\n            return allFileDescriptions.filter(e => this.astReflection.isSubtype(e.type, nodeType));\n        });\n        return descriptions;\n    }\n\n    remove(uri: URI): void {\n        const uriString = uri.toString();\n        this.symbolIndex.delete(uriString);\n        this.symbolByTypeIndex.clear(uriString);\n        this.referenceIndex.delete(uriString);\n    }\n\n    async updateContent(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<void> {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);\n        const uri = document.uri.toString();\n        this.symbolIndex.set(uri, exports);\n        this.symbolByTypeIndex.clear(uri);\n    }\n\n    async updateReferences(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<void> {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\n        this.referenceIndex.set(document.uri.toString(), indexData);\n    }\n\n    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean {\n        const references = this.referenceIndex.get(document.uri.toString());\n        if (!references) {\n            return false;\n        }\n        return references.some(ref => !ref.local && changedUris.has(ref.targetUri.toString()));\n    }\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7090, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7096, "column": 0}, "map": {"version":3,"file":"workspace-manager.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/workspace/workspace-manager.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { InitializeParams, InitializedParams } from 'vscode-languageserver-protocol';\nimport type { WorkspaceFolder } from 'vscode-languageserver-types';\nimport type { ServiceRegistry } from '../service-registry.js';\nimport type { LangiumSharedCoreServices } from '../services.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { Deferred, interruptAndCheck } from '../utils/promise-utils.js';\nimport { URI, UriUtils } from '../utils/uri-utils.js';\nimport type { BuildOptions, DocumentBuilder } from './document-builder.js';\nimport type { LangiumDocument, LangiumDocuments } from './documents.js';\nimport type { FileSystemNode, FileSystemProvider } from './file-system-provider.js';\nimport type { WorkspaceLock } from './workspace-lock.js';\n\n// export type WorkspaceFolder from 'vscode-languageserver-types' for convenience,\n//  is supposed to avoid confusion as 'WorkspaceFolder' might accidentally be imported via 'vscode-languageclient'\nexport type { WorkspaceFolder };\n\n/**\n * The workspace manager is responsible for finding source files in the workspace.\n * This service is shared between all languages of a language server.\n */\nexport interface WorkspaceManager {\n\n    /** The options used for the initial workspace build. */\n    initialBuildOptions: BuildOptions | undefined;\n\n    /**\n     * A promise that resolves when the workspace manager is ready to be used.\n     * Use this to ensure that the workspace manager has finished its initialization.\n     */\n    readonly ready: Promise<void>;\n\n    /**\n     * When used in a language server context, this method is called when the server receives\n     * the `initialize` request.\n     */\n    initialize(params: InitializeParams): void;\n\n    /**\n     * When used in a language server context, this method is called when the server receives\n     * the `initialized` notification.\n     */\n    initialized(params: InitializedParams): Promise<void>;\n\n    /**\n     * Does the initial indexing of workspace folders.\n     * Collects information about exported and referenced AstNodes in\n     * each language file and stores it locally.\n     *\n     * @param folders The set of workspace folders to be indexed.\n     */\n    initializeWorkspace(folders: WorkspaceFolder[], cancelToken?: CancellationToken): Promise<void>;\n\n}\n\nexport class DefaultWorkspaceManager implements WorkspaceManager {\n\n    initialBuildOptions: BuildOptions = {};\n\n    protected readonly serviceRegistry: ServiceRegistry;\n    protected readonly langiumDocuments: LangiumDocuments;\n    protected readonly documentBuilder: DocumentBuilder;\n    protected readonly fileSystemProvider: FileSystemProvider;\n    protected readonly mutex: WorkspaceLock;\n    protected readonly _ready = new Deferred<void>();\n    protected folders?: WorkspaceFolder[];\n\n    constructor(services: LangiumSharedCoreServices) {\n        this.serviceRegistry = services.ServiceRegistry;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.documentBuilder = services.workspace.DocumentBuilder;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n        this.mutex = services.workspace.WorkspaceLock;\n    }\n\n    get ready(): Promise<void> {\n        return this._ready.promise;\n    }\n\n    initialize(params: InitializeParams): void {\n        this.folders = params.workspaceFolders ?? undefined;\n    }\n\n    initialized(_params: InitializedParams): Promise<void> {\n        // Initialize the workspace even if there are no workspace folders\n        // We still want to load additional documents (language library or similar) during initialization\n        return this.mutex.write(token => this.initializeWorkspace(this.folders ?? [], token));\n    }\n\n    async initializeWorkspace(folders: WorkspaceFolder[], cancelToken = CancellationToken.None): Promise<void> {\n        const documents = await this.performStartup(folders);\n        // Only after creating all documents do we check whether we need to cancel the initialization\n        // The document builder will later pick up on all unprocessed documents\n        await interruptAndCheck(cancelToken);\n        await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);\n    }\n\n    /**\n     * Performs the uninterruptable startup sequence of the workspace manager.\n     * This methods loads all documents in the workspace and other documents and returns them.\n     */\n    protected async performStartup(folders: WorkspaceFolder[]): Promise<LangiumDocument[]> {\n        const fileExtensions = this.serviceRegistry.all.flatMap(e => e.LanguageMetaData.fileExtensions);\n        const documents: LangiumDocument[] = [];\n        const collector = (document: LangiumDocument) => {\n            documents.push(document);\n            if (!this.langiumDocuments.hasDocument(document.uri)) {\n                this.langiumDocuments.addDocument(document);\n            }\n        };\n        // Even though we don't await the initialization of the workspace manager,\n        // we can still assume that all library documents and file documents are loaded by the time we start building documents.\n        // The mutex prevents anything from performing a workspace build until we check the cancellation token\n        await this.loadAdditionalDocuments(folders, collector);\n        await Promise.all(\n            folders.map(wf => [wf, this.getRootFolder(wf)] as [WorkspaceFolder, URI])\n                .map(async entry => this.traverseFolder(...entry, fileExtensions, collector))\n        );\n        this._ready.resolve();\n        return documents;\n    }\n\n    /**\n     * Load all additional documents that shall be visible in the context of the given workspace\n     * folders and add them to the collector. This can be used to include built-in libraries of\n     * your language, which can be either loaded from provided files or constructed in memory.\n     */\n    protected loadAdditionalDocuments(_folders: WorkspaceFolder[], _collector: (document: LangiumDocument) => void): Promise<void> {\n        return Promise.resolve();\n    }\n\n    /**\n     * Determine the root folder of the source documents in the given workspace folder.\n     * The default implementation returns the URI of the workspace folder, but you can override\n     * this to return a subfolder like `src` instead.\n     */\n    protected getRootFolder(workspaceFolder: WorkspaceFolder): URI {\n        return URI.parse(workspaceFolder.uri);\n    }\n\n    /**\n     * Traverse the file system folder identified by the given URI and its subfolders. All\n     * contained files that match the file extensions are added to the collector.\n     */\n    protected async traverseFolder(workspaceFolder: WorkspaceFolder, folderPath: URI, fileExtensions: string[], collector: (document: LangiumDocument) => void): Promise<void> {\n        const content = await this.fileSystemProvider.readDirectory(folderPath);\n        await Promise.all(content.map(async entry => {\n            if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {\n                if (entry.isDirectory) {\n                    await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);\n                } else if (entry.isFile) {\n                    const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);\n                    collector(document);\n                }\n            }\n        }));\n    }\n\n    /**\n     * Determine whether the given folder entry shall be included while indexing the workspace.\n     */\n    protected includeEntry(_workspaceFolder: WorkspaceFolder, entry: FileSystemNode, fileExtensions: string[]): boolean {\n        const name = UriUtils.basename(entry.uri);\n        if (name.startsWith('.')) {\n            return false;\n        }\n        if (entry.isDirectory) {\n            return name !== 'node_modules' && name !== 'out';\n        } else if (entry.isFile) {\n            const extname = UriUtils.extname(entry.uri);\n            return fileExtensions.includes(extname);\n        }\n        return false;\n    }\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7213, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7219, "column": 0}, "map": {"version":3,"file":"lexer.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/parser/lexer.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { ILexingError, IMultiModeLexerDefinition, IToken, TokenType, TokenTypeDictionary, TokenVocabulary } from 'chevrotain';\nimport type { LangiumCoreServices } from '../services.js';\nimport { Lexer as ChevrotainLexer } from 'chevrotain';\n\nexport interface LexerResult {\n    /**\n     * A list of all tokens that were lexed from the input.\n     *\n     * Note that Langium requires the optional properties\n     * `startLine`, `startColumn`, `endOffset`, `endLine` and `endColumn` to be set on each token.\n     */\n    tokens: IToken[];\n    /**\n     * Contains hidden tokens, usually comments.\n     */\n    hidden: IToken[];\n    errors: ILexingError[];\n}\n\nexport interface Lexer {\n    readonly definition: TokenTypeDictionary;\n    tokenize(text: string): LexerResult;\n}\n\nexport class DefaultLexer implements Lexer {\n\n    protected chevrotainLexer: ChevrotainLexer;\n    protected tokenTypes: TokenTypeDictionary;\n\n    constructor(services: LangiumCoreServices) {\n        const tokens = services.parser.TokenBuilder.buildTokens(services.Grammar, {\n            caseInsensitive: services.LanguageMetaData.caseInsensitive\n        });\n        this.tokenTypes = this.toTokenTypeDictionary(tokens);\n        const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;\n        this.chevrotainLexer = new ChevrotainLexer(lexerTokens, {\n            positionTracking: 'full'\n        });\n    }\n\n    get definition(): TokenTypeDictionary {\n        return this.tokenTypes;\n    }\n\n    tokenize(text: string): LexerResult {\n        const chevrotainResult = this.chevrotainLexer.tokenize(text);\n        return {\n            tokens: chevrotainResult.tokens,\n            errors: chevrotainResult.errors,\n            hidden: chevrotainResult.groups.hidden ?? []\n        };\n    }\n\n    protected toTokenTypeDictionary(buildTokens: TokenVocabulary): TokenTypeDictionary {\n        if (isTokenTypeDictionary(buildTokens)) return buildTokens;\n        const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;\n        const res: TokenTypeDictionary = {};\n        tokens.forEach(token => res[token.name] = token);\n        return res;\n    }\n}\n\n/**\n * Returns a check whether the given TokenVocabulary is TokenType array\n */\nexport function isTokenTypeArray(tokenVocabulary: TokenVocabulary): tokenVocabulary is TokenType[] {\n    return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || 'name' in tokenVocabulary[0]);\n}\n\n/**\n * Returns a check whether the given TokenVocabulary is IMultiModeLexerDefinition\n */\nexport function isIMultiModeLexerDefinition(tokenVocabulary: TokenVocabulary): tokenVocabulary is IMultiModeLexerDefinition {\n    return tokenVocabulary && 'modes' in tokenVocabulary && 'defaultMode' in tokenVocabulary;\n}\n\n/**\n * Returns a check whether the given TokenVocabulary is TokenTypeDictionary\n */\nexport function isTokenTypeDictionary(tokenVocabulary: TokenVocabulary): tokenVocabulary is TokenTypeDictionary {\n    return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;;;;AAIhF,OAAO,EAAE,KAAK,IAAI,eAAe,EAAE,MAAM,YAAY,CAAC;;AAsBhD,MAAO,YAAY;IAKrB,YAAY,QAA6B,CAAA;QACrC,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,YAAY,CAAC,WAAW,CAAC,QAAQ,CAAC,OAAO,EAAE;YACtE,eAAe,EAAE,QAAQ,CAAC,gBAAgB,CAAC,eAAe;SAC7D,CAAC,CAAC;QACH,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;QACrD,MAAM,WAAW,GAAG,qBAAqB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QACnF,IAAI,CAAC,eAAe,GAAG,gMAAI,QAAe,CAAC,WAAW,EAAE;YACpD,gBAAgB,EAAE,MAAM;SAC3B,CAAC,CAAC;IACP,CAAC;IAED,IAAI,UAAU,GAAA;QACV,OAAO,IAAI,CAAC,UAAU,CAAC;IAC3B,CAAC;IAED,QAAQ,CAAC,IAAY,EAAA;;QACjB,MAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC7D,OAAO;YACH,MAAM,EAAE,gBAAgB,CAAC,MAAM;YAC/B,MAAM,EAAE,gBAAgB,CAAC,MAAM;YAC/B,MAAM,EAAE,CAAA,KAAA,gBAAgB,CAAC,MAAM,CAAC,MAAM,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE;SAC/C,CAAC;IACN,CAAC;IAES,qBAAqB,CAAC,WAA4B,EAAA;QACxD,IAAI,qBAAqB,CAAC,WAAW,CAAC,EAAE,OAAO,WAAW,CAAC;QAC3D,MAAM,MAAM,GAAG,2BAA2B,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC;QAChH,MAAM,GAAG,GAAwB,CAAA,CAAE,CAAC;QACpC,MAAM,CAAC,OAAO,EAAC,KAAK,CAAC,EAAE,AAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;QACjD,OAAO,GAAG,CAAC;IACf,CAAC;CACJ;AAKK,SAAU,gBAAgB,CAAC,eAAgC;IAC7D,OAAO,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,KAAK,CAAC,IAAI,MAAM,IAAI,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5G,CAAC;AAKK,SAAU,2BAA2B,CAAC,eAAgC;IACxE,OAAO,eAAe,IAAI,OAAO,IAAI,eAAe,IAAI,aAAa,IAAI,eAAe,CAAC;AAC7F,CAAC;AAKK,SAAU,qBAAqB,CAAC,eAAgC;IAClE,OAAO,CAAC,gBAAgB,CAAC,eAAe,CAAC,IAAI,CAAC,2BAA2B,CAAC,eAAe,CAAC,CAAC;AAC/F,CAAC","ignoreList":[0]}},
    {"offset": {"line": 7272, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7278, "column": 0}, "map": {"version":3,"file":"jsdoc.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/documentation/jsdoc.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport { Position, Range } from 'vscode-languageserver-types';\nimport type { CstNode } from '../syntax-tree.js';\nimport { NEWLINE_REGEXP, escapeRegExp } from '../utils/regexp-utils.js';\nimport { URI } from '../utils/uri-utils.js';\n\nexport interface JSDocComment extends JSDocValue {\n    readonly elements: JSDocElement[]\n    getTag(name: string): JSDocTag | undefined\n    getTags(name: string): JSDocTag[]\n}\n\nexport type JSDocElement = JSDocParagraph | JSDocTag;\n\nexport type JSDocInline = JSDocTag | JSDocLine;\n\nexport interface JSDocValue {\n    /**\n     * Represents the range that this JSDoc element occupies.\n     * If the JSDoc was parsed from a `CstNode`, the range will represent the location in the source document.\n     */\n    readonly range: Range\n    /**\n     * Renders this JSDoc element to a plain text representation.\n     */\n    toString(): string\n    /**\n     * Renders this JSDoc element to a markdown representation.\n     *\n     * @param options Rendering options to customize the markdown result.\n     */\n    toMarkdown(options?: JSDocRenderOptions): string\n}\n\nexport interface JSDocParagraph extends JSDocValue {\n    readonly inlines: JSDocInline[]\n}\n\nexport interface JSDocLine extends JSDocValue {\n    readonly text: string\n}\n\nexport interface JSDocTag extends JSDocValue {\n    readonly name: string\n    readonly content: JSDocParagraph\n    readonly inline: boolean\n}\n\nexport interface JSDocParseOptions {\n    /**\n     * The start symbol of your comment format. Defaults to `/**`.\n     */\n    readonly start?: RegExp | string\n    /**\n     * The symbol that start a line of your comment format. Defaults to `*`.\n     */\n    readonly line?: RegExp | string\n    /**\n     * The end symbol of your comment format. Defaults to `*\\/`.\n     */\n    readonly end?: RegExp | string\n}\n\nexport interface JSDocRenderOptions {\n    /**\n     * Determines the style for rendering tags. Defaults to `italic`.\n     */\n    tag?: 'plain' | 'italic' | 'bold' | 'bold-italic'\n    /**\n     * Determines the default for rendering `@link` tags. Defaults to `plain`.\n     */\n    link?: 'code' | 'plain'\n    /**\n     * Custom tag rendering function.\n     * Return a markdown formatted tag or `undefined` to fall back to the default rendering.\n     */\n    renderTag?(tag: JSDocTag): string | undefined\n    /**\n     * Custom link rendering function. Accepts a link target and a display value for the link.\n     * Return a markdown formatted link with the format `[$display]($link)` or `undefined` if the link is not a valid target.\n     */\n    renderLink?(link: string, display: string): string | undefined\n}\n\n/**\n * Parses a JSDoc from a `CstNode` containing a comment.\n *\n * @param node A `CstNode` from a parsed Langium document.\n * @param options Parsing options specialized to your language. See {@link JSDocParseOptions}.\n */\nexport function parseJSDoc(node: CstNode, options?: JSDocParseOptions): JSDocComment;\n/**\n * Parses a JSDoc from a string comment.\n *\n * @param content A string containing the source of the JSDoc comment.\n * @param start The start position the comment occupies in the source document.\n * @param options Parsing options specialized to your language. See {@link JSDocParseOptions}.\n */\nexport function parseJSDoc(content: string, start?: Position, options?: JSDocParseOptions): JSDocComment;\nexport function parseJSDoc(node: CstNode | string, start?: Position | JSDocParseOptions, options?: JSDocParseOptions): JSDocComment {\n    let opts: JSDocParseOptions | undefined;\n    let position: Position | undefined;\n    if (typeof node === 'string') {\n        position = start as Position | undefined;\n        opts = options as JSDocParseOptions | undefined;\n    } else {\n        position = node.range.start;\n        opts = start as JSDocParseOptions | undefined;\n    }\n    if (!position) {\n        position = Position.create(0, 0);\n    }\n\n    const lines = getLines(node);\n    const normalizedOptions = normalizeOptions(opts);\n\n    const tokens = tokenize({\n        lines,\n        position,\n        options: normalizedOptions\n    });\n\n    return parseJSDocComment({\n        index: 0,\n        tokens,\n        position\n    });\n}\n\nexport function isJSDoc(node: CstNode | string, options?: JSDocParseOptions): boolean {\n    const normalizedOptions = normalizeOptions(options);\n    const lines = getLines(node);\n    if (lines.length === 0) {\n        return false;\n    }\n\n    const first = lines[0];\n    const last = lines[lines.length - 1];\n    const firstRegex = normalizedOptions.start;\n    const lastRegex = normalizedOptions.end;\n\n    return Boolean(firstRegex?.exec(first)) && Boolean(lastRegex?.exec(last));\n}\n\nfunction getLines(node: CstNode | string): string[] {\n    let content = '';\n    if (typeof node === 'string') {\n        content = node;\n    } else {\n        content = node.text;\n    }\n    const lines = content.split(NEWLINE_REGEXP);\n    return lines;\n}\n\n// Tokenization\n\ninterface JSDocToken {\n    type: 'text' | 'tag' | 'inline-tag' | 'break'\n    content: string\n    range: Range\n}\n\nconst tagRegex = /\\s*(@([\\p{L}][\\p{L}\\p{N}]*)?)/uy;\nconst inlineTagRegex = /\\{(@[\\p{L}][\\p{L}\\p{N}]*)(\\s*)([^\\r\\n}]+)?\\}/gu;\n\nfunction tokenize(context: TokenizationContext): JSDocToken[] {\n    const tokens: JSDocToken[] = [];\n    let currentLine = context.position.line;\n    let currentCharacter = context.position.character;\n    for (let i = 0; i < context.lines.length; i++) {\n        const first = i === 0;\n        const last = i === context.lines.length - 1;\n        let line = context.lines[i];\n        let index = 0;\n\n        if (first && context.options.start) {\n            const match = context.options.start?.exec(line);\n            if (match) {\n                index = match.index + match[0].length;\n            }\n        } else {\n            const match = context.options.line?.exec(line);\n            if (match) {\n                index = match.index + match[0].length;\n            }\n        }\n        if (last) {\n            const match = context.options.end?.exec(line);\n            if (match) {\n                line = line.substring(0, match.index);\n            }\n        }\n\n        line = line.substring(0, lastCharacter(line));\n        const whitespaceEnd = skipWhitespace(line, index);\n\n        if (whitespaceEnd >= line.length) {\n            // Only create a break token when we already have previous tokens\n            if (tokens.length > 0) {\n                const position = Position.create(currentLine, currentCharacter);\n                tokens.push({\n                    type: 'break',\n                    content: '',\n                    range: Range.create(position, position)\n                });\n            }\n        } else {\n            tagRegex.lastIndex = index;\n            const tagMatch = tagRegex.exec(line);\n            if (tagMatch) {\n                const fullMatch = tagMatch[0];\n                const value = tagMatch[1];\n                const start = Position.create(currentLine, currentCharacter + index);\n                const end = Position.create(currentLine, currentCharacter + index + fullMatch.length);\n                tokens.push({\n                    type: 'tag',\n                    content: value,\n                    range: Range.create(start, end)\n                });\n                index += fullMatch.length;\n                index = skipWhitespace(line, index);\n            }\n\n            if (index < line.length) {\n                const rest = line.substring(index);\n                const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));\n                tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));\n            }\n        }\n\n        currentLine++;\n        currentCharacter = 0;\n    }\n\n    // Remove last break token if there is one\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === 'break') {\n        return tokens.slice(0, -1);\n    }\n\n    return tokens;\n}\n\nfunction buildInlineTokens(tags: RegExpMatchArray[], line: string, lineIndex: number, characterIndex: number): JSDocToken[] {\n    const tokens: JSDocToken[] = [];\n\n    if (tags.length === 0) {\n        const start = Position.create(lineIndex, characterIndex);\n        const end = Position.create(lineIndex, characterIndex + line.length);\n        tokens.push({\n            type: 'text',\n            content: line,\n            range: Range.create(start, end)\n        });\n    } else {\n        let lastIndex = 0;\n        for (const match of tags) {\n            const matchIndex = match.index!;\n            const startContent = line.substring(lastIndex, matchIndex);\n            if (startContent.length > 0) {\n                tokens.push({\n                    type: 'text',\n                    content: line.substring(lastIndex, matchIndex),\n                    range: Range.create(\n                        Position.create(lineIndex, lastIndex + characterIndex),\n                        Position.create(lineIndex, matchIndex + characterIndex)\n                    )\n                });\n            }\n            let offset = startContent.length + 1;\n            const tagName = match[1];\n            tokens.push({\n                type: 'inline-tag',\n                content: tagName,\n                range: Range.create(\n                    Position.create(lineIndex, lastIndex + offset + characterIndex),\n                    Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex)\n                )\n            });\n            offset += tagName.length;\n            if (match.length === 4) {\n                offset += match[2].length;\n                const value = match[3];\n                tokens.push({\n                    type: 'text',\n                    content: value,\n                    range: Range.create(\n                        Position.create(lineIndex, lastIndex + offset + characterIndex),\n                        Position.create(lineIndex, lastIndex + offset + value.length + characterIndex)\n                    )\n                });\n            } else {\n                tokens.push({\n                    type: 'text',\n                    content: '',\n                    range: Range.create(\n                        Position.create(lineIndex, lastIndex + offset + characterIndex),\n                        Position.create(lineIndex, lastIndex + offset + characterIndex)\n                    )\n                });\n            }\n            lastIndex = matchIndex + match[0].length;\n        }\n        const endContent = line.substring(lastIndex);\n        if (endContent.length > 0) {\n            tokens.push({\n                type: 'text',\n                content: endContent,\n                range: Range.create(\n                    Position.create(lineIndex, lastIndex + characterIndex),\n                    Position.create(lineIndex, lastIndex + characterIndex + endContent.length)\n                )\n            });\n        }\n    }\n\n    return tokens;\n}\n\nconst nonWhitespaceRegex = /\\S/;\nconst whitespaceEndRegex = /\\s*$/;\n\nfunction skipWhitespace(line: string, index: number): number {\n    const match = line.substring(index).match(nonWhitespaceRegex);\n    if (match) {\n        return index + match.index!;\n    } else {\n        return line.length;\n    }\n}\n\nfunction lastCharacter(line: string): number | undefined {\n    const match = line.match(whitespaceEndRegex);\n    if (match && typeof match.index === 'number') {\n        return match.index;\n    }\n    return undefined;\n}\n\n// Parsing\n\nfunction parseJSDocComment(context: ParseContext): JSDocComment {\n    const startPosition: Position = Position.create(context.position.line, context.position.character);\n    if (context.tokens.length === 0) {\n        return new JSDocCommentImpl([], Range.create(startPosition, startPosition));\n    }\n    const elements: JSDocElement[] = [];\n    while (context.index < context.tokens.length) {\n        const element = parseJSDocElement(context, elements[elements.length - 1]);\n        if (element) {\n            elements.push(element);\n        }\n    }\n    const start = elements[0]?.range.start ?? startPosition;\n    const end = elements[elements.length - 1]?.range.end ?? startPosition;\n    return new JSDocCommentImpl(elements, Range.create(start, end));\n}\n\nfunction parseJSDocElement(context: ParseContext, last?: JSDocElement): JSDocElement | undefined {\n    const next = context.tokens[context.index];\n    if (next.type === 'tag') {\n        return parseJSDocTag(context, false);\n    } else if (next.type === 'text' || next.type === 'inline-tag') {\n        return parseJSDocText(context);\n    } else {\n        appendEmptyLine(next, last);\n        context.index++;\n        return undefined;\n    }\n}\n\nfunction appendEmptyLine(token: JSDocToken, element?: JSDocElement): void {\n    if (element) {\n        const line = new JSDocLineImpl('', token.range);\n        if ('inlines' in element) {\n            element.inlines.push(line);\n        } else {\n            element.content.inlines.push(line);\n        }\n    }\n}\n\nfunction parseJSDocText(context: ParseContext): JSDocParagraph {\n    let token = context.tokens[context.index];\n    const firstToken = token;\n    let lastToken = token;\n    const lines: JSDocInline[] = [];\n    while (token && token.type !== 'break' && token.type !== 'tag') {\n        lines.push(parseJSDocInline(context));\n        lastToken = token;\n        token = context.tokens[context.index];\n    }\n    return new JSDocTextImpl(lines, Range.create(firstToken.range.start, lastToken.range.end));\n}\n\nfunction parseJSDocInline(context: ParseContext): JSDocInline {\n    const token = context.tokens[context.index];\n    if (token.type === 'inline-tag') {\n        return parseJSDocTag(context, true);\n    } else {\n        return parseJSDocLine(context);\n    }\n}\n\nfunction parseJSDocTag(context: ParseContext, inline: boolean): JSDocTag {\n    const tagToken = context.tokens[context.index++];\n    const name = tagToken.content.substring(1);\n    const nextToken = context.tokens[context.index];\n    if (nextToken?.type === 'text') {\n        if (inline) {\n            const docLine = parseJSDocLine(context);\n            return new JSDocTagImpl(\n                name,\n                new JSDocTextImpl([docLine], docLine.range),\n                inline,\n                Range.create(tagToken.range.start, docLine.range.end)\n            );\n        } else {\n            const textDoc = parseJSDocText(context);\n            return new JSDocTagImpl(\n                name,\n                textDoc,\n                inline,\n                Range.create(tagToken.range.start, textDoc.range.end)\n            );\n        }\n    } else {\n        const range = tagToken.range;\n        return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);\n    }\n}\n\nfunction parseJSDocLine(context: ParseContext): JSDocLine {\n    const token = context.tokens[context.index++];\n    return new JSDocLineImpl(token.content, token.range);\n}\n\ninterface NormalizedOptions {\n    start?: RegExp\n    end?: RegExp\n    line?: RegExp\n}\n\ninterface TokenizationContext {\n    position: Position\n    lines: string[]\n    options: NormalizedOptions\n}\n\ninterface ParseContext {\n    position: Position\n    tokens: JSDocToken[]\n    index: number\n}\n\nfunction normalizeOptions(options?: JSDocParseOptions): NormalizedOptions {\n    if (!options) {\n        return normalizeOptions({\n            start: '/**',\n            end: '*/',\n            line: '*'\n        });\n    }\n    const { start, end, line } = options;\n    return {\n        start: normalizeOption(start, true),\n        end: normalizeOption(end, false),\n        line: normalizeOption(line, true)\n    };\n}\n\nfunction normalizeOption(option: RegExp | string | undefined, start: boolean): RegExp | undefined {\n    if (typeof option === 'string' || typeof option === 'object') {\n        const escaped = typeof option === 'string' ? escapeRegExp(option) : option.source;\n        if (start) {\n            return new RegExp(`^\\\\s*${escaped}`);\n        } else {\n            return new RegExp(`\\\\s*${escaped}\\\\s*$`);\n        }\n    } else {\n        return option;\n    }\n}\n\nclass JSDocCommentImpl implements JSDocComment {\n\n    readonly elements: JSDocElement[];\n    readonly range: Range;\n\n    constructor(elements: JSDocElement[], range: Range) {\n        this.elements = elements;\n        this.range = range;\n    }\n\n    getTag(name: string): JSDocTag | undefined {\n        return this.getAllTags().find(e => e.name === name);\n    }\n\n    getTags(name: string): JSDocTag[] {\n        return this.getAllTags().filter(e => e.name === name);\n    }\n\n    private getAllTags(): JSDocTag[] {\n        return this.elements.filter((e): e is JSDocTag => 'name' in e);\n    }\n\n    toString(): string {\n        let value = '';\n        for (const element of this.elements) {\n            if (value.length === 0) {\n                value = element.toString();\n            } else {\n                const text = element.toString();\n                value += fillNewlines(value) + text;\n            }\n        }\n        return value.trim();\n    }\n\n    toMarkdown(options?: JSDocRenderOptions): string {\n        let value = '';\n        for (const element of this.elements) {\n            if (value.length === 0) {\n                value = element.toMarkdown(options);\n            } else {\n                const text = element.toMarkdown(options);\n                value += fillNewlines(value) + text;\n            }\n        }\n        return value.trim();\n    }\n}\n\nclass JSDocTagImpl implements JSDocTag {\n    name: string;\n    content: JSDocParagraph;\n    range: Range;\n    inline: boolean;\n\n    constructor(name: string, content: JSDocParagraph, inline: boolean, range: Range) {\n        this.name = name;\n        this.content = content;\n        this.inline = inline;\n        this.range = range;\n    }\n\n    toString(): string {\n        let text = `@${this.name}`;\n        const content = this.content.toString();\n        if (this.content.inlines.length === 1) {\n            text = `${text} ${content}`;\n        } else if (this.content.inlines.length > 1) {\n            text = `${text}\\n${content}`;\n        }\n        if (this.inline) {\n            // Inline tags are surrounded by curly braces\n            return `{${text}}`;\n        } else {\n            return text;\n        }\n    }\n\n    toMarkdown(options?: JSDocRenderOptions): string {\n        return options?.renderTag?.(this) ?? this.toMarkdownDefault(options);\n    }\n\n    private toMarkdownDefault(options?: JSDocRenderOptions): string {\n        const content = this.content.toMarkdown(options);\n        if (this.inline) {\n            const rendered = renderInlineTag(this.name, content, options ?? {});\n            if (typeof rendered === 'string') {\n                return rendered;\n            }\n        }\n        let marker = '';\n        if (options?.tag === 'italic' || options?.tag === undefined) {\n            marker = '*';\n        } else if (options?.tag === 'bold') {\n            marker = '**';\n        } else if (options?.tag === 'bold-italic') {\n            marker = '***';\n        }\n        let text = `${marker}@${this.name}${marker}`;\n        if (this.content.inlines.length === 1) {\n            text = `${text}  ${content}`;\n        } else if (this.content.inlines.length > 1) {\n            text = `${text}\\n${content}`;\n        }\n        if (this.inline) {\n            // Inline tags are surrounded by curly braces\n            return `{${text}}`;\n        } else {\n            return text;\n        }\n    }\n}\n\nfunction renderInlineTag(tag: string, content: string, options: JSDocRenderOptions): string | undefined {\n    if (tag === 'linkplain' || tag === 'linkcode' || tag === 'link') {\n        const index = content.indexOf(' ');\n        let display = content;\n        if (index > 0) {\n            const displayStart = skipWhitespace(content, index);\n            display = content.substring(displayStart);\n            content = content.substring(0, index);\n        }\n        if (tag === 'linkcode' || (tag === 'link' && options.link === 'code')) {\n            // Surround the display value in a markdown inline code block\n            display = `\\`${display}\\``;\n        }\n        const renderedLink = options.renderLink?.(content, display) ?? renderLinkDefault(content, display);\n        return renderedLink;\n    }\n    return undefined;\n}\n\nfunction renderLinkDefault(content: string, display: string): string {\n    try {\n        URI.parse(content, true);\n        return `[${display}](${content})`;\n    } catch {\n        return content;\n    }\n}\n\nclass JSDocTextImpl implements JSDocParagraph {\n    inlines: JSDocInline[];\n    range: Range;\n\n    constructor(lines: JSDocInline[], range: Range) {\n        this.inlines = lines;\n        this.range = range;\n    }\n\n    toString(): string {\n        let text = '';\n        for (let i = 0; i < this.inlines.length; i++) {\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toString();\n            if (next && next.range.start.line > inline.range.start.line) {\n                text += '\\n';\n            }\n        }\n        return text;\n    }\n\n    toMarkdown(options?: JSDocRenderOptions): string {\n        let text = '';\n        for (let i = 0; i < this.inlines.length; i++) {\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toMarkdown(options);\n            if (next && next.range.start.line > inline.range.start.line) {\n                text += '\\n';\n            }\n        }\n        return text;\n    }\n}\n\nclass JSDocLineImpl implements JSDocLine {\n    text: string;\n    range: Range;\n\n    constructor(text: string, range: Range) {\n        this.text = text;\n        this.range = range;\n    }\n\n    toString(): string {\n        return this.text;\n    }\n    toMarkdown(): string {\n        return this.text;\n    }\n\n}\n\nfunction fillNewlines(text: string): string {\n    if (text.endsWith('\\n')) {\n        return '\\n';\n    } else {\n        return '\\n\\n';\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7769, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7775, "column": 0}, "map": {"version":3,"file":"documentation-provider.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/documentation/documentation-provider.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { LangiumCoreServices } from '../services.js';\nimport type { AstNode, AstNodeDescription } from '../syntax-tree.js';\nimport type { IndexManager } from '../workspace/index-manager.js';\nimport type { CommentProvider } from './comment-provider.js';\nimport type { JSDocTag } from './jsdoc.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { isJSDoc, parseJSDoc } from './jsdoc.js';\n\n/**\n * Provides documentation for AST nodes.\n */\nexport interface DocumentationProvider {\n    /**\n     * Returns a markdown documentation string for the specified AST node.\n     *\n     * The default implementation `JSDocDocumentationProvider` will inspect the comment associated with the specified node.\n     */\n    getDocumentation(node: AstNode): string | undefined;\n}\n\nexport class JSDocDocumentationProvider implements DocumentationProvider {\n\n    protected readonly indexManager: IndexManager;\n    protected readonly commentProvider: CommentProvider;\n\n    constructor(services: LangiumCoreServices) {\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n\n    getDocumentation(node: AstNode): string | undefined {\n        const comment = this.commentProvider.getComment(node);\n        if (comment && isJSDoc(comment)) {\n            const parsedJSDoc = parseJSDoc(comment);\n            return parsedJSDoc.toMarkdown({\n                renderLink: (link, display) => {\n                    return this.documentationLinkRenderer(node, link, display);\n                },\n                renderTag: (tag) => {\n                    return this.documentationTagRenderer(node, tag);\n                }\n            });\n        }\n        return undefined;\n    }\n\n    protected documentationLinkRenderer(node: AstNode, name: string, display: string): string | undefined {\n        const description = this.findNameInPrecomputedScopes(node, name) ?? this.findNameInGlobalScope(node, name);\n        if (description && description.nameSegment) {\n            const line = description.nameSegment.range.start.line + 1;\n            const character = description.nameSegment.range.start.character + 1;\n            const uri = description.documentUri.with({ fragment: `L${line},${character}` });\n            return `[${display}](${uri.toString()})`;\n        } else {\n            return undefined;\n        }\n    }\n\n    protected documentationTagRenderer(_node: AstNode, _tag: JSDocTag): string | undefined {\n        // Fall back to the default tag rendering\n        return undefined;\n    }\n\n    protected findNameInPrecomputedScopes(node: AstNode, name: string): AstNodeDescription | undefined {\n        const document = getDocument(node);\n        const precomputed = document.precomputedScopes;\n        if (!precomputed) {\n            return undefined;\n        }\n        let currentNode: AstNode | undefined = node;\n        do {\n            const allDescriptions = precomputed.get(currentNode);\n            const description = allDescriptions.find(e => e.name === name);\n            if (description) {\n                return description;\n            }\n            currentNode = currentNode.$container;\n        } while (currentNode);\n\n        return undefined;\n    }\n\n    protected findNameInGlobalScope(node: AstNode, name: string): AstNodeDescription | undefined {\n        const description = this.indexManager.allElements().find(e => e.name === name);\n        return description;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;AAOhF,OAAO,EAAE,WAAW,EAAE,MAAM,uBAAuB,CAAC;AACpD,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,MAAM,YAAY,CAAC;;;AAc3C,MAAO,0BAA0B;IAKnC,YAAY,QAA6B,CAAA;QACrC,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,YAAY,CAAC;QAC3D,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC,aAAa,CAAC,eAAe,CAAC;IAClE,CAAC;IAED,gBAAgB,CAAC,IAAa,EAAA;QAC1B,MAAM,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACtD,IAAI,OAAO,QAAI,8LAAA,AAAO,EAAC,OAAO,CAAC,EAAE;YAC7B,MAAM,WAAW,2LAAG,aAAA,AAAU,EAAC,OAAO,CAAC,CAAC;YACxC,OAAO,WAAW,CAAC,UAAU,CAAC;gBAC1B,UAAU,EAAE,CAAC,IAAI,EAAE,OAAO,EAAE,EAAE;oBAC1B,OAAO,IAAI,CAAC,yBAAyB,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;gBAC/D,CAAC;gBACD,SAAS,EAAE,CAAC,GAAG,EAAE,EAAE;oBACf,OAAO,IAAI,CAAC,wBAAwB,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;gBACpD,CAAC;aACJ,CAAC,CAAC;SACN;QACD,OAAO,SAAS,CAAC;IACrB,CAAC;IAES,yBAAyB,CAAC,IAAa,EAAE,IAAY,EAAE,OAAe,EAAA;;QAC5E,MAAM,WAAW,GAAG,CAAA,KAAA,IAAI,CAAC,2BAA2B,CAAC,IAAI,EAAE,IAAI,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAC3G,IAAI,WAAW,IAAI,WAAW,CAAC,WAAW,EAAE;YACxC,MAAM,IAAI,GAAG,WAAW,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC;YAC1D,MAAM,SAAS,GAAG,WAAW,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC;YACpE,MAAM,GAAG,GAAG,WAAW,CAAC,WAAW,CAAC,IAAI,CAAC;gBAAE,QAAQ,EAAE,CAAA,CAAA,EAAI,IAAI,CAAA,CAAA,EAAI,SAAS,EAAE;YAAA,CAAE,CAAC,CAAC;YAChF,OAAO,CAAA,CAAA,EAAI,OAAO,CAAA,EAAA,EAAK,GAAG,CAAC,QAAQ,EAAE,CAAA,CAAA,CAAG,CAAC;SAC5C,MAAM;YACH,OAAO,SAAS,CAAC;SACpB;IACL,CAAC;IAES,wBAAwB,CAAC,KAAc,EAAE,IAAc,EAAA;QAC7D,yCAAyC;QACzC,OAAO,SAAS,CAAC;IACrB,CAAC;IAES,2BAA2B,CAAC,IAAa,EAAE,IAAY,EAAA;QAC7D,MAAM,QAAQ,0LAAG,cAAA,AAAW,EAAC,IAAI,CAAC,CAAC;QACnC,MAAM,WAAW,GAAG,QAAQ,CAAC,iBAAiB,CAAC;QAC/C,IAAI,CAAC,WAAW,EAAE;YACd,OAAO,SAAS,CAAC;SACpB;QACD,IAAI,WAAW,GAAwB,IAAI,CAAC;QAC5C,GAAG;YACC,MAAM,eAAe,GAAG,WAAW,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;YACrD,MAAM,WAAW,GAAG,eAAe,CAAC,IAAI,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;YAC/D,IAAI,WAAW,EAAE;gBACb,OAAO,WAAW,CAAC;aACtB;YACD,WAAW,GAAG,WAAW,CAAC,UAAU,CAAC;SACxC,OAAQ,WAAW,CAAE;QAEtB,OAAO,SAAS,CAAC;IACrB,CAAC;IAES,qBAAqB,CAAC,IAAa,EAAE,IAAY,EAAA;QACvD,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,CAAC,IAAI,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;QAC/E,OAAO,WAAW,CAAC;IACvB,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 7846, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7852, "column": 0}, "map": {"version":3,"file":"comment-provider.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/documentation/comment-provider.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { GrammarConfig } from '../languages/grammar-config.js';\nimport { isAstNodeWithComment } from '../serializer/json-serializer.js';\nimport type { LangiumCoreServices } from '../services.js';\nimport type { AstNode } from '../syntax-tree.js';\nimport { findCommentNode } from '../utils/cst-utils.js';\n\n/**\n * Provides comments for AST nodes.\n */\nexport interface CommentProvider {\n    /**\n     * Returns the comment associated with the specified AST node.\n     * @param node The AST node to get the comment for.\n     * @returns The comment associated with the specified AST node or `undefined` if there is no comment.\n     */\n    getComment(node: AstNode): string | undefined;\n}\n\nexport class DefaultCommentProvider implements CommentProvider {\n    protected readonly grammarConfig: () => GrammarConfig;\n    constructor(services: LangiumCoreServices) {\n        this.grammarConfig = () => services.parser.GrammarConfig;\n    }\n    getComment(node: AstNode): string | undefined {\n        if(isAstNodeWithComment(node)) {\n            return node.$comment;\n        }\n        return findCommentNode(node.$cstNode, this.grammarConfig().multilineCommentRules)?.text;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;AAGhF,OAAO,EAAE,oBAAoB,EAAE,MAAM,kCAAkC,CAAC;AAGxE,OAAO,EAAE,eAAe,EAAE,MAAM,uBAAuB,CAAC;;;AAclD,MAAO,sBAAsB;IAE/B,YAAY,QAA6B,CAAA;QACrC,IAAI,CAAC,aAAa,GAAG,GAAG,CAAG,CAAD,OAAS,CAAC,MAAM,CAAC,aAAa,CAAC;IAC7D,CAAC;IACD,UAAU,CAAC,IAAa,EAAA;;QACpB,sMAAG,uBAAA,AAAoB,EAAC,IAAI,CAAC,EAAE;YAC3B,OAAO,IAAI,CAAC,QAAQ,CAAC;SACxB;QACD,OAAO,CAAA,4LAAA,kBAAA,AAAe,EAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,aAAa,EAAE,CAAC,qBAAqB,CAAC,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,IAAI,CAAC;IAC5F,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 7875, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7881, "column": 0}, "map": {"version":3,"file":"event.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/event.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2024 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n// eslint-disable-next-line no-restricted-imports\nexport * from 'vscode-jsonrpc/lib/common/events.js';\n"],"names":[],"mappings":"AAAA;;;;gFAIgF,CAEhF,iDAAiD","ignoreList":[0]}},
    {"offset": {"line": 7889, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7904, "column": 0}, "map": {"version":3,"file":"async-parser.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/parser/async-parser.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { CancellationToken } from '../utils/cancellation.js';\nimport type { LangiumCoreServices } from '../services.js';\nimport type { AstNode } from '../syntax-tree.js';\nimport type { LangiumParser, ParseResult } from './langium-parser.js';\nimport type { Hydrator } from '../serializer/hydrator.js';\nimport type { Event } from '../utils/event.js';\nimport { Deferred, OperationCancelled } from '../utils/promise-utils.js';\nimport { Emitter } from '../utils/event.js';\n\n/**\n * Async parser that allows to cancel the current parsing process.\n * The sync parser implementation is blocking the event loop, which can become quite problematic for large files.\n *\n * Note that the default implementation is not actually async. It just wraps the sync parser in a promise.\n * A real implementation would create worker threads or web workers to offload the parsing work.\n */\nexport interface AsyncParser {\n    parse<T extends AstNode>(text: string, cancelToken: CancellationToken): Promise<ParseResult<T>>;\n}\n\n/**\n * Default implementation of the async parser. This implementation only wraps the sync parser in a promise.\n *\n * A real implementation would create worker threads or web workers to offload the parsing work.\n */\nexport class DefaultAsyncParser implements AsyncParser {\n\n    protected readonly syncParser: LangiumParser;\n\n    constructor(services: LangiumCoreServices) {\n        this.syncParser = services.parser.LangiumParser;\n    }\n\n    parse<T extends AstNode>(text: string): Promise<ParseResult<T>> {\n        return Promise.resolve(this.syncParser.parse<T>(text));\n    }\n}\n\nexport abstract class AbstractThreadedAsyncParser implements AsyncParser {\n\n    /**\n     * The thread count determines how many threads are used to parse files in parallel.\n     * The default value is 8. Decreasing this value increases startup performance, but decreases parallel parsing performance.\n     */\n    protected threadCount = 8;\n    /**\n     * The termination delay determines how long the parser waits for a thread to finish after a cancellation request.\n     * The default value is 200(ms).\n     */\n    protected terminationDelay = 200;\n    protected workerPool: ParserWorker[] = [];\n    protected queue: Array<Deferred<ParserWorker>> = [];\n\n    protected readonly hydrator: Hydrator;\n\n    constructor(services: LangiumCoreServices) {\n        this.hydrator = services.serializer.Hydrator;\n    }\n\n    protected initializeWorkers(): void {\n        while (this.workerPool.length < this.threadCount) {\n            const worker = this.createWorker();\n            worker.onReady(() => {\n                if (this.queue.length > 0) {\n                    const deferred = this.queue.shift();\n                    if (deferred) {\n                        worker.lock();\n                        deferred.resolve(worker);\n                    }\n                }\n            });\n            this.workerPool.push(worker);\n        }\n    }\n\n    async parse<T extends AstNode>(text: string, cancelToken: CancellationToken): Promise<ParseResult<T>> {\n        const worker = await this.acquireParserWorker(cancelToken);\n        const deferred = new Deferred<ParseResult<T>>();\n        let timeout: NodeJS.Timeout | undefined;\n        // If the cancellation token is requested, we wait for a certain time before terminating the worker.\n        // Since the cancellation token lives longer than the parsing process, we need to dispose the event listener.\n        // Otherwise, we might accidentally terminate the worker after the parsing process has finished.\n        const cancellation = cancelToken.onCancellationRequested(() => {\n            timeout = setTimeout(() => {\n                this.terminateWorker(worker);\n            }, this.terminationDelay);\n        });\n        worker.parse(text).then(result => {\n            const hydrated = this.hydrator.hydrate<T>(result);\n            deferred.resolve(hydrated);\n        }).catch(err => {\n            deferred.reject(err);\n        }).finally(() => {\n            cancellation.dispose();\n            clearTimeout(timeout);\n        });\n        return deferred.promise;\n    }\n\n    protected terminateWorker(worker: ParserWorker): void {\n        worker.terminate();\n        const index = this.workerPool.indexOf(worker);\n        if (index >= 0) {\n            this.workerPool.splice(index, 1);\n        }\n    }\n\n    protected async acquireParserWorker(cancelToken: CancellationToken): Promise<ParserWorker> {\n        this.initializeWorkers();\n        for (const worker of this.workerPool) {\n            if (worker.ready) {\n                worker.lock();\n                return worker;\n            }\n        }\n        const deferred = new Deferred<ParserWorker>();\n        cancelToken.onCancellationRequested(() => {\n            const index = this.queue.indexOf(deferred);\n            if (index >= 0) {\n                this.queue.splice(index, 1);\n            }\n            deferred.reject(OperationCancelled);\n        });\n        this.queue.push(deferred);\n        return deferred.promise;\n    }\n\n    protected abstract createWorker(): ParserWorker;\n}\n\nexport type WorkerMessagePost = (message: unknown) => void;\nexport type WorkerMessageCallback = (cb: (message: unknown) => void) => void;\n\nexport class ParserWorker {\n\n    protected readonly sendMessage: WorkerMessagePost;\n    protected readonly _terminate: () => void;\n    protected readonly onReadyEmitter = new Emitter<void>();\n\n    protected deferred = new Deferred<ParseResult>();\n    protected _ready = true;\n    protected _parsing = false;\n\n    get ready(): boolean {\n        return this._ready;\n    }\n\n    get onReady(): Event<void> {\n        return this.onReadyEmitter.event;\n    }\n\n    constructor(sendMessage: WorkerMessagePost, onMessage: WorkerMessageCallback, onError: WorkerMessageCallback, terminate: () => void) {\n        this.sendMessage = sendMessage;\n        this._terminate = terminate;\n        onMessage(result => {\n            const parseResult = result as ParseResult;\n            this.deferred.resolve(parseResult);\n            this.unlock();\n        });\n        onError(error => {\n            this.deferred.reject(error);\n            this.unlock();\n        });\n    }\n\n    terminate(): void {\n        this.deferred.reject(OperationCancelled);\n        this._terminate();\n    }\n\n    lock(): void {\n        this._ready = false;\n    }\n\n    unlock(): void {\n        this._parsing = false;\n        this._ready = true;\n        this.onReadyEmitter.fire();\n    }\n\n    parse(text: string): Promise<ParseResult> {\n        if (this._parsing) {\n            throw new Error('Parser worker is busy');\n        }\n        this._parsing = true;\n        this.deferred = new Deferred();\n        this.sendMessage(text);\n        return this.deferred.promise;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8051, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8057, "column": 0}, "map": {"version":3,"file":"workspace-lock.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/workspace/workspace-lock.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport { CancellationToken, CancellationTokenSource } from '../utils/cancellation.js';\nimport { Deferred, isOperationCancelled, type MaybePromise } from '../utils/promise-utils.js';\n\n/**\n * Utility service to execute mutually exclusive actions.\n */\nexport interface WorkspaceLock {\n    /**\n     * Performs a single async action, like initializing the workspace or processing document changes.\n     * Only one action will be executed at a time.\n     *\n     * When another action is queued up, the token provided for the action will be cancelled.\n     * Assuming the action makes use of this token, the next action only has to wait for the current action to finish cancellation.\n     */\n    write(action: (token: CancellationToken) => MaybePromise<void>): Promise<void>;\n\n    /**\n     * Performs a single action, like computing completion results or providing workspace symbols.\n     * Read actions will only be executed after all write actions have finished. They will be executed in parallel if possible.\n     *\n     * If a write action is currently running, the read action will be queued up and executed afterwards.\n     * If a new write action is queued up while a read action is waiting, the write action will receive priority and will be handled before the read action.\n     *\n     * Note that read actions are not allowed to modify anything in the workspace. Please use {@link write} instead.\n     */\n    read<T>(action: () => MaybePromise<T>): Promise<T>;\n\n    /**\n     * Cancels the last queued write action. All previous write actions already have been cancelled.\n     */\n    cancelWrite(): void;\n}\n\ntype LockAction<T = void> = (token: CancellationToken) => MaybePromise<T>;\n\ninterface LockEntry {\n    action: LockAction<unknown>;\n    deferred: Deferred<unknown>;\n    cancellationToken: CancellationToken;\n}\n\nexport class DefaultWorkspaceLock implements WorkspaceLock {\n\n    private previousTokenSource = new CancellationTokenSource();\n    private writeQueue: LockEntry[] = [];\n    private readQueue: LockEntry[] = [];\n    private done = true;\n\n    write(action: (token: CancellationToken) => MaybePromise<void>): Promise<void> {\n        this.cancelWrite();\n        const tokenSource = new CancellationTokenSource();\n        this.previousTokenSource = tokenSource;\n        return this.enqueue(this.writeQueue, action, tokenSource.token);\n    }\n\n    read<T>(action: () => MaybePromise<T>): Promise<T> {\n        return this.enqueue(this.readQueue, action);\n    }\n\n    private enqueue<T = void>(queue: LockEntry[], action: LockAction<T>, cancellationToken?: CancellationToken): Promise<T> {\n        const deferred = new Deferred<unknown>();\n        const entry: LockEntry = {\n            action,\n            deferred,\n            cancellationToken: cancellationToken ?? CancellationToken.None\n        };\n        queue.push(entry);\n        this.performNextOperation();\n        return deferred.promise as Promise<T>;\n    }\n\n    private async performNextOperation(): Promise<void> {\n        if (!this.done) {\n            return;\n        }\n        const entries: LockEntry[] = [];\n        if (this.writeQueue.length > 0) {\n            // Just perform the next write action\n            entries.push(this.writeQueue.shift()!);\n        } else if (this.readQueue.length > 0) {\n            // Empty the read queue and perform all actions in parallel\n            entries.push(...this.readQueue.splice(0, this.readQueue.length));\n        } else {\n            return;\n        }\n        this.done = false;\n        await Promise.all(entries.map(async ({ action, deferred, cancellationToken }) => {\n            try {\n                // Move the execution of the action to the next event loop tick via `Promise.resolve()`\n                const result = await Promise.resolve().then(() => action(cancellationToken));\n                deferred.resolve(result);\n            } catch (err) {\n                if (isOperationCancelled(err)) {\n                    // If the operation was cancelled, we don't want to reject the promise\n                    deferred.resolve(undefined);\n                } else {\n                    deferred.reject(err);\n                }\n            }\n        }));\n        this.done = true;\n        this.performNextOperation();\n    }\n\n    cancelWrite(): void {\n        this.previousTokenSource.cancel();\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;AAEhF,OAAO,EAAE,iBAAiB,EAAE,uBAAuB,EAAE,MAAM,0BAA0B,CAAC;AACtF,OAAO,EAAE,QAAQ,EAAE,oBAAoB,EAAqB,MAAM,2BAA2B,CAAC;;;;AAwCxF,MAAO,oBAAoB;IAAjC,aAAA;QAEY,IAAA,CAAA,mBAAmB,GAAG,kMAAI,0BAAuB,EAAE,CAAC;QACpD,IAAA,CAAA,UAAU,GAAgB,EAAE,CAAC;QAC7B,IAAA,CAAA,SAAS,GAAgB,EAAE,CAAC;QAC5B,IAAA,CAAA,IAAI,GAAG,IAAI,CAAC;IA6DxB,CAAC;IA3DG,KAAK,CAAC,MAAwD,EAAA;QAC1D,IAAI,CAAC,WAAW,EAAE,CAAC;QACnB,MAAM,WAAW,GAAG,kMAAI,0BAAuB,EAAE,CAAC;QAClD,IAAI,CAAC,mBAAmB,GAAG,WAAW,CAAC;QACvC,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,EAAE,MAAM,EAAE,WAAW,CAAC,KAAK,CAAC,CAAC;IACpE,CAAC;IAED,IAAI,CAAI,MAA6B,EAAA;QACjC,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;IAChD,CAAC;IAEO,OAAO,CAAW,KAAkB,EAAE,MAAqB,EAAE,iBAAqC,EAAA;QACtG,MAAM,QAAQ,GAAG,2LAAI,WAAQ,EAAW,CAAC;QACzC,MAAM,KAAK,GAAc;YACrB,MAAM;YACN,QAAQ;YACR,iBAAiB,EAAE,iBAAiB,KAAA,QAAjB,iBAAiB,KAAA,KAAA,IAAjB,iBAAiB,iMAAI,oBAAiB,CAAC,IAAI;SACjE,CAAC;QACF,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAClB,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,OAAO,QAAQ,CAAC,OAAqB,CAAC;IAC1C,CAAC;IAEO,KAAK,CAAC,oBAAoB,GAAA;QAC9B,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YACZ,OAAO;SACV;QACD,MAAM,OAAO,GAAgB,EAAE,CAAC;QAChC,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE;YAC5B,qCAAqC;YACrC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,EAAG,CAAC,CAAC;SAC1C,MAAM,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;YAClC,2DAA2D;YAC3D,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;SACpE,MAAM;YACH,OAAO;SACV;QACD,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;QAClB,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,MAAM,EAAE,QAAQ,EAAE,iBAAiB,EAAE,EAAE,EAAE;YAC5E,IAAI;gBACA,uFAAuF;gBACvF,MAAM,MAAM,GAAG,MAAM,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,GAAG,CAAG,CAAD,KAAO,CAAC,iBAAiB,CAAC,CAAC,CAAC;gBAC7E,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;aAC5B,CAAC,OAAO,GAAG,EAAE;gBACV,+LAAI,uBAAoB,AAApB,EAAqB,GAAG,CAAC,EAAE;oBAC3B,sEAAsE;oBACtE,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;iBAC/B,MAAM;oBACH,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;iBACxB;aACJ;QACL,CAAC,CAAC,CAAC,CAAC;QACJ,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,oBAAoB,EAAE,CAAC;IAChC,CAAC;IAED,WAAW,GAAA;QACP,IAAI,CAAC,mBAAmB,CAAC,MAAM,EAAE,CAAC;IACtC,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 8132, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8138, "column": 0}, "map": {"version":3,"file":"hydrator.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/serializer/hydrator.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2024 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { TokenType } from 'chevrotain';\nimport { CompositeCstNodeImpl, LeafCstNodeImpl, RootCstNodeImpl } from '../parser/cst-node-builder.js';\nimport { isAbstractElement, type AbstractElement, type Grammar } from '../languages/generated/ast.js';\nimport type { Linker } from '../references/linker.js';\nimport type { Lexer } from '../parser/lexer.js';\nimport type { LangiumCoreServices } from '../services.js';\nimport type { ParseResult } from '../parser/langium-parser.js';\nimport type { Reference, AstNode, CstNode, LeafCstNode, GenericAstNode, Mutable, RootCstNode } from '../syntax-tree.js';\nimport { isRootCstNode, isCompositeCstNode, isLeafCstNode, isAstNode, isReference } from '../syntax-tree.js';\nimport { streamAst } from '../utils/ast-utils.js';\nimport { BiMap } from '../utils/collections.js';\nimport { streamCst } from '../utils/cst-utils.js';\n\n/**\n * The hydrator service is responsible for allowing AST parse results to be sent across worker threads.\n */\nexport interface Hydrator {\n    /**\n     * Converts a parse result to a plain object. The resulting object can be sent across worker threads.\n     */\n    dehydrate(result: ParseResult<AstNode>): ParseResult<object>;\n    /**\n     * Converts a plain object to a parse result. The included AST node can then be used in the main thread.\n     * Calling this method on objects that have not been dehydrated first will result in undefined behavior.\n     */\n    hydrate<T extends AstNode = AstNode>(result: ParseResult<object>): ParseResult<T>;\n}\n\nexport interface DehydrateContext {\n    astNodes: Map<AstNode, any>;\n    cstNodes: Map<CstNode, any>;\n}\n\nexport interface HydrateContext {\n    astNodes: Map<any, AstNode>;\n    cstNodes: Map<any, CstNode>;\n}\n\nexport class DefaultHydrator implements Hydrator {\n\n    protected readonly grammar: Grammar;\n    protected readonly lexer: Lexer;\n    protected readonly linker: Linker;\n\n    protected readonly grammarElementIdMap = new BiMap<AbstractElement, number>();\n    protected readonly tokenTypeIdMap = new BiMap<number, TokenType>();\n\n    constructor(services: LangiumCoreServices) {\n        this.grammar = services.Grammar;\n        this.lexer = services.parser.Lexer;\n        this.linker = services.references.Linker;\n    }\n\n    dehydrate(result: ParseResult<AstNode>): ParseResult<object> {\n        return {\n            // We need to create shallow copies of the errors\n            // The original errors inherit from the `Error` class, which is not transferable across worker threads\n            lexerErrors: result.lexerErrors.map(e => ({ ...e })),\n            parserErrors: result.parserErrors.map(e => ({ ...e })),\n            value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))\n        };\n    }\n\n    protected createDehyrationContext(node: AstNode): DehydrateContext {\n        const astNodes = new Map<AstNode, any>();\n        const cstNodes = new Map<CstNode, any>();\n        for (const astNode of streamAst(node)) {\n            astNodes.set(astNode, {});\n        }\n        if (node.$cstNode) {\n            for (const cstNode of streamCst(node.$cstNode)) {\n                cstNodes.set(cstNode, {});\n            }\n        }\n        return {\n            astNodes,\n            cstNodes\n        };\n    }\n\n    protected dehydrateAstNode(node: AstNode, context: DehydrateContext): object {\n        const obj = context.astNodes.get(node) as Record<string, any>;\n        obj.$type = node.$type;\n        obj.$containerIndex = node.$containerIndex;\n        obj.$containerProperty = node.$containerProperty;\n        if (node.$cstNode !== undefined) {\n            obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);\n        }\n        for (const [name, value] of Object.entries(node)) {\n            if (name.startsWith('$')) {\n                continue;\n            }\n            if (Array.isArray(value)) {\n                const arr: any[] = [];\n                obj[name] = arr;\n                for (const item of value) {\n                    if (isAstNode(item)) {\n                        arr.push(this.dehydrateAstNode(item, context));\n                    } else if (isReference(item)) {\n                        arr.push(this.dehydrateReference(item, context));\n                    } else {\n                        arr.push(item);\n                    }\n                }\n            } else if (isAstNode(value)) {\n                obj[name] = this.dehydrateAstNode(value, context);\n            } else if (isReference(value)) {\n                obj[name] = this.dehydrateReference(value, context);\n            } else if (value !== undefined) {\n                obj[name] = value;\n            }\n        }\n        return obj;\n    }\n\n    protected dehydrateReference(reference: Reference, context: DehydrateContext): any {\n        const obj: Record<string, unknown> = {};\n        obj.$refText = reference.$refText;\n        if (reference.$refNode) {\n            obj.$refNode = context.cstNodes.get(reference.$refNode);\n        }\n        return obj;\n    }\n\n    protected dehydrateCstNode(node: CstNode, context: DehydrateContext): any {\n        const cstNode = context.cstNodes.get(node) as Record<string, any>;\n        if (isRootCstNode(node)) {\n            cstNode.fullText = node.fullText;\n        } else {\n            // Note: This returns undefined for hidden nodes (i.e. comments)\n            cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);\n        }\n        cstNode.hidden = node.hidden;\n        cstNode.astNode = context.astNodes.get(node.astNode);\n        if (isCompositeCstNode(node)) {\n            cstNode.content = node.content.map(child => this.dehydrateCstNode(child, context));\n        } else if (isLeafCstNode(node)) {\n            cstNode.tokenType = node.tokenType.name;\n            cstNode.offset = node.offset;\n            cstNode.length = node.length;\n            cstNode.startLine = node.range.start.line;\n            cstNode.startColumn = node.range.start.character;\n            cstNode.endLine = node.range.end.line;\n            cstNode.endColumn = node.range.end.character;\n        }\n        return cstNode;\n    }\n\n    hydrate<T extends AstNode = AstNode>(result: ParseResult<object>): ParseResult<T> {\n        const node = result.value;\n        const context = this.createHydrationContext(node);\n        if ('$cstNode' in node) {\n            this.hydrateCstNode(node.$cstNode, context);\n        }\n        return {\n            lexerErrors: result.lexerErrors,\n            parserErrors: result.parserErrors,\n            value: this.hydrateAstNode(node, context) as T\n        };\n    }\n\n    protected createHydrationContext(node: any): HydrateContext {\n        const astNodes = new Map<any, AstNode>();\n        const cstNodes = new Map<any, CstNode>();\n        for (const astNode of streamAst(node)) {\n            astNodes.set(astNode, {} as AstNode);\n        }\n        let root: RootCstNode;\n        if (node.$cstNode) {\n            for (const cstNode of streamCst(node.$cstNode)) {\n                let cst: Mutable<CstNode> | undefined;\n                if ('fullText' in cstNode) {\n                    cst = new RootCstNodeImpl(cstNode.fullText as string);\n                    root = cst as RootCstNode;\n                } else if ('content' in cstNode) {\n                    cst = new CompositeCstNodeImpl();\n                } else if ('tokenType' in cstNode) {\n                    cst = this.hydrateCstLeafNode(cstNode);\n                }\n                if (cst) {\n                    cstNodes.set(cstNode, cst);\n                    cst.root = root!;\n                }\n            }\n        }\n        return {\n            astNodes,\n            cstNodes\n        };\n    }\n\n    protected hydrateAstNode(node: any, context: HydrateContext): AstNode {\n        const astNode = context.astNodes.get(node) as Mutable<GenericAstNode>;\n        astNode.$type = node.$type;\n        astNode.$containerIndex = node.$containerIndex;\n        astNode.$containerProperty = node.$containerProperty;\n        if (node.$cstNode) {\n            astNode.$cstNode = context.cstNodes.get(node.$cstNode);\n        }\n        for (const [name, value] of Object.entries(node)) {\n            if (name.startsWith('$')) {\n                continue;\n            }\n            if (Array.isArray(value)) {\n                const arr: unknown[] = [];\n                astNode[name] = arr;\n                for (const item of value) {\n                    if (isAstNode(item)) {\n                        arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));\n                    } else if (isReference(item)) {\n                        arr.push(this.hydrateReference(item, astNode, name, context));\n                    } else {\n                        arr.push(item);\n                    }\n                }\n            } else if (isAstNode(value)) {\n                astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);\n            } else if (isReference(value)) {\n                astNode[name] = this.hydrateReference(value, astNode, name, context);\n            } else if (value !== undefined) {\n                astNode[name] = value;\n            }\n        }\n        return astNode;\n    }\n\n    protected setParent(node: any, parent: any): any {\n        node.$container = parent as AstNode;\n        return node;\n    }\n\n    protected hydrateReference(reference: any, node: AstNode, name: string, context: HydrateContext): Reference {\n        return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode)!, reference.$refText);\n    }\n\n    protected hydrateCstNode(cstNode: any, context: HydrateContext, num = 0): CstNode {\n        const cstNodeObj = context.cstNodes.get(cstNode) as Mutable<CstNode>;\n        if (typeof cstNode.grammarSource === 'number') {\n            cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);\n        }\n        cstNodeObj.astNode = context.astNodes.get(cstNode.astNode)!;\n        if (isCompositeCstNode(cstNodeObj)) {\n            for (const child of cstNode.content) {\n                const hydrated = this.hydrateCstNode(child, context, num++);\n                cstNodeObj.content.push(hydrated);\n            }\n        }\n        return cstNodeObj;\n    }\n\n    protected hydrateCstLeafNode(cstNode: any): LeafCstNode {\n        const tokenType = this.getTokenType(cstNode.tokenType);\n        const offset = cstNode.offset;\n        const length = cstNode.length;\n        const startLine = cstNode.startLine;\n        const startColumn = cstNode.startColumn;\n        const endLine = cstNode.endLine;\n        const endColumn = cstNode.endColumn;\n        const hidden = cstNode.hidden;\n        const node = new LeafCstNodeImpl(\n            offset,\n            length,\n            {\n                start: {\n                    line: startLine,\n                    character: startColumn\n                },\n                end: {\n                    line: endLine,\n                    character: endColumn\n                }\n            },\n            tokenType,\n            hidden\n        );\n        return node;\n    }\n\n    protected getTokenType(name: string): TokenType {\n        return this.lexer.definition[name];\n    }\n\n    protected getGrammarElementId(node: AbstractElement): number | undefined {\n        if (this.grammarElementIdMap.size === 0) {\n            this.createGrammarElementIdMap();\n        }\n        return this.grammarElementIdMap.get(node);\n    }\n\n    protected getGrammarElement(id: number): AbstractElement {\n        if (this.grammarElementIdMap.size === 0) {\n            this.createGrammarElementIdMap();\n        }\n        const element = this.grammarElementIdMap.getKey(id);\n        if (element) {\n            return element;\n        } else {\n            throw new Error('Invalid grammar element id: ' + id);\n        }\n    }\n\n    protected createGrammarElementIdMap(): void {\n        let id = 0;\n        for (const element of streamAst(this.grammar)) {\n            if (isAbstractElement(element)) {\n                this.grammarElementIdMap.set(element, id++);\n            }\n        }\n    }\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8401, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8407, "column": 0}, "map": {"version":3,"file":"default-module.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/default-module.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n******************************************************************************/\n\nimport type { Module } from './dependency-injection.js';\nimport type { LangiumDefaultCoreServices, LangiumDefaultSharedCoreServices, LangiumCoreServices, LangiumSharedCoreServices } from './services.js';\nimport type { FileSystemProvider } from './workspace/file-system-provider.js';\nimport { createGrammarConfig } from './languages/grammar-config.js';\nimport { createCompletionParser } from './parser/completion-parser-builder.js';\nimport { createLangiumParser } from './parser/langium-parser-builder.js';\nimport { DefaultTokenBuilder } from './parser/token-builder.js';\nimport { DefaultValueConverter } from './parser/value-converter.js';\nimport { DefaultLinker } from './references/linker.js';\nimport { DefaultNameProvider } from './references/name-provider.js';\nimport { DefaultReferences } from './references/references.js';\nimport { DefaultScopeComputation } from './references/scope-computation.js';\nimport { DefaultScopeProvider } from './references/scope-provider.js';\nimport { DefaultJsonSerializer } from './serializer/json-serializer.js';\nimport { DefaultServiceRegistry } from './service-registry.js';\nimport { DefaultDocumentValidator } from './validation/document-validator.js';\nimport { ValidationRegistry } from './validation/validation-registry.js';\nimport { DefaultAstNodeDescriptionProvider, DefaultReferenceDescriptionProvider } from './workspace/ast-descriptions.js';\nimport { DefaultAstNodeLocator } from './workspace/ast-node-locator.js';\nimport { DefaultConfigurationProvider } from './workspace/configuration.js';\nimport { DefaultDocumentBuilder } from './workspace/document-builder.js';\nimport { DefaultLangiumDocumentFactory, DefaultLangiumDocuments } from './workspace/documents.js';\nimport { DefaultIndexManager } from './workspace/index-manager.js';\nimport { DefaultWorkspaceManager } from './workspace/workspace-manager.js';\nimport { DefaultLexer } from './parser/lexer.js';\nimport { JSDocDocumentationProvider } from './documentation/documentation-provider.js';\nimport { DefaultCommentProvider } from './documentation/comment-provider.js';\nimport { LangiumParserErrorMessageProvider } from './parser/langium-parser.js';\nimport { DefaultAsyncParser } from './parser/async-parser.js';\nimport { DefaultWorkspaceLock } from './workspace/workspace-lock.js';\nimport { DefaultHydrator } from './serializer/hydrator.js';\n\n/**\n * Context required for creating the default language-specific dependency injection module.\n */\nexport interface DefaultCoreModuleContext {\n    shared: LangiumSharedCoreServices;\n}\n\n/**\n * Creates a dependency injection module configuring the default core services.\n * This is a set of services that are dedicated to a specific language.\n */\nexport function createDefaultCoreModule(context: DefaultCoreModuleContext): Module<LangiumCoreServices, LangiumDefaultCoreServices> {\n    return {\n        documentation: {\n            CommentProvider: (services) => new DefaultCommentProvider(services),\n            DocumentationProvider: (services) => new JSDocDocumentationProvider(services)\n        },\n        parser: {\n            AsyncParser: (services) => new DefaultAsyncParser(services),\n            GrammarConfig: (services) => createGrammarConfig(services),\n            LangiumParser: (services) => createLangiumParser(services),\n            CompletionParser: (services) => createCompletionParser(services),\n            ValueConverter: () => new DefaultValueConverter(),\n            TokenBuilder: () => new DefaultTokenBuilder(),\n            Lexer: (services) => new DefaultLexer(services),\n            ParserErrorMessageProvider: () => new LangiumParserErrorMessageProvider()\n        },\n        workspace: {\n            AstNodeLocator: () => new DefaultAstNodeLocator(),\n            AstNodeDescriptionProvider: (services) => new DefaultAstNodeDescriptionProvider(services),\n            ReferenceDescriptionProvider: (services) => new DefaultReferenceDescriptionProvider(services)\n        },\n        references: {\n            Linker: (services) => new DefaultLinker(services),\n            NameProvider: () => new DefaultNameProvider(),\n            ScopeProvider: (services) => new DefaultScopeProvider(services),\n            ScopeComputation: (services) => new DefaultScopeComputation(services),\n            References: (services) => new DefaultReferences(services)\n        },\n        serializer: {\n            Hydrator: (services) => new DefaultHydrator(services),\n            JsonSerializer: (services) => new DefaultJsonSerializer(services)\n        },\n        validation: {\n            DocumentValidator: (services) => new DefaultDocumentValidator(services),\n            ValidationRegistry: (services) => new ValidationRegistry(services)\n        },\n        shared: () => context.shared\n    };\n}\n\n/**\n * Context required for creating the default shared dependency injection module.\n */\nexport interface DefaultSharedCoreModuleContext {\n    /**\n     * Factory function to create a {@link FileSystemProvider}.\n     *\n     * Langium exposes an `EmptyFileSystem` and `NodeFileSystem`, exported through `langium/node`.\n     * When running Langium as part of a vscode language server or a Node.js app, using the `NodeFileSystem` is recommended,\n     * the `EmptyFileSystem` in every other use case.\n     */\n    fileSystemProvider: (services: LangiumSharedCoreServices) => FileSystemProvider;\n}\n\n/**\n * Creates a dependency injection module configuring the default shared core services.\n * This is the set of services that are shared between multiple languages.\n */\nexport function createDefaultSharedCoreModule(context: DefaultSharedCoreModuleContext): Module<LangiumSharedCoreServices, LangiumDefaultSharedCoreServices> {\n    return {\n        ServiceRegistry: () => new DefaultServiceRegistry(),\n        workspace: {\n            LangiumDocuments: (services) => new DefaultLangiumDocuments(services),\n            LangiumDocumentFactory: (services) => new DefaultLangiumDocumentFactory(services),\n            DocumentBuilder: (services) => new DefaultDocumentBuilder(services),\n            IndexManager: (services) => new DefaultIndexManager(services),\n            WorkspaceManager: (services) => new DefaultWorkspaceManager(services),\n            FileSystemProvider: (services) => context.fileSystemProvider(services),\n            WorkspaceLock: () => new DefaultWorkspaceLock(),\n            ConfigurationProvider: (services) => new DefaultConfigurationProvider(services)\n        }\n    };\n}\n"],"names":[],"mappings":"AAAA;;;;+EAI+E;;;;AAK/E,OAAO,EAAE,mBAAmB,EAAE,MAAM,+BAA+B,CAAC;AACpE,OAAO,EAAE,sBAAsB,EAAE,MAAM,uCAAuC,CAAC;AAC/E,OAAO,EAAE,mBAAmB,EAAE,MAAM,oCAAoC,CAAC;AACzE,OAAO,EAAE,mBAAmB,EAAE,MAAM,2BAA2B,CAAC;AAChE,OAAO,EAAE,qBAAqB,EAAE,MAAM,6BAA6B,CAAC;AACpE,OAAO,EAAE,aAAa,EAAE,MAAM,wBAAwB,CAAC;AACvD,OAAO,EAAE,mBAAmB,EAAE,MAAM,+BAA+B,CAAC;AACpE,OAAO,EAAE,iBAAiB,EAAE,MAAM,4BAA4B,CAAC;AAC/D,OAAO,EAAE,uBAAuB,EAAE,MAAM,mCAAmC,CAAC;AAC5E,OAAO,EAAE,oBAAoB,EAAE,MAAM,gCAAgC,CAAC;AACtE,OAAO,EAAE,qBAAqB,EAAE,MAAM,iCAAiC,CAAC;AACxE,OAAO,EAAE,sBAAsB,EAAE,MAAM,uBAAuB,CAAC;AAC/D,OAAO,EAAE,wBAAwB,EAAE,MAAM,oCAAoC,CAAC;AAC9E,OAAO,EAAE,kBAAkB,EAAE,MAAM,qCAAqC,CAAC;AACzE,OAAO,EAAE,iCAAiC,EAAE,mCAAmC,EAAE,MAAM,iCAAiC,CAAC;AACzH,OAAO,EAAE,qBAAqB,EAAE,MAAM,iCAAiC,CAAC;AACxE,OAAO,EAAE,4BAA4B,EAAE,MAAM,8BAA8B,CAAC;AAC5E,OAAO,EAAE,sBAAsB,EAAE,MAAM,iCAAiC,CAAC;;AAEzE,OAAO,EAAE,mBAAmB,EAAE,MAAM,8BAA8B,CAAC;AACnE,OAAO,EAAE,uBAAuB,EAAE,MAAM,kCAAkC,CAAC;AAC3E,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACjD,OAAO,EAAE,0BAA0B,EAAE,MAAM,2CAA2C,CAAC;AACvF,OAAO,EAAE,sBAAsB,EAAE,MAAM,qCAAqC,CAAC;AAC7E,OAAO,EAAE,iCAAiC,EAAE,MAAM,4BAA4B,CAAC;AAC/E,OAAO,EAAE,kBAAkB,EAAE,MAAM,0BAA0B,CAAC;AAC9D,OAAO,EAAE,oBAAoB,EAAE,MAAM,+BAA+B,CAAC;AACrE,OAAO,EAAE,eAAe,EAAE,MAAM,0BAA0B,CAAC;AAT3D,OAAO,EAAE,6BAA6B,EAAE,uBAAuB,EAAE,MAAM,0BAA0B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsB5F,SAAU,uBAAuB,CAAC,OAAiC;IACrE,OAAO;QACH,aAAa,EAAE;YACX,eAAe,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,qMAAK,yBAAsB,CAAC,QAAQ,CAAC;YACnE,qBAAqB,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,2MAAK,6BAA0B,CAAC,QAAQ,CAAC;SAChF;QACD,MAAM,EAAE;YACJ,WAAW,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,0LAAK,qBAAkB,CAAC,QAAQ,CAAC;YAC3D,aAAa,EAAE,CAAC,QAAQ,EAAE,EAAE,+LAAC,sBAAA,AAAmB,EAAC,QAAQ,CAAC;YAC1D,aAAa,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,6NAAC,AAAmB,EAAC,QAAQ,CAAC;YAC1D,gBAAgB,EAAE,CAAC,QAAQ,EAAE,EAAE,0MAAC,yBAAA,AAAsB,EAAC,QAAQ,CAAC;YAChE,cAAc,EAAE,GAAG,CAAG,CAAD,6LAAK,wBAAqB,EAAE;YACjD,YAAY,EAAE,GAAG,CAAG,CAAD,GAAK,8MAAmB,EAAE;YAC7C,KAAK,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,gLAAK,eAAY,CAAC,QAAQ,CAAC;YAC/C,0BAA0B,EAAE,GAAG,CAAG,CAAD,4LAAK,oCAAiC,EAAE;SAC5E;QACD,SAAS,EAAE;YACP,cAAc,EAAE,GAAG,CAAG,CAAD,oMAAK,wBAAqB,EAAE;YACjD,0BAA0B,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,iMAAK,oCAAiC,CAAC,QAAQ,CAAC;YACzF,4BAA4B,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,gMAAK,uCAAmC,CAAC,QAAQ,CAAC;SAChG;QACD,UAAU,EAAE;YACR,MAAM,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,qLAAK,gBAAa,CAAC,QAAQ,CAAC;YACjD,YAAY,EAAE,GAAG,CAAG,CAAD,+LAAK,sBAAmB,EAAE;YAC7C,aAAa,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,gMAAK,uBAAoB,CAAC,QAAQ,CAAC;YAC/D,gBAAgB,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,kMAAK,2BAAuB,CAAC,QAAQ,CAAC;YACrE,UAAU,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,yLAAK,oBAAiB,CAAC,QAAQ,CAAC;SAC5D;QACD,UAAU,EAAE;YACR,QAAQ,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,GAAK,sMAAe,CAAC,QAAQ,CAAC;YACrD,cAAc,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,iMAAK,wBAAqB,CAAC,QAAQ,CAAC;SACpE;QACD,UAAU,EAAE;YACR,iBAAiB,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,oMAAK,2BAAwB,CAAC,QAAQ,CAAC;YACvE,kBAAkB,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,qMAAK,qBAAkB,CAAC,QAAQ,CAAC;SACrE;QACD,MAAM,EAAE,GAAG,CAAG,CAAD,MAAQ,CAAC,MAAM;KAC/B,CAAC;AACN,CAAC;AAoBK,SAAU,6BAA6B,CAAC,OAAuC;IACjF,OAAO;QACH,eAAe,EAAE,GAAG,CAAG,CAAD,oLAAK,yBAAsB,EAAE;QACnD,SAAS,EAAE;YACP,gBAAgB,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,GAAK,8NAAuB,CAAC,QAAQ,CAAC;YACrE,sBAAsB,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,uMAAK,gCAA6B,CAAC,QAAQ,CAAC;YACjF,eAAe,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,iMAAK,yBAAsB,CAAC,QAAQ,CAAC;YACnE,YAAY,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,8LAAK,sBAAmB,CAAC,QAAQ,CAAC;YAC7D,gBAAgB,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,GAAK,yNAAuB,CAAC,QAAQ,CAAC;YACrE,kBAAkB,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,MAAQ,CAAC,kBAAkB,CAAC,QAAQ,CAAC;YACtE,aAAa,EAAE,GAAG,CAAG,CAAD,+LAAK,uBAAoB,EAAE;YAC/C,qBAAqB,EAAE,CAAC,QAAQ,EAAE,CAAG,CAAD,2LAAK,+BAA4B,CAAC,QAAQ,CAAC;SAClF;KACJ,CAAC;AACN,CAAC","ignoreList":[0]}},
    {"offset": {"line": 8526, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8532, "column": 0}, "map": {"version":3,"file":"dependency-injection.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/dependency-injection.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * A `Module<I>` is a description of possibly grouped service factories.\n *\n * Given a type I = { group: { service: A } },\n * Module<I> := { group: { service: (injector: I) => A } }\n *\n * Making `I` available during the creation of `I` allows us to create cyclic\n * dependencies.\n */\nexport type Module<I, T = I> = {\n    [K in keyof T]: Module<I, T[K]> | ((injector: I) => T[K])\n}\n\nexport namespace Module {\n    export const merge = <M1, M2, R extends M1 & M2>(m1: Module<R, M1>, m2: Module<R, M2>) => (_merge(_merge({}, m1), m2) as Module<R, M1 & M2>);\n}\n\n/**\n * Given a set of modules, the inject function returns a lazily evaluated injector\n * that injects dependencies into the requested service when it is requested the\n * first time. Subsequent requests will return the same service.\n *\n * In the case of cyclic dependencies, an Error will be thrown. This can be fixed\n * by injecting a provider `() => T` instead of a `T`.\n *\n * Please note that the arguments may be objects or arrays. However, the result will\n * be an object. Using it with for..of will have no effect.\n *\n * @param module1 first Module\n * @param module2 (optional) second Module\n * @param module3 (optional) third Module\n * @param module4 (optional) fourth Module\n * @param module5 (optional) fifth Module\n * @param module6 (optional) sixth Module\n * @param module7 (optional) seventh Module\n * @param module8 (optional) eighth Module\n * @param module9 (optional) ninth Module\n * @returns a new object of type I\n */\nexport function inject<I1, I2, I3, I4, I5, I6, I7, I8, I9, I extends I1 & I2 & I3 & I4 & I5 & I6 & I7 & I8 & I9>(\n    module1: Module<I, I1>, module2?: Module<I, I2>, module3?: Module<I, I3>, module4?: Module<I, I4>, module5?: Module<I, I5>, module6?: Module<I, I6>, module7?: Module<I, I7>, module8?: Module<I, I8>, module9?: Module<I, I9>\n): I {\n    const module = [module1, module2, module3, module4, module5, module6, module7, module8, module9].reduce(_merge, {}) as Module<I>;\n    return _inject(module);\n}\n\nconst isProxy = Symbol('isProxy');\n\n/**\n * Eagerly load all services in the given dependency injection container. This is sometimes\n * necessary because services can register event listeners in their constructors.\n */\nexport function eagerLoad<T>(item: T): T {\n    if (item && (item as any)[isProxy]) {\n        for (const value of Object.values(item)) {\n            eagerLoad(value);\n        }\n    }\n    return item;\n}\n\n/**\n * Helper function that returns an injector by creating a proxy.\n * Invariant: injector is of type I. If injector is undefined, then T = I.\n */\nfunction _inject<I, T>(module: Module<I, T>, injector?: any): T {\n    const proxy: any = new Proxy({} as any, {\n        deleteProperty: () => false,\n        get: (obj, prop) => _resolve(obj, prop, module, injector || proxy),\n        getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)), // used by for..in\n        has: (_, prop) => prop in module, // used by ..in..\n        ownKeys: () => [...Reflect.ownKeys(module), isProxy] // used by for..in\n    });\n    proxy[isProxy] = true;\n    return proxy;\n}\n\n/**\n * Internally used to tag a requested dependency, directly before calling the factory.\n * This allows us to find cycles during instance creation.\n */\nconst __requested__ = Symbol();\n\n/**\n * Returns the value `obj[prop]`. If the value does not exist, yet, it is resolved from\n * the module description. The result of service factories is cached. Groups are\n * recursively proxied.\n *\n * @param obj an object holding all group proxies and services\n * @param prop the key of a value within obj\n * @param module an object containing groups and service factories\n * @param injector the first level proxy that provides access to all values\n * @returns the requested value `obj[prop]`\n * @throws Error if a dependency cycle is detected\n */\nfunction _resolve<I, T>(obj: any, prop: string | symbol | number, module: Module<I, T>, injector: I): T[keyof T] | undefined {\n    if (prop in obj) {\n        if (obj[prop] instanceof Error) {\n            throw new Error('Construction failure. Please make sure that your dependencies are constructable.', {cause: obj[prop]});\n        }\n        if (obj[prop] === __requested__) {\n            throw new Error('Cycle detected. Please make \"' + String(prop) + '\" lazy. See https://langium.org/docs/configuration-services/#resolving-cyclic-dependencies');\n        }\n        return obj[prop];\n    } else if (prop in module) {\n        const value: Module<I, T[keyof T]> | ((injector: I) => T[keyof T]) = module[prop as keyof T];\n        obj[prop] = __requested__;\n        try {\n            obj[prop] = (typeof value === 'function') ? value(injector) : _inject(value, injector);\n        } catch (error) {\n            obj[prop] = error instanceof Error ? error : undefined;\n            throw error;\n        }\n        return obj[prop];\n    } else {\n        return undefined;\n    }\n}\n\n/**\n * Performs a deep-merge of two modules by writing source entries into the target module.\n *\n * @param target the module which is written\n * @param source the module which is read\n * @returns the target module\n */\nfunction _merge(target: Module<any>, source?: Module<any>): Module<unknown> {\n    if (source) {\n        for (const [key, value2] of Object.entries(source)) {\n            if (value2 !== undefined) {\n                const value1 = target[key];\n                if (value1 !== null && value2 !== null && typeof value1 === 'object' && typeof value2 === 'object') {\n                    target[key] = _merge(value1, value2);\n                } else {\n                    target[key] = value2;\n                }\n            }\n        }\n    }\n    return target;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8646, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8652, "column": 0}, "map": {"version":3,"file":"services.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/services.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n// Ensure that all imports are erased at runtime to avoid circular dependencies.\nimport type { IParserErrorMessageProvider } from 'chevrotain';\nimport type { CommentProvider } from './documentation/comment-provider.js';\nimport type { DocumentationProvider } from './documentation/documentation-provider.js';\nimport type { Grammar } from './languages/generated/ast.js';\nimport type { GrammarConfig } from './languages/grammar-config.js';\nimport type { LanguageMetaData } from './languages/language-meta-data.js';\nimport type { AsyncParser } from './parser/async-parser.js';\nimport type { LangiumCompletionParser, LangiumParser } from './parser/langium-parser.js';\nimport type { Lexer } from './parser/lexer.js';\nimport type { IParserConfig } from './parser/parser-config.js';\nimport type { TokenBuilder } from './parser/token-builder.js';\nimport type { ValueConverter } from './parser/value-converter.js';\nimport type { Linker } from './references/linker.js';\nimport type { NameProvider } from './references/name-provider.js';\nimport type { References } from './references/references.js';\nimport type { ScopeComputation } from './references/scope-computation.js';\nimport type { ScopeProvider } from './references/scope-provider.js';\nimport type { JsonSerializer } from './serializer/json-serializer.js';\nimport type { ServiceRegistry } from './service-registry.js';\nimport type { AstReflection } from './syntax-tree.js';\nimport type { DocumentValidator } from './validation/document-validator.js';\nimport type { ValidationRegistry } from './validation/validation-registry.js';\nimport type { AstNodeDescriptionProvider, ReferenceDescriptionProvider } from './workspace/ast-descriptions.js';\nimport type { AstNodeLocator } from './workspace/ast-node-locator.js';\nimport type { ConfigurationProvider } from './workspace/configuration.js';\nimport type { DocumentBuilder } from './workspace/document-builder.js';\nimport type { LangiumDocumentFactory, LangiumDocuments, TextDocumentProvider } from './workspace/documents.js';\nimport type { FileSystemProvider } from './workspace/file-system-provider.js';\nimport type { IndexManager } from './workspace/index-manager.js';\nimport type { WorkspaceLock } from './workspace/workspace-lock.js';\nimport type { Hydrator } from './serializer/hydrator.js';\nimport type { WorkspaceManager } from './workspace/workspace-manager.js';\n\n/**\n * The services generated by `langium-cli` for a specific language. These are derived from the\n * grammar definition and the language configuration.\n */\nexport type LangiumGeneratedCoreServices = {\n    Grammar: Grammar\n    LanguageMetaData: LanguageMetaData\n    parser: {\n        ParserConfig?: IParserConfig\n    }\n}\n\n/**\n * Core services for a specific language of which Langium provides default implementations.\n */\nexport type LangiumDefaultCoreServices = {\n    parser: {\n        AsyncParser: AsyncParser\n        GrammarConfig: GrammarConfig\n        ValueConverter: ValueConverter\n        LangiumParser: LangiumParser\n        ParserErrorMessageProvider: IParserErrorMessageProvider\n        CompletionParser: LangiumCompletionParser\n        TokenBuilder: TokenBuilder\n        Lexer: Lexer\n    }\n    documentation: {\n        CommentProvider: CommentProvider\n        DocumentationProvider: DocumentationProvider\n    }\n    references: {\n        Linker: Linker\n        NameProvider: NameProvider\n        References: References\n        ScopeProvider: ScopeProvider\n        ScopeComputation: ScopeComputation\n    }\n    serializer: {\n        Hydrator: Hydrator\n        JsonSerializer: JsonSerializer\n    }\n    validation: {\n        DocumentValidator: DocumentValidator\n        ValidationRegistry: ValidationRegistry\n    }\n    workspace: {\n        AstNodeLocator: AstNodeLocator\n        AstNodeDescriptionProvider: AstNodeDescriptionProvider\n        ReferenceDescriptionProvider: ReferenceDescriptionProvider\n    }\n    shared: LangiumSharedCoreServices\n}\n\n/**\n * The core set of services available for a language. These are either generated by `langium-cli`\n * or provided as default implementations.\n */\nexport type LangiumCoreServices = LangiumGeneratedCoreServices & LangiumDefaultCoreServices\n\n/**\n * The services generated by `langium-cli` that are shared between multiple languages. These are\n * derived from the grammar definition.\n */\nexport type LangiumGeneratedSharedCoreServices = {\n    AstReflection: AstReflection\n}\n\n/**\n * Core services shared between multiple languages where Langium provides default implementations.\n */\nexport type LangiumDefaultSharedCoreServices = {\n    ServiceRegistry: ServiceRegistry\n    workspace: {\n        ConfigurationProvider: ConfigurationProvider\n        DocumentBuilder: DocumentBuilder\n        FileSystemProvider: FileSystemProvider\n        IndexManager: IndexManager\n        LangiumDocuments: LangiumDocuments\n        LangiumDocumentFactory: LangiumDocumentFactory\n        TextDocuments?: TextDocumentProvider\n        WorkspaceLock: WorkspaceLock\n        WorkspaceManager: WorkspaceManager\n    }\n}\n\n/**\n * The shared core services are a set of services that are used by every language within a Langium project (excluding LSP services)\n * This is necessary to enable features like cross references across different languages.\n */\nexport type LangiumSharedCoreServices = LangiumDefaultSharedCoreServices & LangiumGeneratedSharedCoreServices\n\n/**\n * A deep partial type definition for services. We look into T to see whether its type definition contains\n * any methods. If it does, it's one of our services and therefore should not be partialized.\n */\n//eslint-disable-next-line @typescript-eslint/ban-types\nexport type DeepPartial<T> = T[keyof T] extends Function ? T : {\n    [P in keyof T]?: DeepPartial<T[P]>;\n}\n\n/**\n * Language-specific core services to be partially overridden via dependency injection.\n */\nexport type PartialLangiumCoreServices = DeepPartial<LangiumCoreServices>\n\n/**\n * Shared core services to be partially overridden via dependency injection.\n */\nexport type PartialLangiumSharedCoreServices = DeepPartial<LangiumSharedCoreServices>\n"],"names":[],"mappings":"AAAA;;;;gFAIgF","ignoreList":[0]}},
    {"offset": {"line": 8659, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8665, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/documentation/index.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport * from './comment-provider.js';\nexport * from './documentation-provider.js';\nexport * from './jsdoc.js';\n"],"names":[],"mappings":"AAAA;;;;gFAIgF","ignoreList":[0]}},
    {"offset": {"line": 8674, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8691, "column": 0}, "map": {"version":3,"file":"language-meta-data.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/languages/language-meta-data.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport interface LanguageMetaData {\n    languageId: string;\n    fileExtensions: readonly string[];\n    caseInsensitive: boolean;\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF","ignoreList":[0]}},
    {"offset": {"line": 8698, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8704, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/languages/index.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport * from './grammar-config.js';\nexport * from './language-meta-data.js';\n"],"names":[],"mappings":"AAAA;;;;gFAIgF","ignoreList":[0]}},
    {"offset": {"line": 8712, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8728, "column": 0}, "map": {"version":3,"file":"parser-config.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/parser/parser-config.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport type { IParserConfig } from 'chevrotain';\n"],"names":[],"mappings":"AAAA;;;;gFAIgF","ignoreList":[0]}},
    {"offset": {"line": 8735, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8741, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/parser/index.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport * from './async-parser.js';\nexport * from './completion-parser-builder.js';\nexport * from './cst-node-builder.js';\nexport * from './langium-parser-builder.js';\nexport * from './langium-parser.js';\nexport * from './lexer.js';\nexport * from './parser-config.js';\nexport * from './token-builder.js';\nexport * from './value-converter.js';\n"],"names":[],"mappings":"AAAA;;;;gFAIgF","ignoreList":[0]}},
    {"offset": {"line": 8756, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8779, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/references/index.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport * from './linker.js';\nexport * from './name-provider.js';\nexport * from './references.js';\nexport * from './scope.js';\nexport * from './scope-computation.js';\nexport * from './scope-provider.js';\n"],"names":[],"mappings":"AAAA;;;;gFAIgF","ignoreList":[0]}},
    {"offset": {"line": 8791, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8811, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/serializer/index.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport * from './hydrator.js';\nexport * from './json-serializer.js';\n"],"names":[],"mappings":"AAAA;;;;gFAIgF","ignoreList":[0]}},
    {"offset": {"line": 8819, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8835, "column": 0}, "map": {"version":3,"file":"file-system-provider.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/workspace/file-system-provider.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport type { URI } from '../utils/uri-utils.js';\n\nexport interface FileSystemNode {\n    readonly isFile: boolean;\n    readonly isDirectory: boolean;\n    readonly uri: URI;\n}\n\nexport type FileSystemFilter = (node: FileSystemNode) => boolean;\n\n/**\n * Provides methods to interact with an abstract file system. The default implementation is based on the node.js `fs` API.\n */\nexport interface FileSystemProvider {\n    /**\n     * Reads a document asynchronously from a given URI.\n     * @returns The string content of the file with the specified URI.\n     */\n    readFile(uri: URI): Promise<string>;\n    /**\n     * Reads the directory information for the given URI.\n     * @returns The list of file system entries that are contained within the specified directory.\n     */\n    readDirectory(uri: URI): Promise<FileSystemNode[]>;\n}\n\nexport class EmptyFileSystemProvider implements FileSystemProvider {\n\n    readFile(): Promise<string> {\n        throw new Error('No file system is available.');\n    }\n\n    async readDirectory(): Promise<FileSystemNode[]> {\n        return [];\n    }\n\n}\n\nexport const EmptyFileSystem = {\n    fileSystemProvider: () => new EmptyFileSystemProvider()\n};\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;;AA4B1E,MAAO,uBAAuB;IAEhC,QAAQ,GAAA;QACJ,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;IACpD,CAAC;IAED,KAAK,CAAC,aAAa,GAAA;QACf,OAAO,EAAE,CAAC;IACd,CAAC;CAEJ;AAEM,MAAM,eAAe,GAAG;IAC3B,kBAAkB,EAAE,GAAG,CAAG,CAAD,GAAK,uBAAuB,EAAE;CAC1D,CAAC","ignoreList":[0]}},
    {"offset": {"line": 8854, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8860, "column": 0}, "map": {"version":3,"file":"grammar-loader.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/grammar-loader.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nimport { createDefaultCoreModule, createDefaultSharedCoreModule } from '../default-module.js';\nimport type { Module } from '../dependency-injection.js';\nimport { inject } from '../dependency-injection.js';\nimport * as ast from '../languages/generated/ast.js';\nimport type { LangiumCoreServices, LangiumSharedCoreServices, PartialLangiumCoreServices, PartialLangiumSharedCoreServices } from '../services.js';\nimport type { Mutable } from '../syntax-tree.js';\nimport { EmptyFileSystem } from '../workspace/file-system-provider.js';\nimport { URI } from './uri-utils.js';\n\nconst minimalGrammarModule: Module<LangiumCoreServices, PartialLangiumCoreServices> = {\n    Grammar: () => undefined as unknown as ast.Grammar,\n    LanguageMetaData: () => ({\n        caseInsensitive: false,\n        fileExtensions: ['.langium'],\n        languageId: 'langium'\n    })\n};\n\nconst minimalSharedGrammarModule: Module<LangiumSharedCoreServices, PartialLangiumSharedCoreServices> = {\n    AstReflection: () => new ast.LangiumGrammarAstReflection()\n};\n\nfunction createMinimalGrammarServices(): LangiumCoreServices {\n    const shared = inject(\n        createDefaultSharedCoreModule(EmptyFileSystem),\n        minimalSharedGrammarModule\n    );\n    const grammar = inject(\n        createDefaultCoreModule({ shared }),\n        minimalGrammarModule\n    );\n    shared.ServiceRegistry.register(grammar);\n    return grammar;\n}\n\n/**\n * Load a Langium grammar for your language from a JSON string. This is used by several services,\n * most notably the parser builder which interprets the grammar to create a parser.\n */\nexport function loadGrammarFromJson(json: string): ast.Grammar {\n    const services = createMinimalGrammarServices();\n    const astNode = services.serializer.JsonSerializer.deserialize(json) as Mutable<ast.Grammar>;\n    services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, URI.parse(`memory://${astNode.name ?? 'grammar'}.langium`));\n    return astNode;\n}\n"],"names":[],"mappings":"AAAA;;;;gFAIgF;;;AAEhF,OAAO,EAAE,uBAAuB,EAAE,6BAA6B,EAAE,MAAM,sBAAsB,CAAC;AAE9F,OAAO,EAAE,MAAM,EAAE,MAAM,4BAA4B,CAAC;AACpD,OAAO,KAAK,GAAG,MAAM,+BAA+B,CAAC;AAGrD,OAAO,EAAE,eAAe,EAAE,MAAM,sCAAsC,CAAC;;AACvE,OAAO,EAAE,GAAG,EAAE,MAAM,gBAAgB,CAAC;;;;;;AAErC,MAAM,oBAAoB,GAA4D;IAClF,OAAO,EAAE,GAAG,CAAG,CAAD,QAAoC;IAClD,gBAAgB,EAAE,GAAG,CAAG,CAAD,AAAE;YACrB,eAAe,EAAE,KAAK;YACtB,cAAc,EAAE;gBAAC,UAAU;aAAC;YAC5B,UAAU,EAAE,SAAS;SACxB,CAAC;CACL,CAAC;AAEF,MAAM,0BAA0B,GAAwE;IACpG,aAAa,EAAE,GAAG,CAAG,CAAD,GAAK,GAAG,wLAAC,2BAA2B,EAAE;CAC7D,CAAC;AAEF,SAAS,4BAA4B;IACjC,MAAM,MAAM,IAAG,iMAAA,AAAM,qLACjB,gCAAA,AAA6B,uMAAC,kBAAe,CAAC,EAC9C,0BAA0B,CAC7B,CAAC;IACF,MAAM,OAAO,4LAAG,SAAM,AAAN,qLACZ,0BAAA,AAAuB,EAAC;QAAE,MAAM;IAAA,CAAE,CAAC,EACnC,oBAAoB,CACvB,CAAC;IACF,MAAM,CAAC,eAAe,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IACzC,OAAO,OAAO,CAAC;AACnB,CAAC;AAMK,SAAU,mBAAmB,CAAC,IAAY;;IAC5C,MAAM,QAAQ,GAAG,4BAA4B,EAAE,CAAC;IAChD,MAAM,OAAO,GAAG,QAAQ,CAAC,UAAU,CAAC,cAAc,CAAC,WAAW,CAAC,IAAI,CAAyB,CAAC;IAC7F,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,sBAAsB,CAAC,SAAS,CAAC,OAAO,mLAAE,MAAG,CAAC,KAAK,CAAC,CAAA,SAAA,EAAY,CAAA,KAAA,OAAO,CAAC,IAAI,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,SAAS,CAAA,QAAA,CAAU,CAAC,CAAC,CAAC;IAChI,OAAO,OAAO,CAAC;AACnB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 8906, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8912, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/utils/index.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport * from './caching.js';\nexport * from './event.js';\nexport * from './collections.js';\nexport * from './disposable.js';\nexport * from './errors.js';\nexport * from './grammar-loader.js';\nexport * from './promise-utils.js';\nexport * from './stream.js';\nexport * from './uri-utils.js';\n\nimport * as AstUtils from './ast-utils.js';\nimport * as Cancellation from './cancellation.js';\nimport * as CstUtils from './cst-utils.js';\nimport * as GrammarUtils from './grammar-utils.js';\nimport * as RegExpUtils from './regexp-utils.js';\nexport { AstUtils, Cancellation, CstUtils, GrammarUtils, RegExpUtils };\n"],"names":[],"mappings":"AAAA;;;;gFAIgF","ignoreList":[0]}},
    {"offset": {"line": 8933, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8961, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/validation/index.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport * from './document-validator.js';\nexport * from './validation-registry.js';\n"],"names":[],"mappings":"AAAA;;;;gFAIgF","ignoreList":[0]}},
    {"offset": {"line": 8969, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8985, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/workspace/index.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport * from './ast-descriptions.js';\nexport * from './ast-node-locator.js';\nexport * from './configuration.js';\nexport * from './document-builder.js';\nexport * from './documents.js';\nexport * from './file-system-provider.js';\nexport * from './index-manager.js';\nexport * from './workspace-lock.js';\nexport * from './workspace-manager.js';\n"],"names":[],"mappings":"AAAA;;;;gFAIgF","ignoreList":[0]}},
    {"offset": {"line": 9000, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9023, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///workspaces/atosjs/apps/website/docs/apps/website/docs/node_modules/langium/src/index.ts"],"sourcesContent":["/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nexport * from './default-module.js';\nexport * from './dependency-injection.js';\nexport * from './service-registry.js';\nexport * from './services.js';\nexport * from './syntax-tree.js';\nexport * from './documentation/index.js';\nexport * from './languages/index.js';\nexport * from './parser/index.js';\nexport * from './references/index.js';\nexport * from './serializer/index.js';\nexport * from './utils/index.js';\nexport * from './validation/index.js';\nexport * from './workspace/index.js';\n\n// Export the Langium Grammar AST definitions in the `GrammarAST` namespace\nimport * as GrammarAST from './languages/generated/ast.js';\nimport type { Grammar } from './languages/generated/ast.js';\nexport { Grammar, GrammarAST };\n"],"names":[],"mappings":"AAAA;;;;gFAIgF","ignoreList":[0]}},
    {"offset": {"line": 9044, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}